/**
 * Sequoia: Database clustering technology.
 * Copyright (C) 2002-2004 French National Institute For Research In Computer
 * Science And Control (INRIA).
 * Copyright (C) 2005 AmicoSoft, Inc. dba Emic Networks
 * Copyright (C) 2005-2006 Continuent, Inc.
 * Contact: sequoia@continuent.org
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 *
 * Initial developer(s): Emmanuel Cecchet.
 * Contributor(s): Vadim Kassin, Jean-Bernard van Zuylen.
 */

package org.continuent.sequoia.driver;

import java.sql.BatchUpdateException;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Vector;
import java.util.regex.Matcher;

import org.continuent.sequoia.common.exceptions.NotImplementedException;
import org.continuent.sequoia.common.protocol.Field;
import org.continuent.sequoia.common.sql.Request;
import org.continuent.sequoia.common.sql.RequestWithResultSetParameters;

/**
 * A <code>Statement</code> object is used for executing a static SQL
 * statement and obtaining the results produced by it.
 * <p>
 * Only one <code>ResultSet</code> per <code>Statement</code> can be open at
 * any point in time. Therefore, if the reading of one <code>ResultSet</code>
 * is interleaved with the reading of another, each must have been generated by
 * different <code>Statements</code>. All <code>Statements</code> execute
 * methods implicitly close a statement's current <code>ResultSet</code> if an
 * open one exists.
 * 
 * @see java.sql.Statement
 * @see DriverResultSet
 * @author <a href="mailto:Emmanuel.Cecchet@inria.fr">Emmanuel Cecchet </a>
 * @author <a href="mailto:vadim@kase.kz">Vadim Kassin </a>
 * @author <a href="mailto:jbvanzuylen@transwide.com">Jean-Bernard van Zuylen
 *         </a>
 * @version 1.0
 */
public class Statement implements java.sql.Statement
{
  /** The Driver used to create connections */
  protected Driver     driver;

  /** The connection that created us */
  protected Connection connection           = null;

  /** Vector for batch commands */
  protected Vector<Object>     batch                = null;

  /** The warnings chain - package private */
  SQLWarning           warnings             = null;

  /** The current result for a read request */
  protected ResultSet  result               = null;

  /** List of updateCount/ResultSet */
  protected LinkedList<Object> resultList           = null;
  protected Iterator<?>   resultListIterator   = null;

  /** The update count for a write request */
  protected int        updateCount          = -1;

  /** Query timeout in seconds (0 means no timeout) */
  protected int        timeout              = 0;

  /** Default ResultSet fetch size */
  private int          fetchSize            = 0;
  /** Cursor name used jointly with fetch size */
  private String       cursorName;

  /** Type of the ResultSet defaults to TYPE_FORWARD_ONLY */
  private int          resultSetType        = ResultSet.TYPE_FORWARD_ONLY;

  /** ResultSet Concurrency defaults to CONCUR_READ_ONLY */
  private int          resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;

  /** Maximum field size (unused) */
  private int          maxFieldSize         = 0;

  /** Maximum number of rows */
  private int          maxRows              = 0;

  /**
   * Direction for fetching rows from ResultSet (note that this hint is
   * currently ignored
   */
  private int          fetchDirection       = ResultSet.FETCH_FORWARD;

  /**
   * Should the driver to escape processing before sending to the DB?
   */
  protected boolean    escapeProcessing     = true;

  /** Auto generated keys */
  protected ResultSet  generatedKeys        = null;
  protected int        generatedKeysFlag    = java.sql.Statement.NO_GENERATED_KEYS;

  /**
   * Creates a new <code>Statement</code> instance.
   * 
   * @param c the <code>Connection</code> that created us
   * @param driver tje <code>Driver</code> used to create connections
   */
  Statement(Connection c, Driver driver)
  {
    connection = c;
    this.driver = driver;

    // BEWARE: large fetch size defaults can conflict with max rows settings
    // in the application.
    this.fetchSize = c.getDefaultFetchSize();
  }

  /**
   * Closes the ResultSet attached to this statement
   * 
   * @see #close()
   */
  protected void finalize() throws Throwable
  {
    this.close();
    super.finalize();
  }

  /**
   * Adds sql to the current list of commands.
   * 
   * @param sql an SQL statement that returns an update count (INSERT or UPDATE)
   * @exception SQLException if an error occurs
   */
  public synchronized void addBatch(String sql) throws SQLException
  {
    if (batch == null)
      batch = new Vector<Object>();
    batch.addElement(sql.trim());
  }

  /**
   * Could be use by one thread to cancel a statement that is being executed by
   * another thread. We don't support that for instance.
   * 
   * @exception SQLException if an error occurs
   */
  public void cancel() throws SQLException
  {
    throw new NotImplementedException("cancel()");
  }

  /**
   * Empties the current list of commands.
   * 
   * @exception SQLException if an error occurs
   */
  public void clearBatch() throws SQLException
  {
    if (batch != null)
      batch.removeAllElements();
  }

  /**
   * After this call, <code>getWarnings</code> returns <code>null</code>
   * until a new warning is reported for this <code>Statement</code>.
   * 
   * @exception SQLException if a database access error occurs (why?)
   */
  public void clearWarnings() throws SQLException
  {
    warnings = null;
  }

  /**
   * Utility to add warnings to a given warning chain.
   * 
   * @param addMe (in) warnings to be added
   * @param toThis (in/out) reference chain on which to add addMe. If null, will
   *            be equal to addMe after the function returns
   */
  protected void addWarningTo(SQLWarning addMe, SQLWarning toThis)
  {
    if (toThis != null)
      toThis.setNextWarning(warnings);
    else
      toThis = warnings;
  }

  /**
   * Execute a batch of commands
   * 
   * @return an array containing update count that corresponding to the commands
   *         that executed successfully
   * @exception BatchUpdateException if an error occurs on one statement (the
   *                number of updated rows for the successfully executed
   *                statements can be found in
   *                BatchUpdateException.getUpdateCounts())
   */
  public int[] executeBatch() throws BatchUpdateException
  {
    if (batch == null || batch.isEmpty())
      return new int[0];

    ArrayList<Object> generatedKeysData = null;
    Field generatedKeysField = null;
    if (connection.isAlwaysGettingGeneratedKeys())
      generatedKeysData = new ArrayList<Object>();

    int size = batch.size();
    int[] batchResult = new int[size];
    int i = 0;
    // must keep warning in a separate place otherwise they will be erased at
    // each call to executeUpdate()
    SQLWarning allWarnings = null;
    try
    {
      for (i = 0; i < size; i++)
      {
        batchResult[i] = this.executeUpdate((String) batch.elementAt(i));
        if (warnings != null)
          addWarningTo(warnings, allWarnings);
        if (connection.isAlwaysGettingGeneratedKeys())
        {
          if (generatedKeys != null)
          {
            while (generatedKeys.next())
            {
              generatedKeysData.add(generatedKeys.getObject(1));
              if (generatedKeysField == null)
              {
                ResultSetMetaData metaData = generatedKeys.getMetaData();
                generatedKeysField = new Field(metaData.getTableName(1),
                    metaData.getColumnName(1),
                    metaData.getColumnDisplaySize(1),
                    metaData.getColumnType(1), metaData.getColumnTypeName(1),
                    metaData.getColumnClassName(1));
              }
            }
          }
        }
      }
      // make one chain with all generated warnings
      warnings = allWarnings;
      generatedKeys = new DriverResultSet(connection, generatedKeysData,
          generatedKeysField);
      return batchResult;
    }
    catch (SQLException e)
    {
      String message = "Batch failed for request " + i + ": "
          + batch.elementAt(i) + " (" + e + ")";

      int[] updateCounts = new int[i];
      System.arraycopy(batchResult, 0, updateCounts, 0, i);

      throw new BatchUpdateException(message, updateCounts);
    }
    finally
    {
      batch.removeAllElements();
    }
  }

  /**
   * In many cases, it is desirable to immediately release a Statement's
   * database and JDBC resources instead of waiting for this to happen when it
   * is automatically closed. The close method provides this immediate release.
   * <p>
   * <B>Note: </B> A Statement is automatically closed when it is garbage
   * collected. When a Statement is closed, its current ResultSet, if one
   * exists, is also closed.
   * 
   * @exception SQLException if a database access error occurs (why?)
   */
  public void close() throws SQLException
  {
    // Force the ResultSet to close
    if (result != null)
      try
      {
        result.close();
      }
      catch (SQLException ignore)
      {
      }

    // Disasociate it from us (For Garbage Collection)
    result = null;
    connection = null;
  }

  /**
   * Check if the statement is closed and cleanup the last results if any
   * (update count is reset and last result is closed).
   * 
   * @throws SQLException if the Statement is closed.
   */
  private void checkIfClosedAndCleanupLastResult() throws SQLException
  {
    if (isClosed())
      throw new SQLException("Unable to execute query on a closed statement");

    updateCount = -1; // invalidate the last write result
    if (result != null)
    { // Discard the previous result
      try
      {
        result.close();
      }
      catch (Exception ignore)
      {
      }
      result = null;
    }
    if (generatedKeys != null)
    { // Discard the previous generated keys
      try
      {
        generatedKeys.close();
      }
      catch (Exception ignore)
      {
      }
      generatedKeys = null;
    }
    resultList = null;
    resultListIterator = null;
    clearWarnings();
  }

  /**
   * Returns true if the given SQL query can be mapped to a JDBC call. This is
   * the case for example of BEGIN, COMMIT or ROLLBACK that can be mapped to the
   * corresponding JDBC calls.
   * 
   * @param sqlQuery the SQL statement to try to map
   * @return true if the SQL has been mapped to a JDBC call
   */
  private boolean sqlHasBeenMappedToJDBCCall(String sqlQuery)
      throws SQLException
  {
    final JDBCRegExp jdbcRegExp = driver.getJDBCRegExp();
    if (jdbcRegExp.getBeginPattern().matcher(sqlQuery).matches())
    {
      connection.setAutoCommit(false);
      return true;
    }
    if (jdbcRegExp.getCommitPattern().matcher(sqlQuery).matches())
    {
      connection.commit();
      return true;
    }
    Matcher m = jdbcRegExp.getRollbackToSavepointPattern().matcher(sqlQuery);
    if (m.matches())
    {
      // Extract the savepoint name after the pattern
      connection.rollback(new Savepoint(sqlQuery.substring(m.end(),
          sqlQuery.length()).trim()));
      return true;
    }
    m = jdbcRegExp.getReleaseSavepointPattern().matcher(sqlQuery);
    if (m.matches())
    {
      // Extract the savepoint name after the pattern
      connection.releaseSavepoint(new Savepoint(sqlQuery.substring(m.end(),
          sqlQuery.length()).trim()));
      return true;
    }
    if (jdbcRegExp.getRollbackPattern().matcher(sqlQuery).matches())
    {
      connection.rollback();
      return true;
    }
    if (jdbcRegExp.getSetReadOnlyTransactionPattern().matcher(sqlQuery)
        .matches())
    {
      connection.setReadOnly(true);
      return true;
    }
    m = jdbcRegExp.getSetSavepointPattern().matcher(sqlQuery);
    if (m.matches())
    {
      // Extract the savepoint name after the pattern
      connection.setSavepoint(sqlQuery.substring(m.end(), sqlQuery.length())
          .trim());
      return true;
    }
    m = jdbcRegExp.getSetAutocommit1Pattern().matcher(sqlQuery);
    if (m.matches())
    {
      connection.setAutoCommit(true);
      return true;
    }
    m = jdbcRegExp.getSetIsolationLevelPattern().matcher(sqlQuery);
    if (m.matches())
    {
      String isolationLevel = sqlQuery.substring(m.end(), sqlQuery.length())
          .toLowerCase();
      if (isolationLevel.startsWith("read commited"))
      {
        connection
            .setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
        return true;
      }
      if (isolationLevel.startsWith("read uncommited"))
      {
        connection
            .setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
        return true;
      }
      if (isolationLevel.startsWith("repeatable read"))
      {
        connection
            .setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
        return true;
      }
      if (isolationLevel.startsWith("serializable"))
      {
        connection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);

        return true;
      }
    }
    return false;
  }

  /**
   * Execute a SQL statement that may return multiple results.
   * 
   * @param sql any SQL statement
   * @return true if the result is a ResultSet or false if it is an integer
   * @exception SQLException if an error occurs
   */
  public boolean execute(String sql) throws SQLException
  {
    if (connection.isAlwaysGettingGeneratedKeys())
    {
      if (requestMightGenerateKeys(sql))
        return execute(sql, RETURN_GENERATED_KEYS);
    }
    return execute(sql.trim(), (String) null);
  }

  /**
   * Execute a SQL statement that returns a single ResultSet
   * 
   * @param sqlSkeleton the SQL request squeleton or null
   * @param parameters PreparedStaement parameters
   * @return a ResulSet that contains the data produced by the query
   * @throws SQLException if a database access error occurs or if this statement
   *             is closed
   */
  @SuppressWarnings("unchecked")
protected boolean execute(String sqlSkeleton, String parameters)
      throws SQLException
  {
    checkIfClosedAndCleanupLastResult();

    if (sqlHasBeenMappedToJDBCCall(sqlSkeleton))
      return false;

    RequestWithResultSetParameters request = new RequestWithResultSetParameters(
        sqlSkeleton, parameters, escapeProcessing, timeout);
    setReadRequestParameters(request);
    ResultAndWarnings resultAndWarns = connection.statementExecute(request);
    this.warnings = resultAndWarns.getStatementWarnings();
    resultList = (LinkedList<Object>) resultAndWarns.getResultList();
    resultListIterator = resultList.iterator();
    generatedKeys = new DriverResultSet(this.connection, true);
    return getMoreResults();
  }

  /**
   * Execute a SQL statement that returns a single ResultSet
   * 
   * @param sql typically a static SQL <code>SELECT</code> statement
   * @return a ResulSet that contains the data produced by the query
   * @exception SQLException if a database access error occurs
   */
  public java.sql.ResultSet executeQuery(String sql) throws SQLException
  {
    return executeQuery(sql.trim(), null);
  }

  /**
   * Execute a SQL statement that returns a single ResultSet
   * 
   * @param sqlSkeleton the SQL request squeleton or null
   * @param parameters PreparedStaement parameters
   * @return a ResulSet that contains the data produced by the query
   * @exception SQLException if a database access error occurs or if this
   *                statement is closed
   */
  protected java.sql.ResultSet executeQuery(String sqlSkeleton,
      String parameters) throws SQLException
  {
    checkIfClosedAndCleanupLastResult();

    if (sqlHasBeenMappedToJDBCCall(sqlSkeleton))
      // In theory executeQuery() is not allowed to return null,
      // but after all we are here catering for some user's mistake in the
      // first place (i.e., committing using executeQuery()).
      // We can hardly imagine he will go as far as _using_ this resultset!
      return null;

    RequestWithResultSetParameters request = new RequestWithResultSetParameters(
        sqlSkeleton, parameters, escapeProcessing, timeout);
    setReadRequestParameters(request);
    DriverResultSet drs = connection.statementExecuteQuery(request);
    drs.setStatement(this);
    this.warnings = drs.getStatementWarnings();
    this.result = drs;
    // query does not generate key, so create an empty result set for it
    generatedKeys = new DriverResultSet(this.connection, true);

    return result;
  }

  protected void setReadRequestParameters(RequestWithResultSetParameters request)
  {
    request.setMaxRows(maxRows);
    request.setFetchSize(fetchSize);
    request.setCursorName(cursorName);
  }

  /**
   * Execute a SQL INSERT, UPDATE or DELETE statement. In addition SQL
   * statements that return nothing such as SQL DDL statements can be executed
   * 
   * @param sql a SQL statement
   * @return either a row count, or 0 for SQL commands
   * @exception SQLException if a database access error occurs
   */
  public int executeUpdate(String sql) throws SQLException
  {
    if (connection.isAlwaysGettingGeneratedKeys())
      generatedKeysFlag = RETURN_GENERATED_KEYS;
    return executeUpdateWithSkeleton(sql.trim(), null);
  }

  /**
   * Execute a SQL INSERT, UPDATE or DELETE statement. In addition SQL
   * statements that return nothing such as SQL DDL statements can be executed
   * 
   * @param sqlSkeleton the SQL request squeleton or null
   * @param parameters PreparedStaement parameters
   * @return either a row count, or 0 for SQL commands
   * @exception SQLException if a database access error occurs or if this
   *                statement is closed
   */
  protected int executeUpdateWithSkeleton(String sqlSkeleton, String parameters)
      throws SQLException
  {
    checkIfClosedAndCleanupLastResult();

    if (sqlHasBeenMappedToJDBCCall(sqlSkeleton))
      return 0;

    Request request = new Request(sqlSkeleton, parameters, escapeProcessing,
        timeout);

    if (generatedKeysFlag == java.sql.Statement.RETURN_GENERATED_KEYS)
    { // Get the auto generated key back
      DriverGeneratedKeysResult answer = connection
          .statementExecuteUpdateWithKeys(request);
      generatedKeys = answer.getDriverResultSet();
      updateCount = answer.getUpdateCount();
      warnings = answer.getWarnings();
      return answer.getUpdateCount();
    }
    else
    { // No generated keys
      ResultAndWarnings resultAndWarns = connection
          .statementExecuteUpdate(request);
      this.warnings = resultAndWarns.getStatementWarnings();
      updateCount = resultAndWarns.getUpdateCount();
      generatedKeys = new DriverResultSet(this.connection, true);
      return updateCount;
    }
  }

  /**
   * Retrieve the connection that created this Statement object
   * 
   * @return a <code>java.sql.Connection</code> object
   * @exception SQLException never
   */
  public java.sql.Connection getConnection() throws SQLException
  {
    return connection;
  }

  /**
   * @see java.sql.Statement#getFetchDirection()
   */
  public int getFetchDirection() throws SQLException
  {
    return fetchDirection;
  }

  /**
   * @see java.sql.Statement#getFetchSize()
   */
  public int getFetchSize() throws SQLException
  {
    return fetchSize;
  }

  /**
   * The maxFieldSize limit (in bytes) is the maximum amount of data returned
   * for any column value; it only applies to <code>BINARY</code>,
   * <code>VARBINARY</code>,<code>LONGVARBINARY</code>,<code>CHAR</code>,
   * <code>VARCHAR</code> and <code>LONGVARCHAR</code> columns. If the limit
   * is exceeded, the excess data is silently discarded.
   * <p>
   * <b>Note: </b> We don't do anything with this value yet.
   * 
   * @return the current max column size limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public int getMaxFieldSize() throws SQLException
  {
    return maxFieldSize;
  }

  /**
   * The maxRows limit is set to limit the number of rows that any
   * <code>ResultSet</code> can contain. If the limit is exceeded, the excess
   * rows are silently dropped.
   * 
   * @return the current maximum row limit; zero means unlimited
   * @exception SQLException if a database access error occurs
   */
  public int getMaxRows() throws SQLException
  {
    return maxRows;
  }

  /**
   * Return the true if next available result is a ResultSet or false it this is
   * an update count. If the result is false and getUpdateCount() returns -1
   * then there is no more result
   * <p>
   * Any open ResultSet is implicitly closed.
   * 
   * @return true for a ResultSet, false otherwise
   * @exception SQLException if an error occurs
   */
  public boolean getMoreResults() throws SQLException
  {
    return getMoreResults(CLOSE_CURRENT_RESULT);
  }

  /**
   * The queryTimeout limit is the number of seconds the driver will wait for a
   * Statement to execute. If the limit is exceeded, a <code>SQLException</code>
   * is thrown.
   * 
   * @return the current query timeout limit in seconds; 0 = unlimited
   * @exception SQLException if a database access error occurs
   */
  public int getQueryTimeout() throws SQLException
  {
    return timeout;
  }

  /**
   * Returns the current result as a <code>ResultSet</code>.
   * 
   * @return the current result set; null if there are no more
   * @exception SQLException never
   */
  public java.sql.ResultSet getResultSet() throws SQLException
  {
    return result;
  }

  /**
   * Retrieve the concurrency mode for the <code>ResultSet</code>.
   * 
   * @return <code>CONCUR_READ_ONLY</code> or <code>CONCUR_UPDATABLE</code>
   * @exception SQLException never
   */
  public int getResultSetConcurrency() throws SQLException
  {
    return resultSetConcurrency;
  }

  /**
   * Retrieve the type of the generated <code>ResultSet</code>.
   * 
   * @return one of <code>TYPE_FORWARD_ONLY</code> or
   *         <code>TYPE_SCROLL_INSENSITIVE</code>
   * @exception SQLException never
   */
  public int getResultSetType() throws SQLException
  {
    return resultSetType;
  }

  /**
   * Returns the current result as an update count, if the result is a
   * <code>ResultSet</code> or there are no more results, -1 is returned. It
   * should only be called once per result.
   * 
   * @return the current result as an update count.
   * @exception SQLException if a database access error occurs
   */
  public int getUpdateCount() throws SQLException
  {
    return updateCount;
  }

  /**
   * The first warning reported by calls on this Statement is returned. A
   * Statement's execute methods clear its SQLWarning chain. Subsequent
   * <code>Statement</code> warnings will be chained to this SQLWarning.
   * <p>
   * The Warning chain is automatically cleared each time a statement is
   * (re)executed.
   * <p>
   * <B>Note: </B> if you are processing a <code>ResultSet</code> then any
   * warnings associated with <code>ResultSet</code> reads will be chained on
   * the <code>ResultSet</code> object.
   * 
   * @return the first SQLWarning on null
   * @exception SQLException if a database access error occurs or this method is
   *                called on a closed statement
   */
  public SQLWarning getWarnings() throws SQLException
  {
    if (isClosed())
      throw new SQLException("Unable to get warnings on a closed statement");
    return warnings;
  }

  /**
   * Defines the SQL cursor name that will be used by subsequent execute
   * methods. This name can then be used in SQL positioned update/delete
   * statements to identify the current row in the ResultSet generated by this
   * statement. If a database doesn't support positioned update/delete, this
   * method is a no-op.
   * <p>
   * 
   * @param name the new cursor name
   * @exception SQLException not supported
   */
  public void setCursorName(String name) throws SQLException
  {
    cursorName = name;
  }

  /**
   * If escape scanning is on (the default), the driver will do escape
   * substitution before sending the SQL to the database.
   * 
   * @param enable true to enable; false to disable
   * @exception SQLException if a database access error occurs
   */
  public void setEscapeProcessing(boolean enable) throws SQLException
  {
    escapeProcessing = enable;
  }

  /**
   * @see java.sql.Statement#setFetchDirection(int)
   */
  public void setFetchDirection(int direction) throws SQLException
  {
    if ((direction == ResultSet.FETCH_FORWARD)
        || (direction == ResultSet.FETCH_REVERSE)
        || (direction == ResultSet.FETCH_UNKNOWN))
      this.fetchDirection = direction;
    else
      throw new SQLException("Unsupported direction " + direction
          + " in setFetchDirection");
  }

  /**
   * Set the default fetch size for the produced ResultSet.
   * 
   * @param rows number of rows that should be fetched from the database
   * @exception SQLException if a database access error occurs or the condition
   *                0 <= size <= this.getMaxRows is not satisfied
   */
  public void setFetchSize(int rows) throws SQLException
  {
    if (rows < 0
    // The spec forgets the case maxRows = 0.
        || 0 < maxRows && maxRows < rows)
    {
      throw new SQLException("Invalid fetch size value: " + rows);
    }
    // It also forgets the case where maxRows is set < fetchSize AFTERwards,
    // but we don't care about it.

    fetchSize = rows;
  }

  /**
   * Sets the <code>maxFieldSize</code>.
   * 
   * @param max the new max column size limit; 0 means unlimited
   * @exception SQLException if a database access error occurs or the condition
   *                max >= 0 is not satisfied
   */
  public void setMaxFieldSize(int max) throws SQLException
  {
    if (max < 0)
    {
      throw new SQLException("Invalid max field size value: " + max);
    }
    maxFieldSize = max;
  }

  /**
   * Sets the maximum number of rows that any <code>ResultSet</code> can
   * contain.
   * 
   * @param max the new max rows limit; 0 means unlimited
   * @exception SQLException if a database access error occurs or the condition
   *                max >= 0 is not satisfied
   */
  public void setMaxRows(int max) throws SQLException
  {
    if (max < 0)
    {
      throw new SQLException("Invalid max rows limit: " + max);
    }
    // this may break fetchSize <= maxRows
    maxRows = max;
  }

  /**
   * Sets the number of seconds the driver will wait for a
   * <code>Statement</code> object to execute.
   * 
   * @param seconds the new query timeout limit in seconds; 0 means no timeout
   * @exception SQLException if a database access error occurs or the condition
   *                seconds >= 0 is not satisfied
   */
  public void setQueryTimeout(int seconds) throws SQLException
  {
    if (seconds < 0)
    {
      throw new SQLException("Invalid query timeout value: " + seconds);
    }
    timeout = seconds;
  }

  /**
   * @param value an <code>int</code> value
   * @exception SQLException if an error occurs
   */
  public void setResultSetConcurrency(int value) throws SQLException
  {
    switch (value)
    {
      case ResultSet.CONCUR_READ_ONLY :
      case ResultSet.CONCUR_UPDATABLE :
        resultSetConcurrency = value;
        break;
      default :
        throw new SQLException("Invalid ResultSet " + "concurrency mode: "
            + value);
    }
  }

  /**
   * @param value an <code>int</code> value
   * @exception SQLException if an error occurs
   */
  public void setResultSetType(int value) throws SQLException
  {
    switch (value)
    {
      case ResultSet.TYPE_FORWARD_ONLY :
      case ResultSet.TYPE_SCROLL_INSENSITIVE :
        resultSetType = value;
        break;
      case ResultSet.TYPE_SCROLL_SENSITIVE :
        throw new SQLException(
            "TYPE_SCROLL_SENSITIVE is not a supported ResultSet type");
      default :
        throw new SQLException("Invalid ResultSet type");
    }
  }

  // --------------------------JDBC 3.0-----------------------------

  /**
   * Moves to this <code>Statement</code> object's next result, deals with any
   * current <code>ResultSet</code> object(s) according to the instructions
   * specified by the given flag, and returns <code>true</code> if the next
   * result is a <code>ResultSet</code> object.
   * <p>
   * There are no more results when the following is <code>true</code>:
   * 
   * <pre>(!getMoreResults() &amp;&amp; (getUpdateCount() == -1)</pre>
   * 
   * @param current one of the following <code>Statement</code> constants
   *          indicating what should happen to current <code>ResultSet</code>
   *          objects obtained using the method
   *          <code>getResultSet</code: <code>CLOSE_CURRENT_RESULT</code>,
   *          <code>KEEP_CURRENT_RESULT</code>, or <code>CLOSE_ALL_RESULTS</code>
   * @return <code>true</code> if the next result is a <code>ResultSet</code>
   *         object; <code>false</code> if it is an update count or there are
   *         no more results
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   * @see #execute(String)
   */
  public boolean getMoreResults(int current) throws SQLException
  {
    // TODO: actually support CLOSE_ALL_RESULTS by calling result.close()
    // on ALL previous resultsets.
    if (current != KEEP_CURRENT_RESULT)
    {
      if (result != null)
        try
        {
          result.close();
        }
        catch (SQLException ignore)
        {
        }
    }

    // Reset results so getResultSet() will return null if this is an
    // update count, and getUpdateCount() will return -1 otherwise
    updateCount = -1;
    result = null;

    if (resultListIterator == null || !resultListIterator.hasNext())
    {
      // End of list, return false
      return false;
    }

    Object nextResult = resultListIterator.next();
    if (nextResult instanceof DriverResultSet)
    {
      // The previous ResultSet was NOT being streamed, this is currently
      // incompatible with the generic LinkList this.execute() by design:
      // VirtualDatabaseWorkerThread always returns FULL resultsets when using
      // .execute()
      result = (ResultSet) nextResult;

      // FIXME: why did we miss this at construction time and left a half-built
      // DriverResultSet?
      ((DriverResultSet) result).setStatement(this);
      return true;
    }
    if (nextResult instanceof Integer)
    {
      updateCount = ((Integer) nextResult).intValue();
      return false;
    }
    throw new SQLException("Unexpected result type in getMoreResults ("
        + nextResult + ")");
  }

  /**
   * Retrieves any auto-generated keys created as a result of executing this
   * <code>Statement</code> object. If this <code>Statement</code> object
   * did not generate any keys, an empty <code>ResultSet</code> object is
   * returned.
   * 
   * @return a <code>ResultSet</code> object containing the auto-generated
   *         key(s) generated by the execution of this <code>Statement</code>
   *         object
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public java.sql.ResultSet getGeneratedKeys() throws SQLException
  {
    return generatedKeys;
  }

  /**
   * Executes the given SQL statement and signals the driver with the given flag
   * about whether the auto-generated keys produced by this
   * <code>Statement</code> object should be made available for retrieval.
   * 
   * @param sql must be an SQL <code>INSERT</code>,<code>UPDATE</code> or
   *            <code>DELETE</code> statement or an SQL statement that returns
   *            nothing
   * @param autoGeneratedKeys a flag indicating whether auto-generated keys
   *            should be made available for retrieval; one of the following
   *            constants: <code>Statement.RETURN_GENERATED_KEYS</code>
   * <code>Statement.NO_GENERATED_KEYS</code>
   * @return either the row count for <code>INSERT</code>,
   *         <code>UPDATE</code> or <code>DELETE</code> statements, or
   *         <code>0</code> for SQL statements that return nothing
   * @exception SQLException if a database access error occurs, the given SQL
   *                statement returns a <code>ResultSet</code> object, or the
   *                given constant is not one of those allowed
   * @since JDK 1.4
   */
  public int executeUpdate(String sql, int autoGeneratedKeys)
      throws SQLException
  {
    if (!connection.isAlwaysGettingGeneratedKeys())
      generatedKeysFlag = autoGeneratedKeys;
    else
      generatedKeysFlag = RETURN_GENERATED_KEYS;
    int executeUpdateResult = executeUpdate(sql);
    if (!connection.isAlwaysGettingGeneratedKeys())
      generatedKeysFlag = NO_GENERATED_KEYS;
    return executeUpdateResult;
  }

  /**
   * Executes the given SQL statement and signals the driver that the
   * auto-generated keys indicated in the given array should be made available
   * for retrieval. The driver will ignore the array if the SQL statement is not
   * an <code>INSERT</code> statement.
   * 
   * @param sql an SQL <code>INSERT</code>,<code>UPDATE</code> or
   *            <code>DELETE</code> statement or an SQL statement that returns
   *            nothing, such as an SQL DDL statement
   * @param columnIndexes an array of column indexes indicating the columns that
   *            should be returned from the inserted row
   * @return either the row count for <code>INSERT</code>,
   *         <code>UPDATE</code>, or <code>DELETE</code> statements, or 0
   *         for SQL statements that return nothing
   * @exception SQLException if a database access error occurs or the SQL
   *                statement returns a <code>ResultSet</code> object
   * @since JDK 1.4
   */
  public int executeUpdate(String sql, int[] columnIndexes) throws SQLException
  {
    return executeUpdate(sql, RETURN_GENERATED_KEYS);
  }

  /**
   * Executes the given SQL statement and signals the driver that the
   * auto-generated keys indicated in the given array should be made available
   * for retrieval. The driver will ignore the array if the SQL statement is not
   * an <code>INSERT</code> statement.
   * 
   * @param sql an SQL <code>INSERT</code>,<code>UPDATE</code> or
   *            <code>DELETE</code> statement or an SQL statement that returns
   *            nothing
   * @param columnNames an array of the names of the columns that should be
   *            returned from the inserted row
   * @return either the row count for <code>INSERT</code>,
   *         <code>UPDATE</code>, or <code>DELETE</code> statements, or 0
   *         for SQL statements that return nothing
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public int executeUpdate(String sql, String[] columnNames)
      throws SQLException
  {
    return executeUpdate(sql, RETURN_GENERATED_KEYS);
  }

  /**
   * Executes the given SQL statement, which may return multiple results, and
   * signals the driver that any auto-generated keys should be made available
   * for retrieval. The driver will ignore this signal if the SQL statement is
   * not an <code>INSERT</code> statement.
   * <p>
   * In some (uncommon) situations, a single SQL statement may return multiple
   * result sets and/or update counts. Normally you can ignore this unless you
   * are (1) executing a stored procedure that you know may return multiple
   * results or (2) you are dynamically executing an unknown SQL string.
   * <p>
   * The <code>execute</code> method executes an SQL statement and indicates
   * the form of the first result. You must then use the methods
   * <code>getResultSet</code> or <code>getUpdateCount</code> to retrieve
   * the result, and <code>getMoreResults</code> to move to any subsequent
   * result(s).
   * 
   * @param sql any SQL statement
   * @param autoGeneratedKeys a constant indicating whether auto-generated keys
   *            should be made available for retrieval using the method
   *            <code>getGeneratedKeys</code>; one of the following
   *            constants: <code>Statement.RETURN_GENERATED_KEYS</code> or
   *            <code>Statement.NO_GENERATED_KEYS</code>
   * @return <code>true</code> if the first result is a <code>ResultSet</code>
   *         object; <code>false</code> if it is an update count or there are
   *         no results
   * @exception SQLException if a database access error occurs
   * @see #getResultSet
   * @see #getUpdateCount
   * @see #getMoreResults()
   * @see #getGeneratedKeys
   * @since JDK 1.4
   */
  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
  {
    generatedKeysFlag = autoGeneratedKeys;
    if (connection.isAlwaysGettingGeneratedKeys())
    {
      if (requestMightGenerateKeys(sql))
        generatedKeysFlag = RETURN_GENERATED_KEYS;

    }

    if (autoGeneratedKeys == RETURN_GENERATED_KEYS)
    {
      int executeUpdateResult = executeUpdate(sql);
      resultList = new LinkedList<Object>();
      resultList.add(new Integer(executeUpdateResult));
      resultListIterator = resultList.iterator();
      if (!connection.isAlwaysGettingGeneratedKeys())
        autoGeneratedKeys = NO_GENERATED_KEYS;
      return getMoreResults();
    }
    return execute(sql);
  }

  /**
   * Returns true if the given sql request is likely to generate keys (if it's
   * an insert or a replace)
   * 
   * @param sql request to analyze
   */
  static boolean requestMightGenerateKeys(String sql)
  {
    String request = removeLeadingCommentsFromRequest(sql.toLowerCase().trim());
    if (request.startsWith("insert") || request.startsWith("replace"))
      return true;
    return false;
  }

  /**
   * Removes comments (from /* to *\/) at the begining of the given request
   * 
   * @param request the string to remove leading comments from. Must not be
   *          null, must be trimmed
   */
  static String removeLeadingCommentsFromRequest(String request)
  {
    if (!request.startsWith("/*"))
      return request;
    // here, we know that the request starts with /*.
    // But there may be other comments after the first one => recurse until no
    // more leading
    // comment is found
    int endOfComment = request.indexOf("*/");
    // make sure unclosed comments are correctly returned (as empty string)
    if (endOfComment < 0)
      return "";
    return removeLeadingCommentsFromRequest(request.substring(endOfComment + 2)
        .trim());
  }

  /**
   * Executes the given SQL statement, which may return multiple results, and
   * signals the driver that the auto-generated keys indicated in the given
   * array should be made available for retrieval. This array contains the
   * indexes of the columns in the target table that contain the auto-generated
   * keys that should be made available. The driver will ignore the array if the
   * given SQL statement is not an <code>INSERT</code> statement.
   * <p>
   * Under some (uncommon) situations, a single SQL statement may return
   * multiple result sets and/or update counts. Normally you can ignore this
   * unless you are (1) executing a stored procedure that you know may return
   * multiple results or (2) you are dynamically executing an unknown SQL
   * string.
   * <p>
   * The <code>execute</code> method executes an SQL statement and indicates
   * the form of the first result. You must then use the methods
   * <code>getResultSet</code> or <code>getUpdateCount</code> to retrieve
   * the result, and <code>getMoreResults</code> to move to any subsequent
   * result(s).
   * 
   * @param sql any SQL statement
   * @param columnIndexes an array of the indexes of the columns in the inserted
   *            row that should be made available for retrieval by a call to the
   *            method <code>getGeneratedKeys</code>
   * @return <code>true</code> if the first result is a <code>ResultSet</code>
   *         object; <code>false</code> if it is an update count or there are
   *         no results
   * @exception SQLException if a database access error occurs
   * @see #getResultSet
   * @see #getUpdateCount
   * @see #getMoreResults()
   * @since JDK 1.4
   */
  public boolean execute(String sql, int[] columnIndexes) throws SQLException
  {
    return execute(sql, RETURN_GENERATED_KEYS);
  }

  /**
   * Executes the given SQL statement, which may return multiple results, and
   * signals the driver that the auto-generated keys indicated in the given
   * array should be made available for retrieval. This array contains the names
   * of the columns in the target table that contain the auto-generated keys
   * that should be made available. The driver will ignore the array if the
   * given SQL statement is not an <code>INSERT</code> statement.
   * <p>
   * In some (uncommon) situations, a single SQL statement may return multiple
   * result sets and/or update counts. Normally you can ignore this unless you
   * are (1) executing a stored procedure that you know may return multiple
   * results or (2) you are dynamically executing an unknown SQL string.
   * <p>
   * The <code>execute</code> method executes an SQL statement and indicates
   * the form of the first result. You must then use the methods
   * <code>getResultSet</code> or <code>getUpdateCount</code> to retrieve
   * the result, and <code>getMoreResults</code> to move to any subsequent
   * result(s).
   * 
   * @param sql any SQL statement
   * @param columnNames an array of the names of the columns in the inserted row
   *            that should be made available for retrieval by a call to the
   *            method <code>getGeneratedKeys</code>
   * @return <code>true</code> if the next result is a <code>ResultSet</code>
   *         object; <code>false</code> if it is an update count or there are
   *         no more results
   * @exception SQLException if a database access error occurs
   * @see #getResultSet
   * @see #getUpdateCount
   * @see #getMoreResults()
   * @see #getGeneratedKeys
   * @since JDK 1.4
   */
  public boolean execute(String sql, String[] columnNames) throws SQLException
  {
    return execute(sql, RETURN_GENERATED_KEYS);
  }

  /**
   * Retrieves the result set holdability for <code>ResultSet</code> objects
   * generated by this <code>Statement</code> object.
   * 
   * @return either <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or
   *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public int getResultSetHoldability() throws SQLException
  {
    return connection.getHoldability();
  }

  /**
   * Test if this statement is closed.
   * 
   * @return <code>true</code> if this statement is closed
   */
  public boolean isClosed()
  {
    return (connection == null);
  }

@Override
public <T> T unwrap(Class<T> iface) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public boolean isWrapperFor(Class<?> iface) throws SQLException {
	// TODO Auto-generated method stub
	return false;
}

@Override
public void setPoolable(boolean poolable) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public boolean isPoolable() throws SQLException {
	// TODO Auto-generated method stub
	return false;
}

@Override
public void closeOnCompletion() throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public boolean isCloseOnCompletion() throws SQLException {
	// TODO Auto-generated method stub
	return false;
}
}