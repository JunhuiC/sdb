/**
 * Sequoia: Database clustering technology.
 * Copyright (C) 2002-2004 French National Institute For Research In Computer
 * Science And Control (INRIA).
 * Copyright (C) 2006 Continuent, Inc.
 * Contact: sequoia@continuent.org
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 *
 * Initial developer(s): Emmanuel Cecchet.
 * Contributor(s): Jaco Swart.
 */

package org.continuent.sequoia.controller.loadbalancer.tasks;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.continuent.sequoia.common.exceptions.SQLExceptionFactory;
import org.continuent.sequoia.common.locks.TransactionLogicalLock;
import org.continuent.sequoia.controller.backend.DatabaseBackend;
import org.continuent.sequoia.controller.loadbalancer.BackendWorkerThread;
import org.continuent.sequoia.controller.requests.AbstractRequest;

/**
 * Defines an abstract task to be processed by a
 * <code>BackendWorkerThread</code>.
 * 
 * @author <a href="mailto:Emmanuel.Cecchet@inria.fr">Emmanuel Cecchet </a>
 * @author <a href="mailto:jaco.swart@iblocks.co.uk">Jaco Swart </a>
 * @version 1.0
 */
public abstract class AbstractTask
{
  //
  // How the code is organized ?
  // 1. Member variables
  // 2. Constructor(s)
  // 3. Task management
  // 4. Getter/Setter
  //

  /** Total number of threads. */
  private int       totalNb;

  /** Number of threads that must succeed before returning. */
  private int       nbToComplete;

  /** Number of thread that have started the execution of the task */
  private int       executionStarted;
  /** Number of backendThread that have succeeded */
  private int       success        = 0;
  /** Number of backendThread that have failed */
  private int       failed         = 0;
  /** List of backendThread that have notified this task */
  private List      notifications  = null;
  /** List of exceptions of failed nodes */
  private List      exceptions     = null;
  /** Map of Lists of locksMap taken by this task, indexed by backend */
  private Map       locksMap       = new HashMap();

  // ResultSet for getting back autogenerated keys in an update with keys
  private ResultSet generatedKeysResultSet;

  // True if the timeout has expired on this task
  private boolean   timeoutExpired = false;

  /** Query result on the fist backend to succeed. Used for sanity check */
  private int       resultOnFirstBackendToSucceed;

  /** True if this task executes on a persistent connection */
  private boolean   persistentConnection;

  /** Persistent connection id if persistentConnection is true */
  private long      persistentConnectionId;

  /*
   * Constructor
   */

  /**
   * Sets the number of threads among the total number of threads that must
   * successfully complete the execution of this AbstractTask before returning.
   * 
   * @param nbToComplete number of threads that must succeed before returning
   * @param totalNb total number of threads
   * @param isPersistentConnection true if this task executes on a persistent
   *          connection
   * @param persistentConnectionId persistent connection id if
   *          persistentConnection is true
   */
  public AbstractTask(int nbToComplete, int totalNb,
      boolean isPersistentConnection, long persistentConnectionId)
  {
    this.nbToComplete = nbToComplete;
    this.totalNb = totalNb;
    success = 0;
    failed = 0;
    executionStarted = 0;
    notifications = new ArrayList(nbToComplete);
    this.persistentConnection = isPersistentConnection;
    this.persistentConnectionId = persistentConnectionId;
  }

  /*
   * Task management
   */

  /**
   * The task code executed by the backendThread.
   * 
   * @param backendThread The backend thread executing this task
   * @throws SQLException if an error occurs
   */
  public void execute(BackendWorkerThread backendThread) throws SQLException
  {
    synchronized (this)
    {
      // If the task has expired and nobody has executed it yet, we ignore it
      // else we have to play it.
      // Note that the exception corresponding to the timeout is set by the
      // caller of setExpiredTimeout.
      if (timeoutExpired && (executionStarted == 0))
        return;
      this.executionStarted++;
    }
    executeTask(backendThread);
    // Completed executions are handled by the task internal code that calls
    // notifyFailure or notifySuccess.
  }

  /**
   * The implementation specific task code to be executed by backendThread.
   * 
   * @param backendThread The backend thread executing this task
   * @throws SQLException if an error occurs
   */
  public abstract void executeTask(BackendWorkerThread backendThread)
      throws SQLException;

  /**
   * This is used to notify the completion of this task without success or
   * failure. This is usually used when the task has been discarded for example
   * by a backend that is currently disabling but still needs to execute the
   * remaining queries in open transactions.
   * <p>
   * Therefore, this only decrements by one the number of threads that needs to
   * complete.
   * 
   * @param backendThread The backend worker thread notifying this task (null in
   *          case this task is cancelled before being processed by a worker
   *          thread)
   */
  public synchronized void notifyCompletion(BackendWorkerThread backendThread)
  {
    if ((backendThread != null) && !addNotification(backendThread))
      return;

    totalNb--;
    // Notify if needed
    if (success + failed >= totalNb)
    {
      notifyAll(); // Notify all failed threads
    }
  }

  /**
   * Notifies that the specified backendThread failed to execute this task. If
   * all nodes failed, this method return <code>false</code> meaning that the
   * problem was due to the task and not to the thread. If the method returns
   * <code>true</code>, it can mean that this thread failed and is no more
   * coherent, therefore the backend associated to this thread should be
   * disabled.
   * 
   * @param backendThread The backend thread notifying this task
   * @param timeout time in milliseconds to wait for other threads to signal
   *          success or failure (use -1 if you don't want to wait)
   * @param e the exception causing the failure
   * @return <code>true</code> if at least one node succeeded to execute this
   *         task, <code>false</code> if all threads failed
   * @throws SQLException if an error occured in the notification process
   */
  public synchronized boolean notifyFailure(BackendWorkerThread backendThread,
      long timeout, Throwable e) throws SQLException
  {
    if (!addNotification(backendThread))
    {
      if (backendThread != null)
        backendThread.getLogger().info(
            "Backend " + backendThread.getBackend() + " already notified task "
                + toString());
      return success > 0;
    }

    failed++;

    // Log the exception
    if (exceptions == null)
      exceptions = new ArrayList();
    String backendName;
    if (backendThread == null)
    { // Happens in case of cascade abort (see SEQUOIA-469)
      backendName = "Query not processed";
    }
    else
      backendName = backendThread.getName();

    if (e instanceof SQLException)
    {
      SQLException sqlEx = (SQLException) e;
      exceptions.add(SQLExceptionFactory.getSQLException(sqlEx, "Backend "
          + backendName + " failed (" + sqlEx.getLocalizedMessage() + ")"));
    }
    else
      exceptions.add(new SQLException("Backend " + backendName + " failed ("
          + e.getLocalizedMessage() + ")").initCause(e));

    // Notify if needed
    if (success + failed >= totalNb)
    {
      notifyAll(); // Notify all failed threads
    }
    else
    {
      if ((timeout > -1) && (success == 0))
      {
        try
        { // Wait to check if all other threads failed or not
          wait(timeout);
        }
        catch (InterruptedException ie)
        {
          throw (SQLException) new SQLException(
              "Wait interrupted() in failed task of backend " + backendName
                  + " (" + e.getLocalizedMessage() + ")").initCause(e);
        }
      }
    }
    return success > 0;
  }

  /**
   * Notifies the successful completion of this task.
   * 
   * @param backendThread The backend thread notifying this task
   */
  public synchronized void notifySuccess(BackendWorkerThread backendThread)

  {
    if (!addNotification(backendThread))
      return;

    doNotifySuccess();
  }

  /**
   * 
   */
  private void doNotifySuccess()
  {
    success++;

    // Notify if needed
    if ((success == nbToComplete) || (success + failed >= totalNb))
    {
      if (failed > 0)
        notifyAll(); // Notify all failed threads too
      else
        notify();
    }
  }

  /**
   * Notifies the successful completion of this task and provide the
   * resultOnFirstBackendToSucceed for checking.
   * 
   * @param backendThread The backend thread notifying this task
   * @param result the result of the query on the backend that notify the
   *          success
   * @return the result returned by the query on the first backend which
   *         succeeded
   */
  public synchronized int notifySuccess(BackendWorkerThread backendThread,
      int result)
  {
    if (success == 0)
    {
      /*
       * we keep only the result of the first backend to succeed which can be
       * used as a basis to check that success on other backends will be
       * consistent with that first result.
       */
      resultOnFirstBackendToSucceed = result;
    }

    /*
     * There is a nasty case if the database does not support
     * Statement.cancel(). When a deadlock is detected, the query will be
     * aborted and failure will be notified. But if the query cannot be
     * cancelled, it might be notified as a success later on. In this case, we
     * have to update resultOnFirstBackendToSucceed first (this is why the check
     * on addNotification is done after the update of
     * resultOnFirstBackendToSucceed.
     */
    if (!addNotification(backendThread))
      return resultOnFirstBackendToSucceed;

    doNotifySuccess();

    return resultOnFirstBackendToSucceed;
  }

  /**
   * Add a backend worker thread to the notification list
   * 
   * @param backendThread the backend worker thread to add
   * @return false if this thread already notified the task
   */
  private boolean addNotification(BackendWorkerThread backendThread)
  {
    if (notifications.contains(backendThread))
      return false;
    notifications.add(backendThread);
    return true;
  }

  //
  // Getter/Setter
  //

  /**
   * Returns true if this task is in autocommit mode, false if it is in a
   * transaction.
   * 
   * @return Returns true if task must be executed in autoCommit mode.
   * @see #getTransactionId()
   */
  public abstract boolean isAutoCommit();

  /**
   * Returns the exceptions lists.
   * 
   * @return an <code>List</code>
   */
  public List getExceptions()
  {
    return exceptions;
  }

  /**
   * Returns the number of threads that have started the execution of the task.
   * 
   * @return Returns the number of started executions.
   */
  public synchronized int getExecutionStarted()
  {
    return executionStarted;
  }

  /**
   * Set the flag to tell that the timeout has expired on this task. If no
   * backend has started the task execution then the task will be canceled and
   * the method will return true. Otherwise, all backends will execute the
   * request and the method will return false.
   * 
   * @return true if BackendThreads will ignore the task, false if all backends
   *         will execute the task.
   */
  public synchronized boolean setExpiredTimeout()
  {
    this.timeoutExpired = true;
    return executionStarted == 0;
  }

  /**
   * Returns the failed.
   * 
   * @return an <code>int</code> value
   */
  public int getFailed()
  {
    return failed;
  }

  /**
   * Returns the generatedKeysResultSet value.
   * 
   * @return Returns the generatedKeysResultSet.
   */
  public ResultSet getGeneratedKeysResultSet()
  {
    return generatedKeysResultSet;
  }

  /**
   * Sets the generatedKeysResultSet value.
   * 
   * @param generatedKeysResultSet The generatedKeysResultSet to set.
   */
  public void setGeneratedKeysResultSet(ResultSet generatedKeysResultSet)
  {
    this.generatedKeysResultSet = generatedKeysResultSet;
  }

  /**
   * Returns the locksMap taken by this task for a given backend.
   * 
   * @param backend backend for which to get the locksMap
   * @return Returns the locksMap.
   */
  public List getLocks(DatabaseBackend backend)
  {
    synchronized (locksMap)
    {
      return (List) locksMap.get(backend);
    }
  }

  /**
   * Sets the locksMap taken by this task for a given backend (ignored if the
   * locksMap were already set once).
   * 
   * @param backend backend for which to set the locksMap
   * @param locks The locks map taken.
   */
  public synchronized void setLocks(DatabaseBackend backend, List locks)
  {
    synchronized (locksMap)
    {
      /*
       * Use get instead of contains key, because sometimes a null entry is
       * added.
       */
      if (locksMap.get(backend) == null)
        locksMap.put(backend, locks);
      else
      {
        backend.getLogger().fatal(
            "Double locks entry: " + locks + " and " + locksMap.get(backend),
            new Exception());
      }
    }
  }

  /**
   * Adds a lock to the task lock list for the given backend.
   * 
   * @param backend backend to which lock list the given lock should be added
   * @param lock lock to be added
   */
  public synchronized void addLock(DatabaseBackend backend,
      TransactionLogicalLock lock)
  {
    List locks = (List) locksMap.get(backend);
    if (locks == null)
    {
      locks = new ArrayList();
      locksMap.put(backend, locks);
    }
    if (locks.contains(lock))
    {
      backend.getLogger().fatal(
          "Lock entry " + lock + " already present in " + locks);
    }
    else
      locks.add(lock);
  }

  /**
   * Returns the number of threads that must succeed before returning.
   * 
   * @return an <code>int</code> value
   */
  public int getNbToComplete()
  {
    return nbToComplete;
  }

  /**
   * Returns the persistentConnection value.
   * 
   * @return Returns the persistentConnection.
   */
  public final boolean isPersistentConnection()
  {
    return persistentConnection;
  }

  /**
   * Sets the persistentConnection value.
   * 
   * @param persistentConnection The persistentConnection to set.
   */
  public final void setPersistentConnection(boolean persistentConnection)
  {
    this.persistentConnection = persistentConnection;
  }

  /**
   * Returns the persistentConnectionId value.
   * 
   * @return Returns the persistentConnectionId.
   */
  public final long getPersistentConnectionId()
  {
    return persistentConnectionId;
  }

  /**
   * Sets the persistentConnectionId value.
   * 
   * @param persistentConnectionId The persistentConnectionId to set.
   */
  public final void setPersistentConnectionId(long persistentConnectionId)
  {
    this.persistentConnectionId = persistentConnectionId;
  }

  /**
   * Return the request associated with this task if any, returns null
   * otherwise.
   * 
   * @return the request associated with this task or null
   */
  public abstract AbstractRequest getRequest();

  /**
   * Returns the success.
   * 
   * @return an <code>int</code> value
   */
  public int getSuccess()
  {
    return success;
  }

  /**
   * Returns the total number of threads.
   * 
   * @return an <code>int</code> value
   * @see #setTotalNb
   */
  public int getTotalNb()
  {
    return totalNb;
  }

  /**
   * Sets the total number of threads.
   * 
   * @param totalNb the total number of threads to set
   * @see #getTotalNb
   */
  public void setTotalNb(int totalNb)
  {
    this.totalNb = totalNb;
  }

  /**
   * Returns the transaction identifier of this task if any (isAutoCommit
   * returns false).
   * 
   * @return Returns the transaction identifier.
   */
  public abstract long getTransactionId();

  /**
   * Returns true if the task has been sucessfully completed by nbToComplete
   * nodes (set in the constructor) of if everyone has completed (successfully
   * or not), false otherwise.
   * 
   * @return true if the task execution is complete
   * @see AbstractTask#AbstractTask(int, int)
   */
  public synchronized boolean hasCompleted()
  {
    return ((success >= nbToComplete) || (success + failed == totalNb));
  }

  /**
   * Returns true if the task has completed (successfully or not) or false if we
   * are still expecting answers from some backends.
   * 
   * @return true if the task execution is complete
   */
  public synchronized boolean hasFullyCompleted()
  {
    return success + failed == totalNb;
  }

}
