#############################################
######### Controller messages ########
#############################################

   ### Info Messages ###
controller.file.send=Xml Configuration file send to controller
# 0 => product name, 1 => product version
controller.info={0} controller ({1})
controller.ready=Controller {0} ready, listening to requests ...
controller.date=Controller started on {0}

   ### Actions on the controller ###
controller.add.driver.failed=Failed to add driver (because of : {0})
controller.add.driver.success=Driver successfully added to directory {0}
controller.add.jar.write.failed=Failed to write the bytes into a file
controller.add.jar.read.failed=Failed to write the bytes into a file
controller.add.jar.to.directory=Driver added to directory {0}
controller.add.jar.extract.dir=Extracting directory
controller.add.jar.extract.file=Extracting file
controller.add.virtualdatabases=Loading virtual databases configuration file
controller.add.virtualdatabases.failed=Loading of virtual databases configuration file failed (because of {0}).
controller.virtualdatabases.added=Loading of virtual databases configuration file has been successful
controller.add.virtualdatabase=Adding VirtualDatabase {0}
controller.add.virtualdatabase.already.used=The virtual database name {0} is already used in this controller.
controller.add.virtualdatabase.failed=The virtual database {0} could not be added to the controller (because of {1})
controller.add.virtualdatabase.success=The virtual database {0} has been successfully added to the controller.
# 0 => product name
controller.commandline.header=Launchs the {0} controller
controller.database.autoenable=The database backends are auto-enabled in mode {0}.
controller.driver.dir.not.found=Cannot find drivers directory {0}
controller.driver.extract.failed=Error extracting the driver file {0} : {1}
controller.loading.virtualdatabase=Loading New Virtual Database
# 0 => product name, 1 => exception
controller.loadXml.failed=Failed to send file to {0} controller: {1}
controller.logconfigfile.not.found=Cannot find Log4J configuration file 'log4j.properties' in classpath.
controller.refresh.log.success=Log refresh completed.
controller.update.log.success=Log update completed.
controller.removeVirtualDatabase.success=Removing virtual database from controller.
controller.save.configuration=Controller configuration saved in file {0}
controller.save.configuration.failed=Saving of controller configuration failed (because of {0})

   ### Jmx Notification Messages ###
notification.distributed.controller.added=Controller {0} has joined distributed virtual database {1}
# 0 => Member, 1 => VDB name
notification.distributed.controller.removed={0} has left distributed virtual database {1}
notification.virtualdatabase.added=The virtual database {0} has been added to the controller
notification.virtualdatabase.shutdown=The virtual database {0} has been successfully shut down
notification.backend.disabled=Disabled backend {0}
notification.backend.enabled=Enabled backend {0}
notification.backend.added=Added backend {0}
notification.backend.removed=Removed backend {0}
# 0 => vdb name
notification.distributed.vdb.network.partition=A network partition has been detected on virtual database {0}

   ### Configuration ###
controller.configure.commandline.error=Syntax error on the controller command line.
controller.configure.failed=Configuration of controller failed.
controller.configure.file.autoload=Autoload for config file: {0} has been set to: {1}
controller.configure.file.not.found=Configuration file not found {0}
controller.configure.invalid.iprange=Invalid IP range
controller.configure.jmx.fail.start=Failed to start the JMX server. ({0})
controller.configure.jmx.started=JMX server started
controller.configure.load.file.failed=Could not load config file: {0}. Error is: {1}.
controller.configure.file.not.in.classpath=Unable to find default controller.xml configuration file in CLASSPATH.
controller.configure.load.file.failed.minimum.configuration=Could not load config file: {0} ({1}). Loading minimum configuration.
controller.configure.loading.file=Loading configuration file: {0}
# 0 => controller configuration file
controller.configure.optional.file.invalid=Unable to access controller configuration file : {0}.
controller.configure.setup=Call to setup VirtualDatabase {0} with options [{1}:{2}]
controller.configure.start.jmx=Starting JMX server on host: {0}
controller.configure.unknown.option=Syntax error: unrecognized option : {0}
controller.configure.using=Using file: {0}
controller.configure.xml.file.error=Error while analysing xml configuration file ({0}).
controller.file.not.found=File not found: {0}

   ### Command Line ###
controller.commandline.footer= ---
controller.commandline.options=Options:
controller.commandline.option.help=Displays usage information.
controller.commandline.option.version=Displays version information.
controller.commandline.option.rmi=Optional JMX server RMI-Adaptor port number (the default is: {0} ). Also enables jmx.
controller.commandline.option.jmx=Optional JMX server HTTP-Adaptor port number (the default is: {0} ). Also enables jmx.
controller.commandline.option.ip=Optional IP address (the default is: {0} )
controller.commandline.option.port=Specify the port the controller is listening on (the default is: {0})
controller.commandline.option.file=The optional configuration file to init the controller.

   ### Shutdown ###
controller.already.shutting.down=The controller {0} has already been asked to shutdown
controller.shutdown.error.existing.virtualdatabases=Unable to shutdown controller {0} because the following virtualdatabases are still active : {1}
controller.shutdown.aborted=Shutdown was aborted.
controller.shutdown.active.threads=Waiting for {0} virtual database worker threads to terminate.
controller.shutdown.backends.exception=An error occured while disabling a backend for shutdown
controller.shutdown.client.socket=Waiting client is refused because shutting down
controller.shutdown.client.socket.exception=Exception while closing pending client connection ({0})
controller.shutdown.database.thread=Shutting down database backend thread.
controller.shutdown.jmx.error=Could not shutdown jmx properly because of {0}
controller.shutdown.refused=Shutdown Refused by security manager
controller.shutdown.server.socket.exception=Exception while closing server connection ({0})
controller.shutdown=Shutting down controller {0}
controller.shutdown.completed=Shutdown of controller {0} completed

   ### Controller Threads ###
controller.server.thread.backlog.size=Backlog size is {0} connections.
controller.server.thread.connection.accept=Connection accepted for {0}
controller.server.thread.connection.refused=Connection refused for {0}
controller.server.thread.controller.null=Got null controller in ControllerServerThread
controller.server.thread.illegal.ip=Cannot bind controller to requested IP {0} because of ({1})
controller.server.thread.new.connection.error=Error while handling new connection ({0})
controller.server.thread.terminating=ControllerServerThread terminating
controller.server.thread.socket.failed=Unable to create socket on port {0}. Controller startup aborted ({1})
controller.server.thread.starting=Starting new ControllerWorkerThread
controller.server.thread.waiting.connections=Waiting for connections on {0}:{1}
controller.ping.responder.creation.failed=Unable to create driver ping responder. Error was: {0}
controller.ping.responder.started=Ping responder started
controller.ping.responder.ended=Ping responder ended
controller.ping.responder.not.terminated=Ping responder did not terminate as expected
controller.ping.responder.received.ping=Received ping data from {0}
controller.ping.responder.wrong.protocol=Controller ping protocol does not match. Got {0} instead of {1}
controller.ping.responder.received.error=Error while receiving client ping
controller.ping.responder.send.pong=Response to ping sent to {0}
controller.ping.responder.send.error=Error while sending pong

   ### Controller Backup ###
controller.backup.no.lastknown.checkpoint=No last known checkpoint for backend {0}
controller.backup.complete=Backup has completed.
controller.backup.failed=Backup command failed
controller.backup.start=Starting backup of backend {0}
controller.backup.recovery.done=Recovery of backend {0} done.
controller.backup.recovery.failed=Recovery could not complete
controller.octopus.instance.failed=Failed to instanciate octopus
controller.octopus.load.failed=Failed to load octopus {0}
controller.octopus.loader.io.problem=A problem occured while accessing octopus loader file
controller.octopus.loader.job.not.found=Could not find octopus loader job file

   ### ControllerWorkerThread ###
controller.workerthread.connection.closing=Closing connection with client.
controller.workerthread.connection.from=Connection from {0}:{1}
controller.workerthread.io.error=I/O error during driver connection ({0})
controller.workerthread.maximum.thread=Maximum number of VirtualDatabaseWorkerThread reached ({0})
controller.workerthread.notify.thread=Notifying VirtualDatabaseWorkerThread
controller.workerthread.null.active.thread=Got null active threads queue in ControllerWorkerThread
controller.workerthread.null.connection=Got null connection queue in ControllerWorkerThread
controller.workerthread.null.pendingqueue=Got null controllerServerThreadPendingQueue in ControllerWorkerThread
controller.workerthread.null.serverthread=Got null serverThread in ControllerWorkerThread
controller.workerthread.null.socket=Got a null socket from pendingQueue.
controller.workerthread.protocol.error=Protocol error while expecting virtual database name ({0})
controller.workerthread.protocol.versions=Driver={0}, Controller={1}
controller.workerthread.protocol.incompatible=Driver protocol is not compatible with controller ({0}).
controller.workerthread.protocol.old.driver=Old driver version is connecting ({0}) - some new features may not be accessible
controller.workerthread.starting.thread=Starting new VirtualDatabaseWorkerThread
controller.workerthread.starting.thread.for.minimum=Starting new VirtualDatabaseWorkerThread to reach minimum number of threads
controller.workerthread.terminating=ControllerWorkerThread terminating.
controller.workerthread.too.many.connections=Connection refused - Too many connections.
   ### Controller Xml ###
controller.xml.dtd.using=Using DTD {0}
controller.xml.dtd.not.validated=DTD has not been validated.
controller.xml.dtd.validated=DTD has been validated.
# 0 => product name, 1 => dtd file path
controller.xml.dtd.not.found=Cannot find {0} DTD file "{1}" in classpath
controller.xml.document.not.validated=Xml document has not been validated.
controller.xml.document.validated=Xml document has been validated.
controller.xml.document.not.valid=Controller Xml configuration file is not valid.
controller.xml.done=XML document processing done.
controller.xml.parsing.document=Parsing XML document.
controller.xml.parsing.end=End parsing {0}
controller.xml.parsing.error=Error parsing "{0}" line {1}, column {2}: {3}
controller.xml.parsing.fatal=Fatal error parsing "{0}" line {1}, column {2}: {3}
controller.xml.parsing.start=Start parsing {0}
controller.xml.jmx.setup.failed=Could not setup jmx {0}
controller.xml.transformation.failed=Transformation of xml file failed.
controller.xml.use.xsl=XSL File used

####################################################
######### Virtual Database messages ########
####################################################

virtualdatabase.authentication.failed=Security violation : Virtual database authentication failed for user {0}

# 0 => dump name
virtualdatabase.backup.dumpNameError=Dump {0} can not be created: a dump with this name already exists.
virtualdatabase.backup.onlyOneBackendLeft=WARNING: only one active backend left.\n\
Performing a backup now will render the system non-responsive.\n\
Please use the -force option if this is intended.

   ### Info Messages ###
virtualdatabase.invalid.timestamp.resolution=Invalid timestamp resolution

   ### Actions of the virtualdatabase ###
virtualdatabase.not.found=Cannot find virtual database named: {0}

virtualdatabase.backuping.backend=Virtual database {0} is backuping database backend {1} with dump name {2}
virtualdatabase.backup.backend.failed=Virtual database {0} failed to backup database backend {1} (because of : {2})
virtualdatabase.backup.backend.success=Virtual database {0} successfully backuped database backend {1} with dump name {2}

virtualdatabase.checking.authentication=Checking administration login {0} for virtual database {1}
virtualdatabase.check.authentication.failed=Failed to check authentication for login {0} for virtual database {1} (because of : {2})

virtualdatabase.copying.log.fromCheckpoint=Virtual database {0} is copying log from checkpoint {1}
virtualdatabase.copy.log.fromCheckpoint.failed=Virtual database {0} failed to copy log from checkpoint {1} (because of : {2})
virtualdatabase.copy.log.fromCheckpoint.success=Virtual database {0} has successfully copied log from checkpoint {1}

virtualdatabase.deleting.dump=Virtual database {0} is deleting dump {1}
virtualdatabase.delete.dump.failed=Virtual database {0} failed to delete dump {1} (because of : {2})
virtualdatabase.delete.dump.success=Virtual database {0} has successfully deleted dump {1}

virtualdatabase.deleting.log.upToCheckpoint=Virtual database {0} log deleting (purged) up to checkpoint {1}
virtualdatabase.delete.log.upToCheckpoint.failed=Failed to delete virtual database {0} log up to checkpoint {1} (because of : {2})
virtualdatabase.delete.log.upToCheckpoint.success=Virtual database {0} log has been successfully deleted (purged) up to checkpoint {1}

virtualdatabase.disabling.with.checkpoint=Virtual database {0} is disabling database backend {1} with checkpoint
virtualdatabase.disable.with.checkpoint.failed=Virtual database {0} failed to disable database backend {1} with checkpoint (because of : {2})
virtualdatabase.disable.with.checkpoint.success=Virtual database {0} successfully disabled with checkpoint on database backend {1}

   ### Distributed virtual database messages ###
virtualdatabase.distributed.configuration.checking=Checking virtual database configuration with remote controllers.
virtualdatabase.distributed.configuration.checking.duplicate.controller.name=Duplicate controller name found.
virtualdatabase.distributed.configuration.checking.error=Error while checking virtual database configuration compatibility.
virtualdatabase.distributed.configuration.checking.mismatch.backend.shared=Backends cannot be shared between controllers.
virtualdatabase.distributed.configuration.checking.mismatch.databaseschema=Conflict on controller schemas.
virtualdatabase.distributed.configuration.checking.mismatch.groupname=Virtual database group names do not match.
virtualdatabase.distributed.configuration.checking.mismatch.loadbalancer=Load balancers are not compatible.
virtualdatabase.distributed.configuration.checking.mismatch.name=Virtual database names do not match.
virtualdatabase.distributed.configuration.checking.mismatch.scheduler=Schedulers are not compatible.
virtualdatabase.distributed.configuration.checking.mismatch.vlogins=Authentication managers do not have the same set of virtual logins.
virtualdatabase.distributed.configuration.checking.noanswer=No answer from remote controllers when trying to check configuration compatibility.
virtualdatabase.distributed.configuration.checking.noschema=No database schema provided, unable to check database schema compatibility.
virtualdatabase.distributed.configuration.compatible=Virtual database configuration is compatible with other controllers.
virtualdatabase.distributed.configuration.first.in.group=First controller in group {0}
virtualdatabase.distributed.configuration.not.compatible=Virtual database configuration is not compatible with other controller settings.
virtualdatabase.distributed.configuration.querying.remote.status=Querying backend status on remote controllers.
virtualdatabase.distributed.configuration.updating.backend.list=Updating backend list for controller {0}
virtualdatabase.distributed.disable.backend=Notifying controller that backend {0} is being disabled.
virtualdatabase.distributed.enable.backend.check=Checking with other controllers to enable backend.
virtualdatabase.distributed.joingroup.error=Error while joining group {0}
virtualdatabase.distributed.unable.get.remote.status=Unable to get backend information from controller {0}

virtualdatabase.distributed.abort.exception=Exception while executing distributed abort
virtualdatabase.distributed.abort.logging.only=No backend available to abort transaction {0}, updating recovery log.
virtualdatabase.distributed.abort.sqlexception=SQLException while executing distributed abort
virtualdatabase.distributed.commit.all.backends.locally.failed=All backends locally failed to commit transaction {0}
virtualdatabase.distributed.commit.logging.only=No backend available to commit transaction {0}, updating recovery log.
virtualdatabase.distributed.commit.sqlexception=SQLException while executing distributed commit
virtualdatabase.distributed.commit.exception=Exception while executing distributed commit
virtualdatabase.distributed.releasesavepoint.all.backends.locally.failed=All backends locally failed to release savepoint {0} from transaction {1}
virtualdatabase.distributed.releasesavepoint.exception=Exception while executing distributed release savepoint
virtualdatabase.distributed.releasesavepoint.logging.only=No backend available to release savepoint {0} from transaction {1}, updating recovery log.
virtualdatabase.distributed.releasesavepoint.sqlexception=SQLException while executing distributed release savepoint
virtualdatabase.distributed.rollback.exception=Exception while executing distributed rollback
virtualdatabase.distributed.rollback.logging.only=No backend available to rollback transaction {0}, updating recovery log.
virtualdatabase.distributed.rollback.sqlexception=SQLException while executing distributed rollback
virtualdatabase.distributed.rollbacksavepoint.all.backends.locally.failed=All backends locally failed to rollback to savepoint {0} for transaction {1}
virtualdatabase.distributed.rollbacksavepoint.exception=Exception while executing distributed rollback to savepoint
virtualdatabase.distributed.rollbacksavepoint.logging.only=No backend available to rollback to savepoint {0} for transaction {1}, updating recovery log.
virtualdatabase.distributed.rollbacksavepoint.sqlexception=SQLException while executing distributed rollback to savepoint
virtualdatabase.distributed.setsavepoint.all.backends.locally.failed=All backends locally failed to set savepoint {0} to transaction {1}
virtualdatabase.distributed.setsavepoint.exception=Exception while executing distributed set savepoint
virtualdatabase.distributed.setsavepoint.logging.only=No backend available to set savepoint {0} to transaction {1}, updating recovery log.
virtualdatabase.distributed.setsavepoint.sqlexception=SQLException while executing distributed set savepoint

virtualdatabase.distributed.read.procedure.all.backends.locally.failed=All backends failed locally for read stored procedure {0}
virtualdatabase.distributed.read.procedure.exception=Exception while executing distributed read stored procedure ({0}).
virtualdatabase.distributed.read.procedure.logging.only=No backend available to execute read stored procedure {0}, updating recovery log.
virtualdatabase.distributed.read.procedure.sqlexception=SQLException while executing distributed read stored procedure ({0}).
virtualdatabase.distributed.read.sqlexception=SQLException while executing remote read request.
virtualdatabase.distributed.read.exception=Exception while executing remote read request.
virtualdatabase.distributed.write.all.backends.locally.failed=All backends failed locally for write request {0}
virtualdatabase.distributed.write.sqlexception=SQLException while executing distributed write request {0}
virtualdatabase.distributed.write.exception=Exception while executing distributed write request {0}
virtualdatabase.distributed.write.failover.lost.warnings="Failover happened while executing request {0}. SQLWarnings, if any, were lost.
virtualdatabase.distributed.write.logging.only=No backend available to execute request {0}, updating recovery log.
virtualdatabase.distributed.write.procedure.all.backends.locally.failed=All backends failed locally for write stored procedure {0}
virtualdatabase.distributed.write.procedure.exception=Exception while executing distributed write stored procedure ({0}).
virtualdatabase.distributed.write.procedure.logging.only=No backend available to execute write stored procedure {0}, updating recovery log.
virtualdatabase.distributed.write.procedure.sqlexception=SQLException while executing distributed write stored procedure ({0}).
virtualdatabase.distributed.prepared.statement.metadata.remote.no.response=No response while getting prepared statement (parameter) metadata from remote controller
virtualdatabase.distributed.prepared.statement.metadata.remote.error=Error while getting prepared statement (parameter) metadata from remote controller
virtualdatabase.distributed.prepared.statement.metadata.remote.channel.unavailable=Channel unavailable while getting prepared statement (parameter) metadata from remote controller

virtualdatabase.enabling.from.checkpoint=Virtual database {0} is enabling database backend {1} from checkpoint
# 0 => vdb name, 1 => backend name, 2 => exception message
virtualdatabase.enable.from.checkpoint.failed=Virtual database {0} failed to enable database backend {1} from checkpoint (because of : {2})
virtualdatabase.enable.from.checkpoint.success=Virtual database {0} successfully enabled from checkpoint on database backend {1}

   ### Exception message ###
virtualdatabase.fail.read.lock=Failed to obtain read lock on backend list.
virtualdatabase.fail.backend.copy=Failed to replicate the backend (because of {0}).
virtualdatabase.fail.register.backend.mbean=Failed to register the mbean of backend {0}
virtualdatabase.fail.unregister.backend.mbean=Failed to unregister the mbean of backend {0}
virtualdatabase.fail.unregister.mbean=Failed to unregister the mbean of virtual database {0}
virtualdatabase.fail.enable.cause.resyncing=Failed to enable backend because recoverylog resync in progress. Try again later.
virtualdatabase.fail.enable.cause.shutdown=Failed to enable backend because virtual database is shutting down.
virtualdatabase.fail.enable.cause.nolastcheckpoint=Failed to enable backend {0} from checkpoint because no last checkpoint is available for that backend (restore a dump on this backend).

virtualdatabase.force.disabling=Virtual database {0} is forcing the disable of database backend {1}
virtualdatabase.force.disable.failed=Virtual database {0} failed to force disable database backend {1} (because of : {2})
virtualdatabase.force.disable.success=Virtual database {0} successfully disabled on database backend {1}

virtualdatabase.force.enabling=Virtual database {0} is forcing the enable of database backend {1}
virtualdatabase.force.enable.failed=Virtual database {0} failed to force enable database backend {1} (because of : {2})
virtualdatabase.force.enable.success=Virtual database {0} successfully enabled on database backend {1}

virtualdatabase.initializing=Virtual database {0} is initializing from database backend {1}
virtualdatabase.initialize.failed=Virtual database {0} failed to initialize (because of : {1})
virtualdatabase.initialize.success=Virtual database {0} initialization from database backend {1} completed

virtualdatabase.monitoring.not.defined=No monitoring has been defined yet.
virtualdatabase.no.recovery.log=There is no recovery log configured for this database (required)
virtualdatabase.not.distributed=This virtual database is not distributed (required)
# 0 => vdb name
virtualdatabase.no.total.order.queue= No total order queue for virtual database {0}

# 0: dump name, 1: exception message
virtualdatabase.removeDump.failure=Unable to remove dump {0} ({1})

virtualdatabase.replicating.backend=Virtual database {0} is replicating database backend {1}
virtualdatabase.replicate.backend.failed=Virtual database {0} failed to replicate database backend {1} (because of : {2})
virtualdatabase.replicate.backend.success=Virtual database {0} replicate database backend {1} completed

virtualdatabase.restoring.dump=Virtual database {0} is restoring dump {1} on database backend {2}
virtualdatabase.restore.dump.failed=Virtual database {0} failed to restore dump {1} (because of : {2})
virtualdatabase.restore.dump.success=Virtual database {0} successfully restored dump {1} on database backend {2}

virtualdatabase.setting.lastKnownCheckpoint=Virtual database {0} is setting last known checkpoint {1} on database backend {2}
virtualdatabase.set.lastKnownCheckpoint.failed=Virtual database {0} failed to set last known checkpoint {1} on database backend {2} (because of : {3})
virtualdatabase.set.lastKnownCheckpoint.success=Virtual database {0} successfully set last known checkpoint {1} on database backend {2}

   ### Shutdown ###
# 0 => vdb name
virtualdatabase.shutting.down=Virtual database {0} is shutting down and does not accept new connections.
# 0 => vdb name
virtualdatabase.shutdown.type.wait=Shutting down virtual database {0} in wait mode : waiting for all clients to be closed
# 0 => vdb name
virtualdatabase.shutdown.type.safe=Shutting down virtual database {0} in safe mode : waiting for all current transactions to complete
# 0 => vdb name
virtualdatabase.shutdown.type.force=Shutting down virtual database {0} in force mode : immediate without consistency
# 0 => mode, 1 => vdb name
virtualdatabase.shutdown.unknown.level=Unknown mode ({0}) for virtual database {1} shutdown

virtualdatabase.transferring.backend=Database backend {0} for virtual database {1} is being transferred to controller {2}
virtualdatabase.transfer.backend.failed=Failed to transfer database backend {0} for virtual database {1} to controller {2} (because of : {3})
virtualdatabase.transfer.backend.success=Database backend {0} for virtual database {1} has been successfully transferred to controller {2}

virtualdatabase.transferring.dump=Dump {0} for virtual database {1} is being transferred on remote controller {2}
virtualdatabase.transfer.dump.failed=Failed to transfer dump {0} for virtual database {1} (because of : {2})
virtualdatabase.transfer.dump.success=Dump {0} for virtual database {1} has been successfully transferred on remote controller {2} completed

virtualdatabase.updating.dump.path=Virtual database {0} is updating dump path for dump {1} : the new path is {2}
virtualdatabase.update.dump.path.success=Virtual database {0} has successfully updated dump path for dump {1} : the new path is {2}
virtualdatabase.update.dump.path.failed=Virtual database {0} failed in updating dump path for dump {1} (because of : {2})

   ### XML Parsing ###
virtualdatabase.xml.add.CommonTranslatevirtualdatabase=Adding new virtual database
virtualdatabase.xml.authentication.login.admin.add=Adding admin login "{0}" with password "{1}"
virtualdatabase.xml.authentication.login.real.add=Adding real login "{0}" with password "{1}" for backend "{2}"
virtualdatabase.xml.authentication.login.real.add.failed=Failed to add new real login
virtualdatabase.xml.authentication.login.virtual.add=Adding virtual login "{0}" with password "{1}"
virtualdatabase.xml.backend.add.failed=Failed to add database backend
virtualdatabase.xml.backend.create=Creating new database backend (name={0}, driver={1}, url={2}, connectionTestStatement={3})
virtualdatabase.xml.backend.policy.add=Adding backend "{0}" to the current policy
virtualdatabase.xml.backend.set.schema.failed=Failed to set database backend schema
virtualdatabase.xml.backend.weigth.set=Weight "{0}" assigned to backend "{1}"
virtualdatabase.xml.backend.weigth.failed=Failed to set weight assigned to backend "{0}"
virtualdatabase.xml.cache.create=Creating query cache with granularity "{0}"
virtualdatabase.xml.cache.create.failed=Failed to create cache with granularity "{0}"
virtualdatabase.xml.cache.rule.add=Adding rule for "{0}" - Case sensitive:{1} - Apply to skeleton:{2} - Timestamp Resolution:{3}
virtualdatabase.xml.cache.unsupported=Unsupported query cache granularity "{0}"
virtualdatabase.xml.connectionmanager.failfast.add=Adding fail fast pool connection manager for backend "{0}" (vLogin={1}, size={2}, login={3}, password={4})
virtualdatabase.xml.connectionmanager.failfast.failed=Failed to add fail fast pool connection manager for backend "{0}"
virtualdatabase.xml.connectionmanager.failfast.failed.parameter=Cannot create new fail fast pool connection manager with the given parameter
virtualdatabase.xml.connectionmanager.randomwait.add=Adding random wait pool connection manager for backend "{0}" (vLogin={1}, size={2}, timeout={3}, login={4}, password={5})
virtualdatabase.xml.connectionmanager.randomwait.failed=Failed to add random wait pool connection manager for backend "{0}"
virtualdatabase.xml.connectionmanager.randomwait.failed.parameter=Cannot create new random wait pool connection manager with given parameter
virtualdatabase.xml.connectionmanager.simple.add=Adding simple connection manager for backend "{0}" (vLogin={1}, login={2}, password={3})
virtualdatabase.xml.connectionmanager.variable.failed=Failed to add variable pool connection manager for backend "{0}"
virtualdatabase.xml.connectionmanager.variable.failed.parameter=Cannot create new variable pool connection manager with the given parameter
virtualdatabase.xml.connectionmanager.vlogin.undefined=Virtual login "{0}" not defined in connection manager of backend "{1}"
virtualdatabase.xml.create.table.add=Adding create table rule: {0}
virtualdatabase.xml.create.table.default=Adding default round-robin create table rule.
virtualdatabase.xml.create.table.unsupported=Unsupported CreateTable policy "{0}"
virtualdatabase.xml.document.not.validated=Xml document has not been validated.
virtualdatabase.xml.document.not.valid=Controller Xml configuration file is not valid.
virtualdatabase.xml.document.validated=Xml document has been validated.
virtualdatabase.xml.done=XML document processing done.
# 0 => product name, 1 => DTD file path
virtualdatabase.xml.dtd.not.found=Cannot find {0} DTD file "{1}" in classpath
virtualdatabase.xml.dtd.not.validated=DTD has not been validated.
virtualdatabase.xml.dtd.validated=DTD has been validated.
virtualdatabase.xml.invalid.macroshandler.settings=Invalid values for MacrosHandler: {0}
virtualdatabase.xml.loadbalancer.errorchecking.policy=Error checking policy is: {0}
virtualdatabase.xml.loadbalancer.errorchecking.unsupported=Unsupported ErrorChecking policy "{0}"
virtualdatabase.xml.loadbalancer.paralleldb_lprf.set=Setting new ParallelDB_LPRF load balancer
virtualdatabase.xml.loadbalancer.paralleldb_lprf.failed=Failed to create new ParallelDB_LPRF load balancer
virtualdatabase.xml.loadbalancer.paralleldb_rr.set=Setting new ParallelDB_RR load balancer
virtualdatabase.xml.loadbalancer.paralleldb_rr.failed=Failed to create new ParallelDB_RR load balancer
virtualdatabase.xml.loadbalancer.raidb0.set=Setting new RAIDb-0 load balancer
virtualdatabase.xml.loadbalancer.raidb0.failed=Failed to set RAIDb-0 load balancer.
virtualdatabase.xml.loadbalancer.raidb1_lprf.set=Setting new RAIDb-1 less pending requests first load balancer
virtualdatabase.xml.loadbalancer.raidb1_lprf.failed=Failed to create RAIDb-1 less pending requests first load balancer
virtualdatabase.xml.loadbalancer.raidb1_rr.set=Setting new RAIDb-1 round robin load balancer
virtualdatabase.xml.loadbalancer.raidb1_rr.failed=Failed to create RAIDb-1 round robin load balancer
virtualdatabase.xml.loadbalancer.raidb1_wrr.set=Setting new RAIDb-1 weighted round robin load balancer
virtualdatabase.xml.loadbalancer.raidb1_wrr.failed=Failed to create RAIDb-1 weighted round robin load balancer
virtualdatabase.xml.loadbalancer.raidb1ec_rr.set=Setting new RAIDb-1ec round robin load balancer
virtualdatabase.xml.loadbalancer.raidb1ec_rr.failed=Failed to create RAIDb-1ec round robin load balancer
virtualdatabase.xml.loadbalancer.raidb1ec_wrr.set=Setting new RAIDb-1ec weighted round robin load balancer
virtualdatabase.xml.loadbalancer.raidb1ec_wrr.failed=Failed to create RAIDb-1ec weighted round robin load balancer
virtualdatabase.xml.loadbalancer.raidb2_lprf.set=Setting new RAIDb-2 less pending requests first load balancer
virtualdatabase.xml.loadbalancer.raidb2_lprf.failed=Failed to create RAIDb-2 less pending requests first load balancer
virtualdatabase.xml.loadbalancer.raidb2_rr.set=Setting new RAIDb-2 round robin load balancer
virtualdatabase.xml.loadbalancer.raidb2_rr.failed=Failed to create RAIDb-2 round robin load balancer
virtualdatabase.xml.loadbalancer.raidb2_wrr.set=Setting new RAIDb-2 weighted round robin load balancer
virtualdatabase.xml.loadbalancer.raidb2_wrr.failed=Failed to create RAIDb-2 weighted round robin load balancer
virtualdatabase.xml.loadbalancer.raidb2ec_rr.failed=Failed to create RAIDb-2ec round robin load balancer
virtualdatabase.xml.loadbalancer.raidb2ec_wrr.failed=Failed to create RAIDb-2ec weighted round robin load balancer
virtualdatabase.xml.loadbalancer.singledb.set=Setting new SingleDB load balancer
virtualdatabase.xml.loadbalancer.singledb.failed=Failed to create new SingleDB load balancer
virtualdatabase.xml.loadbalancer.transaction.isolation.set=Setting default transaction isolation level to {0}
virtualdatabase.xml.loadbalancer.waitforcompletion.rule=WaitForCompletion rule is: {0}
virtualdatabase.xml.loadbalancer.waitforcompletion.unsupported=Unsupported WaitForCompletion policy "{0}"
virtualdatabase.xml.metadata.cache.create.failed=Failed to create metadata cache with the given attributes ({0})
virtualdatabase.xml.no.distributed.requestmanager=No distributed request manager currently support RAIDb level {0}
virtualdatabase.xml.no.single.distributed.requestmanager=SingleDB configuration cannot be used in a distributed virtual database.
virtualdatabase.xml.parsing.cache.create.failed=Failed to create parsing cache with the given attributes ({0})
virtualdatabase.xml.parsing.cache.jmx.failed=Failed to registered parsing cache in mbean server for virtual database {0}
virtualdatabase.xml.parsing.end=End parsing {0}
virtualdatabase.xml.parsing.warning=Parser reported a warning: {0}
virtualdatabase.xml.parsing.error=Error parsing "{0}" line {1}, column {2}: {3}
virtualdatabase.xml.parsing.fatal=Fatal error parsing "{0}" line {1}, column {2}: {3}
virtualdatabase.xml.parsing.start=Start parsing {0}
virtualdatabase.xml.procedure.add=Adding procedure {0}
virtualdatabase.xml.procedure.add.failed=Failed to add procedure to database table.
virtualdatabase.xml.recoverylog.cheking.tables=Checking JDBC Recovery log tables.
virtualdatabase.xml.recoverylog.cheking.tables.failed=Failed to check JDBC Recovery log tables.
virtualdatabase.xml.recoverylog.jdbc.create=Creating new JDBC recovery log (driver={0}, url={1}, login={2}, password={3} - request timeout:{4})
virtualdatabase.xml.recoverylog.jdbc.failed=Failed to create JDBC RecoveryLog
virtualdatabase.xml.recoverylog.jdbc.backendtable.setnull=Trying to set the backend table create statement on a null recovery log
virtualdatabase.xml.recoverylog.jdbc.backendtable.failed=Failed to create the backend table
virtualdatabase.xml.recoverylog.jdbc.checkpointtable.setnull=Trying to set the checkpoint table create statement on a null recovery log
virtualdatabase.xml.recoverylog.jdbc.checkpointtable.failed=Failed to create checkpoint table
virtualdatabase.xml.recoverylog.jdbc.dumptable.setnull=Trying to set the dump table create statement on a null recovery log
virtualdatabase.xml.recoverylog.jdbc.dumptable.failed=Failed to create the dump table
virtualdatabase.xml.recoverylog.jdbc.recoverytable.setnull=Trying to set the log table create statement on a null recovery log
virtualdatabase.xml.recoverylog.jdbc.recoverytable.failed=Failed to create JDBC recovery log table
# 0 => vdb name
virtualdatabase.xml.recoverylog.jmx.failed=failed to registered recovery log in mbean server for virtual database {0}
virtualdatabase.xml.requestmanager.creation.failed=Failed to create the request manager.
virtualdatabase.xml.requestmanager.initialization.failed=Failed to retrieve last request id to initalize request manager.
virtualdatabase.xml.requestmanager.parameters=Request manager will use the following timeouts in ms: begin={0}, commit={1}, rollback={2}
virtualdatabase.xml.requestmanager.set=Setting new request manager
virtualdatabase.xml.requestmanager.timeout.failed=Failed to set timeouts on request manager.
virtualdatabase.xml.rewritingrule.add=Adding rewriting rule "{0}"->"{1}" - Case sensitive:{2} - Stop on match:{3}
virtualdatabase.xml.rewritingrule.unsupported.matching=Unsupported matching type {0} in AbstractRewritingRule
virtualdatabase.xml.scheduler.initialization.failed=Failed to retrieve last transaction id to initalize scheduler.
virtualdatabase.xml.scheduler.raidb0.create.passthrough=Creating RAIDb-0 pass-through level scheduler
virtualdatabase.xml.scheduler.raidb0.create.pessimistic=Creating RAIDb-0 pessimistic transaction level scheduler
virtualdatabase.xml.scheduler.raidb0.unsupported=Unsupported RAIDb-0 scheduler level "{0}"
virtualdatabase.xml.scheduler.raidb1.create.passthrough=Creating RAIDb-1 pass-through level scheduler
virtualdatabase.xml.scheduler.raidb1.create.query=Creating RAIDb-1 query level scheduler
virtualdatabase.xml.scheduler.raidb1.create.query.optimistic=Creating RAIDb-1 optimistic query level scheduler
virtualdatabase.xml.scheduler.raidb1.create.pessimistic=Creating RAIDb-1 pessimistic transaction level scheduler
virtualdatabase.xml.scheduler.raidb1.create.optimistic=Creating RAIDb-1 optimistic transaction level scheduler
virtualdatabase.xml.scheduler.raidb1.unsupported=Unsupported RAIDb-1 scheduler level "{0}"
virtualdatabase.xml.scheduler.raidb2.create.passthrough=Creating RAIDb-2 pass-through level scheduler
virtualdatabase.xml.scheduler.raidb2.create.query=Creating RAIDb-2 query level scheduler
virtualdatabase.xml.scheduler.raidb2.create.pessimistic=Creating RAIDb-2 pessimistic transaction level scheduler
virtualdatabase.xml.scheduler.raidb2.unsupported=Unsupported RAIDb-2 scheduler level "{0}"
virtualdatabase.xml.scheduler.singledb.create.passthrough=Creating SingleDB pass-through level scheduler
virtualdatabase.xml.scheduler.singledb.create.pessimistic=Creating SingleDB pessimistic transaction level scheduler
virtualdatabase.xml.scheduler.singledb.unsupported=Unsupported SingleDB scheduler level "{0}"
virtualdatabase.xml.scheduler.jmx.failed=failed to registered abstract scheduler in mbean server for virtual database {0}
virtualdatabase.xml.schema.column.add=Adding column "{0}" (unique: {1})
virtualdatabase.xml.schema.procedure.add=Adding procedure "{0}" (returnType: {1})
virtualdatabase.xml.schema.procedure.parameter.add=Adding procedure parameter "{0}" (nullable:{1}, type:{2})
virtualdatabase.xml.schema.static.incompatible.dynamic=A static schema definition is not compatible with a non-static dynamic precision for backend {0}.
virtualdatabase.xml.schema.table.add=Creating table "{0}" with {1} columns
virtualdatabase.xml.schema.table.failed=Failed to create database table "{0}"
virtualdatabase.xml.sqlmonitoring.rule.add=Adding rule for "{0}" - Case sensitive:{1} - Apply to skeleton:{2} - Monitor request:{3}
virtualdatabase.xml.start=Parsing XML document.
virtualdatabase.xml.table.no.column=Table {0} has no column.
virtualdatabase.xml.table.column.mismatch={0} columns where expected for table {1} but {2} were provided.
virtualdatabase.xml.table.add=Adding table {0}
virtualdatabase.xml.table.add.failed=Failed to add table to database table
virtualdatabase.xml.virtualdatabase.already.exists=A database named "{0}" already exists
virtualdatabase.xml.virtualdatabase.create=Creating new virtual database {0}
virtualdatabase.xml.virtualdatabase.distributed.create=Creating new distributed virtual database {0} belonging to group {1}.
virtualdatabase.xml.virtualdatabase.distributed.failed=Failed to create distributed virtual database
virtualdatabase.xml.virtualdatabase.failed=Failed to create virtual database
virtualdatabase.xml.virtualdatabase.set.schema.failed=Failed to set virtual database schema

############################################
############# Backend messages #############
############################################
backend.already.disabled=Backend {0} is already disabled.
backend.add.connection.manager.for.user=Adding connection manager for virtual user "{0}"
backend.add.connection.manager.failed=Failed to add connection manager ({0})
backend.cannot.connect.to=Unable to connect to backend.
backend.check.schema.compatibility=Checking compatibility with existing database schema
backend.detected.as=Detected backend as: {0}
backend.driver.loaded=Driver {0} loaded.
# 0 => driver class name, 1 => product name
backend.driver.not.compliant=Driver {0} is not {1} compliant
backend.dynamic.schema=Dynamic schema gathering level: {0}
backend.gather.schema.failed=Unable to gather schema from database meta data: {0}
backend.gathering.database.schema=Gathering database schema
backend.missing.connection.manager=A connection manager is missing for login {0}
backend.not.defined=Backend with name {0} and url {1} is not defined.
# 0 => numbers of remaining pending requests
backend.not.ready.for.backup=Backend is not ready for backup: {0} remaining pending requests
backend.null.backend.name=Illegal null database backend name in DatabaseBackend constructor
backend.null.connection.manager=Invalid null connection manager for backend "{0}" (URL: "{1}")
backend.null.connection.test=Illegal null connectionTestStatement in DatabaseBackend constructor
backend.null.driver=Illegal null driver class name in DatabaseBackend constructor
backend.null.tables=Invalid null tables list
backend.null.url=Illegal null URL in DatabaseBackend constructor
backend.null.virtualdatabase.name=Illegal null virtual database name in DatabaseBackend constructor
backend.rewriting.query=Rewriting query: {0}
backend.rewriting.rule.add=Adding rewriting rule {0} -> {1}
backend.schema.compatible.for.login=Database schema for login "{0}" is compatible with existing schema
backend.schema.not.set=Database schema not set.
backend.schema.not.compatible.for.login=Gathered schema for login "{0}" is not compatible with existing shema. Keeping current schema.
backend.schema.static.no.check=Static schema definition for backend {0} is not checked for compatibility.
backend.state.disabled=Backend {0} is now disabled
backend.state.disabling=Disabling backend {0}, waiting for current transaction to complete on this backend
backend.state.enabled=Database backend {0} is now enabled
backend.state.changed=Database backend {0} is now in state {1}
backend.transaction.not.started=Transaction id {0} is not started on backend {1}
backend.use.gathered.schema.as.new=Using gathered schema as new schema.
backend.no.lock=No lock
backend.locker=Lock owner transaction id: {0}

BackendState.readEnabledWriteDisabled=read-only enabled
BackendState.readEnabledWriteEnabled=enabled
BackendState.readDisabledWriteEnabled=write-only enabled
BackendState.disabled=disabled
BackendState.restoring=restoring
BackendState.disabling=disabling
BackendState.backingUp=backing up
BackendState.replaying=replaying
BackendState.unknown=unknown

   ### Meta Data ###
backend.meta.connection.failed=Unable to get a connection to gather database schema.
backend.meta.failed.get.info=Failed to get information about database schema: {0}
backend.meta.found.table=Table found: {0}
backend.meta.found.column=Column found: {0}
backend.meta.found.exported.key=Exported key found: {0}
backend.meta.found.imported.key=Imported key found: {0}
backend.meta.found.foreign.key=Foreign key found: from {0} to {1}
backend.meta.found.primary.key=Primary key found: {0}
backend.meta.found.procedure=Found procedure: {0}
backend.meta.get.columns.failed=Unable to fetch columns for table {0}
backend.meta.get.exported.keys.failed=Failed to get exported keys for table {0}
backend.meta.get.imported.keys.failed=Failed to get imported keys for table {0}
backend.meta.get.foreign.keys.failed=Failed to get foreign keys
backend.meta.get.primary.keys.failed=Failed to get primary keys for table {0}
backend.meta.get.procedure.params.failed=Unable to get parameters information for stored procedure {0}
backend.meta.get.procedures=Retrieving procedures from backend
backend.meta.get.procedures.failed=Unable to fetch procedures because of {0}
backend.meta.procedure.added=Adding procedure {0} to schema
backend.meta.procedure.already.in.schema=Procedure {0} already in schema.
backend.meta.procedure.found.semantics=Found semantic for procedure {0}
backend.meta.procedure.notfound=Stored procedure {0} not found in schema, ignoring semantic information.
backend.meta.procedure.semantics.add.reference=Adding reference to {1} for stored procedure {0}
backend.meta.procedure.semantics.get.failed=Failed to get stored procedure semantics from database backend ({0})
# 0 => exception message
backend.meta.procedures.semantics.set.table.failed=Failed to set stored procedure semantics from database backend ({0})
backend.meta.procedure.semantics.no.references=No references found for stored procedure {0}
backend.meta.procedure.semantics.references.found=Stored procedure {0} references {1} {2},{3}
backend.meta.received.null=Unable to get to gather metadata from database.
backend.meta.runtime.error=Runtime error while fetching schema
backend.meta.view.not.supported=Views are not supported by this driver. Getting tables only.

   ### Driver ###
backend.driver.metadata.getColumnCount.failed=metaData.getColumnCount test failed ({0})
backend.driver.metadata.getColumnCount.ok=metaData.getColumnCount test OK.
backend.driver.metadata.getColumnDisplaySize.failed=metaData.getColumnDisplaySize test failed.
backend.driver.metadata.getColumnDisplaySize.ok=metaData.getColumnDisplaySize test OK.
backend.driver.metadata.getColumnName.ok=metaData.getColumnName test OK.
backend.driver.metadata.getColumnName.failed=metaData.getColumnName test failed ({0})
backend.driver.metadata.getColumnType.failed=metaData.getColumnType test failed.
backend.driver.metadata.getColumnType.ok=metaData.getColumnType test OK.
backend.driver.metadata.getColumnTypeName.failed=metaData.getColumnTypeName test failed.
backend.driver.metadata.getColumnTypeName.ok=metaData.getColumnTypeName test OK.
backend.driver.metadata.getColumnClassName.failed=metaData.getColumnClassName test failed.
backend.driver.metadata.getColumnClassName.ok=metaData.getColumnClassName test OK.
backend.driver.metadata.getTableName.failed=metaData.getTableName test failed.
backend.driver.metadata.getTableName.ok=metaData.getTableName test OK.
backend.driver.metadata.getTables.failed=ConnectionMetaData.getTables test failed ({0})
backend.driver.metadata.getTables.ok=ConnectionMetaData.getTables test OK.
backend.driver.resultset.getMetaData.failed=resultset.getMetaData test failed ({0})
backend.driver.resultset.getMetaData.ok=ResultSet.getMetaData test OK.
backend.driver.resultset.getObject.unable=Unable to test ResultSet.getObject
backend.driver.resultset.getObject.failed=ResultSet.getObject test failed ({0})
backend.driver.resultset.getObject.ok=ResultSet.getObject test OK.
backend.driver.setQueryTimeout.failed=setQueryTimeout test failed.
backend.driver.setQueryTimeout.ok=setQueryTimeout test OK.
backend.driver.statement.setCursorName.ok=Statement.setCursorName test OK.
backend.driver.statement.setCursorName.failed=Statement.setCursorName not supported.
backend.driver.statement.setFetchSize.ok=Statement.setFetchSize test OK.
backend.driver.statement.setFetchSize.failed=Statement.setFetchSize not supported.
backend.driver.statement.setMaxRows.ok=Statement.setMaxRows test OK.
backend.driver.statement.setMaxRows.failed=Statement.setMaxRows not supported.
backend.driver.statement.getGeneratedKeys.ok=Statement.getGeneratedKeys test OK.
backend.driver.statement.getGeneratedKeys.failed=Statement.getGeneratedKeys not supported.
backend.driver.test.connection.failed=Connection test failed ({0})
backend.driver.test.connection.ok=Connection test OK.
backend.driver.test.database.productname.failed=Failed to get database product name
backend.driver.test.metadata.failed=Connection.getMetaData test failed  ({0})
backend.driver.test.metadata.ok=Connection.getMetaData test OK.
backend.driver.test.serializable.isolation.failed=Your database does not support a Serializable transaction isolation level, this might lead to cluster inconsistencies if you are using sub-selects ({0})
backend.driver.test.serializable.isolation.ok=Connection.setTransactionIsolation(SERIALIZABLE) test OK.
backend.driver.test.statement.failed=Statement test failed  ({0})
backend.driver.test.statement.invalid=Test statement {0} is invalid ({0})
backend.driver.test.statement.ok=Statement test OK.
backend.driver.using.default.statement=Using default test statement.

   ### BackendWorkerThread ###
backendworkerthread.execute.task=Executing task {0}
backendworkerthread.execute.task.completed=Task {0} completed
backendworkerthread.null.backend=Invalid null backend in BackendWorkerThread constructor.
backendworkerthread.null.loadbalancer=Invalid null load balancer in BackendWorkerThread constructor.
backendworkerthread.remove.task.error=Error while removing pending task ({0})
backendworkerthread.task.failed=Task execution failed ({0})
backendworkerthread.task.unexpected.throwable=Unexpected error while executing task: {0}

############################################
####### Connection Manager messages ########
############################################
connection.backend.out.of.connections=Out of connections for backend "{0}", consider increasing pool size (current size is {1})
connection.backend.pool.created=Pool connection manager created for backend {0} for {1} connection(s)
connection.backend.unreachable=Backend {0} is no more reachable.
connection.connections.still.active=Some connections are still active, destroying them.
connection.empty.pool=Pool is empty, no connection available for this backend
connection.free.connections.failed=An error occured while freeing the connections
connection.freed.connection={0} connections freed on "{1}"
connection.initialize.pool.failed=Unable to initialize connections for this backend
connection.limit.poolsize=Failed to obtain the requested number of connections, limiting pool size to {0} connection(s)
connection.max.poolsize.reached=Cannot enable more connections ({0}) than pool size ({1}). Enabling only {2} connections
connection.persistent.id.unknown=Cannot find persistent connection {0}
connection.pool.initialized=Initialized {0} connections on "{1}"
connection.pool.not.initialized=Cannot release connections since connection pool has not been initialized
connection.reallocate.failed=Unable to re-allocate {0} missing connections.
connection.reallocate.missing=Trying to reallocate {0} missing connections.
connection.release.failed=Failed to release connection {0} (not found in active pool)
connection.replaced.failed=Bad connection {0} has been removed but cannot be replaced.
connection.replaced.failed.exception=Failed to release connection {0} (not found in active pool)
connection.replaced.success=Bad connection {0} has been replaced by a new connection.
connection.request.not.initialized=Requesting a connection from a non-initialized connection manager
connection.transaction.unknown=Cannot find connection for transaction {0}

############################################
######## Request Manager messages ##########
############################################
requestmanager.incompatible.raidb.levels=Incompatible RAIDb levels between scheduler ({0}) and load balancer ({1})
requestmanager.null.loadbalancer=Illegal null load balancer in RequestManager constructor
requestmanager.null.scheduler=Illegal null scheduler assigned to RequestManager
requestmanager.parsing.granularity=Request manager will parse requests with the following granularity: {0}
requestmanager.read.request.balance=Load balancing read request ({0}): {1}
requestmanager.read.request.cache.get=Getting from cache read request ({0}): {1}
requestmanager.read.request.cache.update=Updating cache with read Request ({0}): {1}
requestmanager.read.request.log=Logging read request ({0}): {1}
requestmanager.read.request.schedule=Scheduling read Request ({0}): {1}
requestmanager.read.stored.procedure=Read Stored Procedure ({0}) : {1}
requestmanager.releasesavepoint.failed.all=All backends failed to release savepoint {0} from transaction {1} ({2})
requestmanager.request.failed=Failed to execute request {0} because of ({1})
requestmanager.resume.pending.writes=Resume pending writes
requestmanager.rollback.failed.all=All backends failed to rollback transaction {0} ({1})
requestmanager.rollbackavepoint.failed.all=All backends failed to rollback transaction {0} to savepoint {1} ({2})
requestmanager.schema.add.table=Added table {0} to schema
requestmanager.schema.ignore.new.dynamic=Ignoring new dynamically gathered virtual database schema.
requestmanager.schema.merge.failed=Failed to merge current schema because of {0}.
requestmanager.schema.remove.table=Removed table from schema
requestmanager.schema.replace.static.with.new=Replacing static Virtual Database schema with a new one.
requestmanager.schema.set.new.virtualdatabase=Setting new virtual database schema.
requestmanager.schema.virtualdatabase.merged.new=Virtual database schema merged with new schema.
requestmanager.setsavepoint.failed.all=All backends failed to set savepoint {0} to transaction {1} ({2})
requestmanager.stored.procedure.failed=Failed to execute stored procedure {0}. Error is: {1}
requestmanager.wait.pending.writes=Waiting for pending writes to complete
requestmanager.write.request.balance=Load balancing write request ({0},{1}): {2}
requestmanager.write.request.cache.update=Invalidating cache for write request ({0}): {1}
requestmanager.write.request.failed.unexpected=Unexpected exception in execWriteRequest
requestmanager.write.request.keys.failed.unexpected=Unexpected exception in execWriteRequestKeys
requestmanager.write.request.log=Logging write request ({0}): {1}
requestmanager.write.request.schedule=Scheduling write request ({0}): {1}
requestmanager.write.stored.procedure=Write Stored Procedure ({0}) : {1}

############################################
### Authentication manager messages ########
############################################
authentication.failed.add.user.already.exists=Failed to add real user "{0}" to virtual database login "{1}" for backend "{2}": real login "{3}" already exist for this backend.

############################################
######### Load Balancer messages ###########
############################################
loadbalancer.backendlist.acquire.readlock.failed=Failed to acquire read lock on backend list
loadbalancer.backendlist.acquire.writelock.failed=Failed to acquire write lock on backend list
loadbalancer.backend.autogeneratedkeys.unsupported=Backend {0} does not support auto generated keys.
loadbalancer.backend.disabling=Disabling backend {0} because it is no more in sync
loadbalancer.backend.disabling.connection.failure=Disabling backend {0} because connections failed inside a transaction.
loadbalancer.backend.disabling.unreachable=Disabling backend {0} because it is no more reachable.
loadbalancer.backend.is.disabling=Cannot execute request {0} on backend {1} because it is disabling.
loadbalancer.backend.enabling=Enabling backend {0}
loadbalancer.backend.no.connection=No more connection available on backend {0}
loadbalancer.backend.no.required.table=No database backend has the required table ({0})
loadbalancer.backend.no.required.tables=No database backend has the required tables ({0})
loadbalancer.backend.no.required.storedprocedure=No database backend has the required stored procedure ({0})
loadbalancer.backend.unreacheable=Backend {0} is no more reachable.
loadbalancer.backend.workerthread.starting=Starting {0} worker threads for backend {1}
loadbalancer.backend.workerthread.stopping=Stopping {0} worker threads of backend {1}
loadbalancer.backendlist.empty=No backend to execute the request.
loadbalancer.commit.all.failed=No backend thread succeeded to commit transaction {0}
loadbalancer.commit.failed=Failed to commit transaction {0} on backend {1} ({2})
loadbalancer.commit.failed.and.abort=Failed to commit transaction {0}, transaction has been aborted ({1})
loadbalancer.commit.failed.stack=Commit of transaction {0} failed:
loadbalancer.connection.failed=Connection for transaction {0} failed on backend {1} ({2})
loadbalancer.connectionmanager.not.found=Unable to find connection manager for login {0} on backend {1}
loadbalancer.constructor.backends.not.disabled=Backends must be disabled when installing a new load balancer. Disabling backend {0}
loadbalancer.create.table.rule.failed=Unable to create table using the specified rule ({0})
loadbalancer.execute.find.backend.failed=Failed to find a backend to execute {0} ({1})
loadbalancer.execute.no.backend.available=No available backend to execute request {0}
loadbalancer.execute.no.backend.enabled=No enabled backend to execute request {0}
loadbalancer.execute.no.backend.found=No backend found to execute request {0}
loadbalancer.execute.on=Request {0} executed on {1}
loadbalancer.execute.on.several=Request {0} execute on {1} backends
loadbalancer.execute.transaction.on=Transaction {0} - request {1} executed on {2}
loadbalancer.from.not.found=Unable to get the FROM clause table in request {0}
loadbalancer.getmetadata.failed=Getting metaData for {0} failed on database backend {1} ( because of {2} )
loadbalancer.releasesavepoint.all.failed=No backend thread succeeded to release savepoint {0} from transaction {1}
loadbalancer.releasesavepoint.failed=Failed to release savepoint {0} from transaction {1} on backend {2} ({3})
loadbalancer.releasesavepoint.failed.stack=Release savepoint {0} from transaction {1} failed:
loadbalancer.request.failed=Request {0} failed ({1})
# 0 => type of request (read request, stored procedure, ...), 1 => request transaction id
loadbalancer.request.failed.all=No backend thread succeeded to execute {0} {1}
loadbalancer.request.failed.and.abort=Request {0} failed, transaction has been aborted ({1})
loadbalancer.request.failed.on.backend=Request {0} failed on backend {1} ({2})
# 0 => type of request (read request, stored procedure, ...), 1 => request transaction id
loadbalancer.request.failed.stack={0} {1} failed:
loadbalancer.request.on=Request {0} executed on {1}
loadbalancer.request.target.table.not.found=Unable to get target table in request {0}
loadbalancer.request.timeout=Request {0} has timed out ({1} success - {2} failures)
loadbalancer.rollback.all.failed=No backend thread succeeded to rollback transaction {0}
loadbalancer.rollback.failed=Failed to rollback transaction {0} on backend {1} ({2})
loadbalancer.rollback.failed.and.abort=Failed to rollback transaction {0}, transaction has been aborted ({1})
loadbalancer.rollback.failed.stack=Rollback of transaction {0} failed:
loadbalancer.rollbacksavepoint.all.failed=No backend thread succeeded to rollback to savepoint {0} for transaction {1}
loadbalancer.rollbacksavepoint.failed=Failed to rollback to savepoint {0} for transaction {1} on backend {2} ({3})
loadbalancer.rollbacksavepoint.failed.stack=Rollback to savepoint {0} for transaction {1} failed:
loadbalancer.setsavepoint.all.failed=No backend thread succeeded to set savepoint {0} to transaction {1}
loadbalancer.setsavepoint.failed=Failed to set savepoint {0} to transaction {1} on backend {2} ({3})
loadbalancer.setsavepoint.failed.stack=Set savepoint {0} to transaction {1} failed:
loadbalancer.something.failed={0} {1} failed ({2})
loadbalancer.something.failed.on={0} {1} failed on backend {2} ({3})
loadbalancer.storedprocedure.backend.no.enabled=No enabled backend to execute stored procedure {0}
loadbalancer.storedprocedure.on=Stored procedure {0} executed on {1}
loadbalancer.storedprocedure.failed=Stored procedure {0} failed ({1})
loadbalancer.storedprocedure.failed.all=No backend thread succeeded to execute stored procedure {0}
loadbalancer.storedprocedure.failed.on.all.backends=Stored procedure {0} failed on all backends ({1})
loadbalancer.storedprocedure.failed.on.backend=Stored procedure {0} failed on backend {1} ({2})
loadbalancer.storedprocedure.failed.stack=Stored procedure {0} failed:
loadbalancer.storedprocedure.failed.twice=Stored procedure {0} failed twice ({1})
loadbalancer.storedprocedure.no.backend.found=No backend found to execute request {0}
loadbalancer.storedprocedure.status=Stored procedure {0} succeeded on {1} but failed on {2}
loadbalancer.transaction.already.started=Transaction {0} is already started.
loadbalancer.unable.get.connection=Unable to get connection for transaction {0} on backend {1}
loadbalancer.unable.retrieve.connection=Unable to retrieve connection for transaction {0} on backend {1}
loadbalancer.unable.retrieve.savepoint=Unable to retrieve savepoint {0} for transaction {1} on backend {2}
loadbalancer.waitforcompletion.unsupported=Unsupported WaitForCompletion policy, waiting for all nodes.
loadbalancer.weight.set=Setting weight {0} for backend {1}

############################################
############# Cache messages ###############
############################################
cache.memory.error.cache.flushed=Memory Error, cache was flushed: {0}
cache.metadata.invalid.size=Invalid metadata cache size ({0})
cache.parsing.failed.join.parser.thread=Failed to join parser thread at scheduler for read request: {0} ({1})
cache.parsing.invalid.size=Invalid parsing cache size ({0})
cache.parsing.jmx.size=Invalid parsing cache size ({0})
cache.schemas.not.supported=This cache does not support database schemas.
cache.scheduler.doesnt.support.schemas=This scheduler does not support database schemas.
cachebehavior.new.action=New cache action with type: {0}
cache.dump=Parsing cache:
cache.granularity=\n\tGranularity={0}
cache.max.entries=\n\tMax number of entries={0}
cache.background.parsing=\n\tBackground parsing={0}
cache.case.sensitive=\n\tCase sensitive={0}
cache.entries=\n\tCache entries: (unique key: request)
cache.entry=\n\t\t{0}: {1}
cache.currently.parsing.entries=\n\tCurrently parsed: (unique key: request)
cache.currently.parsing.entry=\n\t\t{0}: {1}

resultcache.adding.query=Adding query {0} to cache
resultcache.adding.table=Adding table {0}
resultcache.adding.to.pending.queries=Adding {0} to pending queries.
resultcache.behavior.for.request=Behavior for request {0} : {1}
resultcache.cache.flushed=Cache flushed
resultcache.cache.hit=Cache hit {0}
resultcache.cache.miss=Cache miss
resultcache.error.while.merging=Error while merging new database schema {0}
resultcache.error.retrieving.cache.data=Error while retrieving cache data {0}
resultcache.flushing.cache.cause.rollback=Flushing whole cache due to rollback of transaction : {0}
resultcache.flusing.whole.cache=Removing all tables and flushing whole cache.
resultcache.merging.new.database.schema=Merging new database schema
resultcache.modifying.result.valid.entry=Modifying the result of a valid entry in the cache ({0})
resultcache.null.result=Trying to add a null result in the cache {0}
resultcache.pending.query.timeout=Pending query timeout
resultcache.removing.oldest.cache.entry=Removing oldest cache entry: {0}
resultcache.removing.pending.query=Removing {0} from pending queries.
resultcache.removing.pending.query.failed=Unable to remove pending query {0}
resultcache.removing.table=Removing table {0}
resultcache.setting.database.schema=Setting new database schema.
resultcache.streamed.resultset=Cannot cache streamed ResultSet for request {0}
resultcache.uncacheable.request=Trying to add an uncacheable request to the cache {0}
resultcache.valid.entry.without.result=WARNING! Valid cache entry without result: {0}
resultcache.waiting.pending.query=Waiting for pending query {0}

cachethread.cache.empty.sleeping=Cache is empty. I sleep.
cachethread.remove.entry.from.cache=Removing entry from cache: {0}
cachethread.sleeping=Sleeping for: {0} seconds

############################################
########### Scheduler messages #############
############################################
scheduler.begin.timeout.writesSync=Timeout in begin, still waiting for {0} pending writes to complete
scheduler.begin.timeout.transactionSync=Timeout in begin, still waiting for {0} pending transactions to complete
scheduler.commit.timeout.writesSync=Timeout in commit, still waiting for {0} pending writes to complete
scheduler.doesnt.support.schemas=This scheduler does not support database schemas.
scheduler.releasesavepoint.timeout.writeSync=Timeout in release savepoint, still waiting for {0} pending writes to complete
scheduler.request.timeout=Request {0} timeout ({1} ms) in scheduler, still waiting for {2} pending writes to complete
scheduler.request.timeout.failed=Request timeout failed in scheduleWriteRequest ({0})
scheduler.request.notActive=No request with id {0} found active in scheduler
scheduler.rollback.timeout.writesSync=Timeout in rollback, still waiting for {0} pending writes to complete
scheduler.rollbacksavepoint.timeout.writeSync=Timeout on writesSync in rollback to savepoint
scheduler.setsavepoint.timeout.writeSync=Timeout in set savepoint, still waiting for {0} pending writes to complete
scheduler.suspend.transaction.failed=Wait failed in suspendNewTransactionsForCheckpoint ({0})
scheduler.suspend.writes.failed=Wait failed in suspendWrites ({0})

############################################
########## Recovery Log messages ###########
############################################
recovery.cannot.get.checkpoint=Unable to get checkpoint from recovery log.
recovery.cannot.recover.from.index=Unable to complete recovery due to error ({0})
recovery.checkpoint.stored=Checkpoint {0} was stored
recovery.checkpoint.storing=Storing checkpoint {0}
recovery.cleaning.failed=Error while cleaning the recovery log
recovery.consistency.checking=Checking recovery log consistency
recovery.consistency.checking.failed=Check of recovery log consistency has failed (because of {0})
recovery.failed.with.error=Recovery process failed to replay: request {0} ({1})
recovery.failed.with.error.transaction=Recovery process failed to replay transaction {0}: request {1} ({2})
recovery.jdbc.backendtable.case.mismatch=Backend table {0} does not match database table name case ({1})
recovery.jdbc.backendtable.create=Creating backend table: {0}
recovery.jdbc.backendtable.create.failed=Unable to create backend table {0} ({1})
recovery.jdbc.backendtable.statement=Backend table create statement: {0}
recovery.jdbc.checkpoint.check.failed=Unable to check for duplicate checkpoint name ({0})
recovery.jdbc.checkpoint.duplicate=A checkpoint with name {0} already exists!
recovery.jdbc.checkpoint.list.failed=Failed to get checkpoint list ({0})
recovery.jdbc.checkpoint.id.not.found=No log id found found for checkpoint {0} corresponding to request id {1}
recovery.jdbc.checkpoint.not.found=Checkpoint {0} does not exist in recovery log
recovery.jdbc.checkpoint.not.found.error=Unable to get checkpoint {0} from the recovery log ({1})
recovery.jdbc.checkpoint.remove.failed=Unable to remove checkpoint {0} from recovery log database ({1})
recovery.jdbc.checkpoint.store.failed=Unable to store checkpoint {0} in recovery log database ({1})
recovery.jdbc.checkpointtable.case.mismatch=Checkpoint table {0} does not match database table name case ({1})
recovery.jdbc.checkpointtable.create=Creating checkpoint table: {0}
recovery.jdbc.checkpointtable.create.failed=Unable to create checkpoint table {0} ({1})
recovery.jdbc.checkpointtable.statement=Checkpoint table create statement: {0}
recovery.jdbc.commit.not.found=Commit {0} does not exist in recovery log
recovery.jdbc.commit.not.found.error=Unable to get commit {0} from the recovery log ({1})
recovery.jdbc.connect=Connection to {0} as user {1}
recovery.jdbc.connect.failed=Failed to get connection ({0})
recovery.jdbc.dump.info.failed=Failed to retrieve information for dump {0} ({1})
recovery.jdbc.dump.list.failed=Failed to get dump list ({0})
recovery.jdbc.dump.store.failed=Failed to store dump {0} ({1})
recovery.jdbc.dump.remove.failed=Failed to remove dump {0} ({1})
recovery.jdbc.dump.update.column.failed=Failed to update column for dump {0} ({1})
recovery.jdbc.dumptable.case.mismatch=Dump table {0} does not match database table name case ({1})
recovery.jdbc.dumptable.create=Creating dump table: {0}
recovery.jdbc.dumptable.create.failed=Unable to create dump table {0} ({1})
recovery.jdbc.dumptable.statement=Dump table create statement: {0}
recovery.jdbc.entries.remove.failed=Failed to remove entries from recovery log ({0})
recovery.jdbc.loggerthread.awaken=JDBCLoggerThread awaken
recovery.jdbc.loggerthread.log.failed=Failed to log {0}
recovery.jdbc.loggerthread.log.failed.transaction=Failed to log {0} for transaction {1}
recovery.jdbc.loggerthread.log.info=Logging request {0}
recovery.jdbc.loggerthread.log.reset.failed=Failed to reset recovery log for checkpoint {0}
recovery.jdbc.loggerthread.log.update.failed=Failed to update completion for log entry {0} with success status to {1}.
recovery.jdbc.loggerthread.removing=Removing queries of transaction {0} from logging queue
recovery.jdbc.loggerthread.shift.failed=Failed to shift recovery entries log ({0})
recovery.jdbc.loggerthread.unlog.info=Unlogging request {0}
recovery.jdbc.logtable.case.mismatch=Log table {0} does not match database table name case ({1})
recovery.jdbc.logtable.create=Creating recovery log table: {0}
recovery.jdbc.logtable.create.failed=Unable to create table {0} ({1})
recovery.jdbc.logtable.statement=Log table create statement: {0}
recovery.jdbc.logtable.getvalue.failed=Unable to get the maximum value of logTable id ({0})
recovery.jdbc.recover.failed=Unable to recover a request ({0})
recovery.jdbc.rollback.not.found=Rollback {0} does not exist in recovery log
recovery.jdbc.rollback.not.found.error=Unable to get rollback {0} from the recovery log ({1})
recovery.jdbc.sql.unkwown=Unknown SQL statement "{0}"
recovery.jdbc.table.found=Table found: {0}
recovery.jdbc.table.no.description=Unable to get recovery log table description
recovery.jdbc.transaction.remove.failed=Unable to remove transaction {0} from recovery log ({1})
recovery.jdbc.updatecount.not.found=Update count {0} does not exist in recovery log
recovery.jdbc.updatecount.not.found.error=Unable to get update count {0} from the recovery log ({1})
recovery.jdbc.update.failed=Update request failed
recovery.join.failed=Failed to join() on recovery thread
recovery.process.complete=Recovery completed
recovery.restore.checkpoint.failed.cause.null=Cannot restore from checkpoint {0} because no recovery log has been defined
recovery.restore.backend.state.invalid=Invalid state of backend {0}
recovery.start.process=Starting recovery
recovery.store.checkpoint.failed=Could not store checkpoint for backend: {0} ({1})
recovery.store.checkpoint.failed.cause.null=Cannot store checkpoint {0} because no recovery log has been defined

backup.manager.backuping.backend=Starting backup of backend {0} with checkpoint {1}
backup.manager.restoring.backend=Starting restore of backend {0} from checkpoint {1}

##########################
######### Request ########
##########################
request.not.parsed=\nRequest not parsed yet
request.parsing.results=Request parsing results:
request.unique.key=\n\tUnique key={0}
request.type=\n\tType={0}
request.locked.tables=\n\tLocked tables:
request.locked.table=\n\t\t{0}
request.table.involved=\n\tTable involved in write={0}
request.table.column=\n\t\t{0}
request.blocking=\n\tBlocking={0}
request.primary.key=\n\tPrimary key={0}
request.delete.single.row=\n\tDeletes single row={0}
request.from.tables=\n\tFrom tables:
request.from.table=\n\t\t{0}
request.where.tables=\n\tWhere tables:
request.where.table=\n\t\t{0}
request.alter.table=\n\tAlter table={0}
request.alter.column=\n\tAlter column={0}
request.alter.is.drop=\n\tAlter isDrop={0}
request.alter.is.add=\n\tAlter isAdd={0}
request.alters=\n\tAlters:\
\n\t\tAggregateList={0},\
\n\t\tDatabaseCatalog={1},\
\n\t\tDatabaseSchema={2},\
\n\t\tMetadataCache={3},\
\n\t\tQueryResultCache={4},\
\n\t\tSomething={5},\
\n\t\tStoredProcedureList={6},\
\n\t\tUserDefinedTypes={7},\
\n\t\tUsers={8}
request.create.table=\n\tCreate table={0}
request.create.from.tables=\n\tFrom tables:{0}
request.create.from.table=\n\t\t{0}
request.select.selects=\n\tSelected columns:
request.select.select=\n\t\t{0}
request.select.froms=\n\From tables:
request.select.from=\n\t\t{0}
request.select.alias.froms=\n\Alias from tables:
request.select.alias.from=\n\t\t{0}
request.select.wheres=\n\Where columns:
request.select.where=\n\t\t{0}
request.select.orders=\n\Order by columns:
request.select.order=\n\t\t{0}
request.storedproc.name=\n\tProcedure name={0}
request.storedproc.parameters.number=\n\tNumber of parameters={0}
request.storedproc.named.parameters.names=\n\tNamed parameters names:
request.storedproc.named.parameters.name=\n\t\t{0}
request.storedproc.named.parameters.values=\n\tNamed parameters values:
request.storedproc.named.parameters.value=\n\t\t{0}: {1}
request.storedproc.out.parameters.indexes=\n\tOut parameters indexes:
request.storedproc.out.parameters.index=\n\t\t{0}
request.storedproc.out.parameters.values=\n\Out parameters values:
request.storedproc.out.parameters.value=\n\t\t{0}: {1}
request.storedproc.semantic=\n\tProcedure semantic={0}
request.update.unique=\n\tUpdates unique row={0}
request.update.values=\n\tUpdated values:
request.update.value=\n\t\t{0}: {1}

##############################
######### Transaction ########
##############################
transaction.aborted=Transaction {0} aborted
transaction.aborting=Aborting transaction {0}
transaction.begin=Begin transaction {0}
transaction.begin.lazy=Begin lazily transaction {0}
transaction.begin.log=Logging transaction {0} begin
transaction.commit=Commit transaction {0}
transaction.marker.not.found=No transaction marker metadata found for transaction {0}
transaction.not.started=Transaction {0} is not started
transaction.releasesavepoint=Release savepoint {0} from transaction {1}
transaction.rollback=Rollback transaction {0}
transaction.rollbacksavepoint=Rollback transaction {0} to savepoint {1}
transaction.savepoint.not.found=No savepoint {0} found for transaction {1}
transaction.setsavepoint=Set savepoint {0} to transaction {1}

######################
######### JMX ########
######################

   ### From Controller ###
jmx.configure.enabled=JMX is enabled
jmx.configure.disabled=JMX is disabled

   ### Standard Message ###
jmx.create.http.adaptor=Registering HTTP Adaptor for hostname {0} and port {1}
jmx.create.jrmp.adaptor=Create JRMP adaptor
jmx.create.jrmp.ssl.enabled=SSL Enabled for JRMP adaptor
jmx.create.naming.service=Create and start naming service
jmx.create.xslt.processor=Set the XSLT processor
jmx.prepare.jndi=Set jndi name and properties
jmx.register.mbean=Register MBean of type {0} with name {1}
jmx.server.mbean.count=Total number of MBeans registered: {0}
jmx.server.not.java5=Unable to create Java 5 platform MBeanServer
jmx.server.from.classpath=Create the MBeanServer from the classpath
jmx.server.from.java5=Create the MBeanServer from Java 5

   ### Errors ###
jmx.delete.mbean.failed=Failed to delete mbean with name {0} because of {1}
jmx.register.mbean.already.exist=MBean with name {0} has already been registered. Deleting old mbean.
jmx.register.mbean.failed=Register mbean of type {0} failed with error {1} ({2})
jmx.failed.register.mbean.requestmanager=Failed to register Request Manager MBean
jmx.failed.register.mbean.loadbalancer=Failed to register Load Balancer MBean

## JMX Notifications ##
sequoia.controller.virtualdatabases.removed=Removed virtual database from controller
sequoia.controller.virtualdatabase.added=Added virtual database to controller
sequoia.virtualdatabase.dump.list=New Dump available
sequoia.virtualdatabase.backend.added=Added backend to virtual database
sequoia.distributed.controller.added=Added controller
sequoia.distributed.controller.removed=Removed controller
sequoia.distributed.controller.failed=Failed controller
sequoia.distributed.controller.joined=Joined controller
sequoia.virtualdatabase.backend.disabled=Disabled backend
sequoia.virtualdatabase.backend.enabled=Enabled backend
sequoia.virtualdatabase.backend.recovering=Restoring backend...
sequoia.virtualdatabase.backend.replaying=Replaying backend
sequoia.virtualdatabase.backend.recovery.failed=Failed to restore backend
sequoia.virtualdatabase.backend.replaying.failed=Failed to replay backend
sequoia.virtualdatabase.backend.backingup=Backing up backend...
sequoia.virtualdatabase.backend.enable.write=Wrote-enabled backend
sequoia.virtualdatabase.backend.enable.read=Read-enabled backend
sequoia.virtualdatabase.backend.removed=Removed backend
sequoia.virtualdatabase.backend.disabling=Disabling backend...
sequoia.virtualdatabase.backend.unknown=Unknown backend!

RecoveryLogControl.login=login
RecoveryLogControl.request=request
RecoveryLogControl.txFlag=tx flag
RecoveryLogControl.txId=tx id
RecoveryLogControl.globalId=global id
RecoveryLogControl.time=time
RecoveryLogControl.numUpdates=# updates
RecoveryLogControl.LogEntryDescription=Composite type for an entry of the recovery log
RecoveryLogControl.LogEntriesDescription=Tabular type for entries of the recovery log
RecoveryLogControl.openTypeWarning=unable to define OpenTypes
# 0 => entry array representation
RecoveryLogControl.conversionWarning=unable to convert entry to CompositeDate [entry={0}]

###################################
######### CONSOLE MESSAGES ########
###################################

### Backends Viewer ###
console.infoviewer.backend.name=Backend Name
console.infoviewer.backend.driver=Driver
console.infoviewer.backend.url=URL
console.infoviewer.backend.active.transactions=Active transactions
console.infoviewer.backend.pending.requests=Pending Requests
console.infoviewer.backend.read.enabled=Read Enabled
console.infoviewer.backend.write.enabled=Write Enabled
console.infoviewer.backend.init.status=Is Initialized
console.infoviewer.backend.static.schema=Static Schema
console.infoviewer.backend.connection.managers=Connection Managers
console.infoviewer.backend.total.active.connections=Total Active Connections
console.infoviewer.backend.persistent.connections=Persistent Connections
console.infoviewer.backend.total.requests=Total Requests
console.infoviewer.backend.total.transactions=Total Transactions
console.infoviewer.backend.lastknown.checkpoint=Last known checkpoint

################################
######### MONITORING ###########
################################
   ### Controller ###
monitoring.controller.total.memory=Controller Total Memory
monitoring.controller.used.memory=Controller Used Memory
monitoring.controller.threads.number=Controller Total Thread Count
monitoring.controller.idle.worker.threads=Idle Controller Worker Thread Count
monitoring.controller.pending.queue=Controller Pending Queue
   ### Scheduler ###
monitoring.scheduler.number.read=Scheduler Number Read
monitoring.scheduler.number.writes=Scheduler Number Writes
monitoring.scheduler.pending.transactions=Scheduler Pending Transactions
monitoring.scheduler.pending.writes=Scheduler Pending Writes
monitoring.scheduler.number.requests=Scheduler Requests Count
   ### Database ###
monitoring.virtualdatabase.active.threads=Virtual Database Active Threads
monitoring.virtualdatabase.pending.connections=Virtual Database Pending Connections
monitoring.virtualdatabase.threads.count=Virtual Database Threads Count
   ### Client ###
monitoring.client.active.time=Client Active Time
   ### Cache ###
monitoring.cache.count.select=Cache Select Count
monitoring.cache.count.insert=Cache Insert Count
monitoring.cache.count.hits=Cache Hits Count
monitoring.cache.hits.ratio=Cache Hits Ratio
monitoring.cache.number.entries=Cache Entries Count
   ### Backend ###
monitoring.backend.active.transactions=Backend Active Transactions
monitoring.backend.pending.requests=Backend Pending Requests
monitoring.backend.active.connections=Backend Total Active Connections
monitoring.backend.total.requests=Backend Total Requests
monitoring.backend.total.transactions=Backend Total Transactions
monitoring.backend.total.read.requests=Backend Total Read Requests
monitoring.backend.total.write.requests=Backend Total Write Requests


########################
######### ZIP ##########
########################
zip.archiving=Archiving {0} to {1}
zip.directory.not.found=Directory {0} does not exist.
zip.extracting=Extracting {0} to {1}
zip.invalid.source.file=Invalid source file ({0})
zip.invalid.target.directory=Invalid target directory
zip.not.directory={0} is not a directory.

################################
######### FATAL ERRORS #########
################################

fatal.error=Fatal Error. Now Quitting.
# 0 => report file path
fatal.report.generated=A report has been generated {0}
# 0 => group communication properties file
fatal.distributed.no.group.communication.properties=Could not find group communication properties file {0}
fatal.runtime.exception.requestmanager.abort=Runtime exception in abort.
fatal.runtime.exception.requestmanager.begin=Runtime exception in begin.
fatal.runtime.exception.requestmanager.begin.log=Runtime exception in begin log.
fatal.runtime.exception.requestmanager.commit=Runtime exception in commit.
fatal.runtime.exception.requestmanager.releasesavepoint=Runtime exception in release savepoint
fatal.runtime.exception.requestmanager.rollback=Runtime exception in rollback.
fatal.runtime.exception.requestmanager.rollbacksavepoint=Runtime exception in rollback to savepoint
fatal.runtime.exception.requestmanager.setsavepoint=Runtime exception in set savepoint
