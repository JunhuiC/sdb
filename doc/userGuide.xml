<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN" "http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">

<!--
<!DOCTYPE article SYSTEM "../../../xml/docbook/dtd/simple/1.0/sdocbook.dtd">
-->

<article class="whitepaper">
  <articleinfo>
    <authorgroup> <author>
      <firstname>Emmanuel</firstname>
      <surname>Cecchet</surname> </author> <author>
      <firstname>Julie</firstname>
      <surname>Marguerite</surname> </author> <author>
      <firstname>Mathieu</firstname>
      <surname>Peltier</surname> </author> <author>
      <firstname>Nicolas</firstname>
      <surname>Modrzyk</surname> </author> <author>
      <firstname>Dylan</firstname>
      <surname>Hansen</surname> </author> <author>
        <firstname>Nuno</firstname>
        <surname>Carvalho</surname> </author>
    </authorgroup>
    <copyright>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <year>2005</year>
      <year>2006</year>
      <holder>French National Institute For Research In Computer Science And Control
        (INRIA)</holder>
      <holder>Continuent</holder>
    </copyright>
    <releaseinfo>Version @VERSION@</releaseinfo>
    <title>Sequoia User's Guide</title>
    <legalnotice>
      <para>Java, and all Java-based trademarks are trademarks or registered trademarks of
        Sun Microsystems, Inc. in the United States and other countries.</para>
    </legalnotice>
  </articleinfo>
  <!-- =============================================================== -->
  <!-- Section: Getting Started -->
  <!-- =============================================================== -->
  <section id="getting_started">
    <title>Getting Started</title>
    <!-- ========== What is Sequoia? ========== -->
    <section id="what_is_sequoia">
      <title>What is Sequoia?</title>
      <para>Sequoia is a database cluster middleware that allows any <trademark 
        class="trade">Java</trademark> application (standalone application, 
        servlet or <trademark class="trade">EJB</trademark> container, ...) to 
        transparently access a cluster of databases through <trademark 
        class="trade">JDBC</trademark>. You do not have to modify client 
        applications, application servers or database server software. You just 
        have to ensure that all database accesses are performed through 
        Sequoia.</para>
      <para>Sequoia is a <emphasis>free</emphasis>, <emphasis>open source</emphasis>
        project that is the continuation of the <ulink
          url="http://c-jdbc.objectweb.org">C-JDBC project</ulink> hosted by the
          <ulink url="http://www.objectweb.org/">ObjectWeb Consortium</ulink>.
        Sequoia is licensed under an <ulink
          url="http://www.apache.org/licenses/LICENSE-2.0.html">Apache v2
        license</ulink> is licensed whereas C-JDBC is available under the <ulink
          url="http://www.gnu.org/copyleft/lesser.html">GNU Lesser General Public
        License</ulink> (LGPL).</para>
      <para>Sequoia also provides driver for non-Java applications. These developments
        are hosted in the <ulink url="http://carob.continuent.org">Carob
        project</ulink>. An Eclipse plug-in for Sequoia is also available in the <ulink
          url="http://oak.continuent.org">Oak project</ulink>.</para>
    </section>
    <!-- ========== What do I need to use Sequoia? ========== -->
    <section id="what_do_i_need_to_use_sequoia">
      <title>What do I need to use Sequoia?</title>
      <para>In order to use Sequoia, you will need:</para>
      <itemizedlist>
        <listitem>
          <para>a client application that accesses a database through 
            JDBC,</para>
        </listitem>
        <listitem>
          <para>a <trademark class="trade">JDK</trademark> 1.4 (or greater) compliant
              <trademark class="trade">Java Virtual Machine</trademark>
            (JVM)<footnote><para>Sequoia may work with older JVM version, but hasn't been
            tested.</para></footnote>,</para>
        </listitem>
        <listitem>
          <para>a database with a JDBC driver (type 1, 2, 3 or 4) or an ODBC 
            driver used with the JDBC-ODBC bridge.</para>
        </listitem>
        <listitem>
          <para>a network supporting TCP/IP communications between your cluster 
            nodes.</para>
        </listitem>
      </itemizedlist>
      <note>
        <para>If your client application does not use JDBC, you can use the C++ API or the ODBC
          driver provided by the <ulink url="http://carob.continuent.org/">Carob
          project </ulink>.</para>
      </note>
    </section>
    <!-- ========== Why should I use Sequoia? ========== -->
    <section id="why_should_i_use_sequoia">
      <title>Why should I use Sequoia?</title>
      <para>You have a Java application or a Java-based application server that 
        accesses one or several databases. The database tier becomes the 
        bottleneck of your application or it is a single point of failure or 
        both. Sequoia can help you resolve these problems by providing:</para>
      <itemizedlist>
        <listitem>
          <para>performance scalability by adding database nodes and balancing 
            the load among these nodes.</para>
        </listitem>
        <listitem>
          <para>high availability of the database tier, i.e. Sequoia tolerates 
            database crashes and offers transparent failover using database 
            replication techniques.</para>
        </listitem>
        <listitem>
          <para>improved performance with fine grain query caching and 
            transparent connection pooling.</para>
        </listitem>
        <listitem>
          <para>SQL traffic logging for performance monitoring and 
            analysis.</para>
        </listitem>
        <listitem>
          <para>support for clusters of heterogeneous database engines.</para>
        </listitem>
      </itemizedlist>
    </section>
    <!-- ========== How does it work? ========== -->
    <section id="how_does_it_works">
      <title>How does it work?</title>
      <para>Sequoia provides a flexible architecture that allows you to achieve 
        scalability, high availability and failover with your database tier. 
        Sequoia implements the concept of RAIDb: <emphasis>Redundant Array of 
        Inexpensive Databases</emphasis> (see <xref linkend="raidb_basics"/>). 
        The database is distributed and replicated among several nodes and 
        Sequoia load balances the queries between these nodes.</para>
      <para>Sequoia provides a generic JDBC driver to be used by the clients 
        (see <xref linkend="sequoia_driver"/>). This driver forwards the SQL 
        requests to the Sequoia controller (see <xref 
        linkend="sequoia_controller"/>) that balances them on a cluster of 
        databases (reads are load balanced and writes are broadcasted). Sequoia 
        can be used with any RDBMS (Relational DataBase Management System) 
        providing a JDBC driver, that is to say almost all existing open source 
        and commercial databases. <xref linkend="fig_sequoia_principle"/> gives 
        an overview of the Sequoia principle.</para>
      <figure id="fig_sequoia_principle">
        <title>Sequoia principle</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/sequoia_principle.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/sequoia_principle.gif" align="center" 
              format="GIF" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Sequoia allows to build any cluster configuration including mixing 
        database engines from different vendors. The main features provided by 
        Sequoia are performance scalability, fault tolerance and high 
        availability. Additional features such as monitoring, logging, SQL 
        requests caching are provided as well.</para>
      <para>The architecture is widely open to allow anyone to plug custom 
        requests schedulers, load balancers, connection managers, caching 
        policies, ...</para>
    </section>
    <!-- ========== What does it cost? ========== -->
    <section id="what_does_it_cost">
      <title>What does it cost?</title>
      <para>From a software point of view, Sequoia is an open-source software licensed under
        Apache v2 License which means that it is free of charge for any usage (personal or
        commercial). If you are using commercial RDBMS (such as Oracle, DB2, ...), you will
        have to buy extra licenses for the nodes where you install replicas of the database.
        But you can possibly use open-source databases to host replicas of your main
        database.</para>
      <para>You need to buy extra machines if you want more performance and more fault
        tolerance. Sequoia has been designed to work with standard off-the-shelf
        workstations because it primarily targets low cost open-source solutions but it can
        work as well with large SMP machines. A standard Ethernet network is sufficient to
        achieve good performance.</para>
    </section>
    <!-- ========== What kind of modifications are needed? ========== -->
    <section id="what_modifications_are_needed">
      <title>What kind of modifications are needed?</title>
      <para>You <emphasis>do not have to change anything</emphasis> to your 
        application or your database.</para>
      <para>You only have to update the JDBC driver configuration used by your 
        application (usually it is just a configuration file update) and to 
        setup a Sequoia configuration file (see <xref 
        linkend="configuration"/>).</para>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Getting the Software -->
  <!-- =============================================================== -->
  <section id="getting_the_software">
    <title>Getting the Software</title>
    <para>The binary distribution of Sequoia can be downloaded from <ulink 
      url="http://sequoia.continuent.org/">Sequoia's Web site</ulink>. It mainly 
      contains the JAR files for the Sequoia driver and controller and also the 
      documentation and other tools such as the Sequoia administration 
      console.</para>
    <note>
      <para>A source distribution of Sequoia is also available. The whole code 
        base can also be downloaded through an anonymous CVS 
        server<footnote><para>CVS stands for <emphasis>Concurrent Versions 
        System</emphasis> and is a popular version control 
        system.</para></footnote>. For more information, please refer to Sequoia 
        Developer's Guide. Most users will only need the binary 
        distribution.</para>
    </note>
    <para>The following formats are available (where 
      <literal>x.y</literal> is the Sequoia release number):</para>
    <itemizedlist>
      <listitem>
        <para><filename 
          class="libraryfile">sequoia-x.y-bin-installer.jar</filename>: Java 
          graphical installer (powered by <ulink 
          url="http://www.izforge.com/izpack/">IzPack</ulink>).</para>
      </listitem>
      <listitem>
        <para><filename class="libraryfile">sequoia-x.y-bin.tar.gz</filename>: 
          binary distribution for the Unix platforms users.</para>
      </listitem>
      <listitem>
        <para><filename class="libraryfile">sequoia-x.y-bin.zip</filename>: 
          binary distribution for the Windows platforms users.</para>
      </listitem>
    </itemizedlist>
    <para>We strongly advice to use the Java installer package since it 
      automatically configures the scripts to suit your system 
      configuration.</para>
    <note>
      <para>All distributions contain the user documentation.</para>
    </note>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Installation -->
  <!-- =============================================================== -->
  <section id="installation">
    <title>Installation</title>
    <!-- ========== Sequoia Controller ========== -->
    <section id="sequoia_controller_install">
      <title>Sequoia Controller</title>
      <section id="using_java_graphical_installer">
        <title>Using the Java graphical installer</title>
        <para>The easiest way to install Sequoia is to use the Java graphical 
          installer. A Java Virtual Machine is of course needed in this 
          case.</para>
        <itemizedlist>
          <listitem>
            <para>Unix users can simply launch the installation program by 
              typing:</para>
            <programlisting> 
              bash> java -jar sequoia-x.y.bin-installer.jar 
            </programlisting>
          </listitem>
          <listitem>
            <para>Windows users can use the same command or just double-click on 
              the JAR installation file if your JRE has been properly 
              installed.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="using_binary_distribution">
        <title>Using the binary distribution</title>
        <para>If you want to use the other distribution formats (for example if 
          you have not installed a JVM or if you can not launch a graphical 
          application), you have to uncompress the downloaded file in the 
          directory of your choice, and then set the 
          <literal>SEQUOIA_HOME</literal> environment variable.</para>
        <note>
          <para>If you are using the Java installer, you do not need to set any 
            environment variable since the installer customizes the scripts 
            with the installation path.</para>
        </note>
        <para>To set the <literal>SEQUOIA_HOME</literal> environment variable, 
          you can proceed as follows:</para>
        <itemizedlist>
          <listitem>
            <para>Unix users can proceed as follows:</para>
            <programlisting> 
bash> mkdir -p /usr/local/sequoia
bash> cd /usr/local/sequoia
bash> tar xfz /path-to-sequoia-bin-dist/sequoia-x.y-bin.tar.gz
bash> export SEQUOIA_HOME=/usr/local/sequoia
            </programlisting>
            <note>
              <para>In this example, we assume you install Sequoia in the 
                <filename class="directory">/usr/local/sequoia</filename> 
                directory.</para>
            </note>
            <para>You can modify your shell configuration file 
              (<filename>.bashrc</filename>, <filename>.cshrc</filename>, ...) 
              to set the environment variable permanently.</para>
          </listitem>
          <listitem>
            <para>Windows users have to use an utility such as <ulink 
              url="http://www.winzip.com/">WinZip</ulink> to extract the files 
              from the archive. Then, to set the <literal>CJDB_HOME</literal> 
              variable, do the following according to your Windows 
              version:</para>
            <itemizedlist>
              <listitem>
                <para><emphasis>Windows 95 or 98</emphasis>: you must insert 
                  the following line in the <filename>AUTOEXEC.BAT</filename> 
                  file:</para>
                <programlisting>set SEQUOIA_HOME="C:\Program Files\Sequoia"</programlisting>
              </listitem>
              <listitem>
                <para><emphasis>Windows Me</emphasis>: go to the <quote>Start 
                  Menu</quote>, then choose <quote>Programs</quote>, 
                  <quote>Accessories</quote>, <quote>System Tools</quote> and 
                  <quote>System Information</quote>. A window titled 
                  <quote>Microsoft Help and Support</quote> should appear. 
                  Select the <quote>Tools</quote> menu, and choose the 
                  <quote>System Configuration Utility</quote>. Go to the 
                  <quote>Environment</quote> and click on the 
                  <quote>New</quote> button. Enter 
                  <literal>SEQUOIA_HOME</literal> in the <quote>Variable 
                  Name</quote> field and <filename 
                  class="directory">"C:\Program Files\Sequoia"</filename> in 
                  <quote>Variable Value</quote>. Once you have changed and 
                  saved the value, you will be prompted for reboot.</para>
              </listitem>
              <listitem>
                <para><emphasis>Windows NT</emphasis>: go to the <quote>Start 
                  Menu</quote>, then choose <quote>Settings</quote>, 
                  <quote>Control Panel</quote> and select 
                  <quote>System</quote>. Select the <quote>Environment</quote> 
                  tab and click on the <quote>New</quote> button. Enter 
                  <literal>SEQUOIA_HOME</literal> in the <quote>Variable 
                  Name</quote> field and <filename 
                  class="directory">"C:\Program Files\Sequoia"</filename> in 
                  <quote>Variable Value</quote>.</para>
              </listitem>
              <listitem>
                <para><emphasis>Windows 2000</emphasis>: go to the <quote>Start 
                  Menu</quote>, then choose <quote>Settings</quote>, 
                  <quote>Control Panel</quote> and select 
                  <quote>System</quote>. Select the <quote>Advanced</quote> tab 
                  and click on the <quote>New</quote> button. Enter 
                  <literal>SEQUOIA_HOME</literal> in the <quote>Variable 
                  Name</quote> field and <filename 
                  class="directory">"C:\Program Files\Sequoia"</filename> in 
                  <quote>Variable Value</quote>.</para>
              </listitem>
              <listitem>
                <para><emphasis>Windows XP</emphasis>: go to the <quote>Start 
                  Menu</quote>, then double click on <quote>System</quote>. In 
                  the <quote>System Control Panel</quote> select the 
                  <quote>Advanced</quote> tab and push the <literal>Environment 
                  Variables</literal> button. Click on the <quote>New</quote> 
                  button for <quote>System Variables</quote>. Enter 
                  <literal>SEQUOIA_HOME</literal> in the <quote>Variable 
                  Name</quote> field and <filename 
                  class="directory">"C:\Program Files\Sequoia"</filename> in 
                  <quote>Variable Value</quote>.</para>
              </listitem>
            </itemizedlist>
            <note>
              <para>In this example, we assume you install Sequoia in the 
                <filename class="directory">C:\Program Files\Sequoia</filename> 
                directory.</para>
            </note>
            <note>
              <para>Do not forget the quotes in the SEQUOIA_HOME environment 
                variable definition else the starting scripts will fail with 
                paths including spaces.</para>
            </note>
          </listitem>
        </itemizedlist>
      </section>
    </section>
    <!-- ========== Sequoia driver ========== -->
    <section id="sequoia_driver_install">
      <title>Sequoia Driver</title>
      <para>Once you have installed the Sequoia controller, you will find the 
        driver JAR file in the <filename class="directory">drivers/</filename> 
        directory of the controller installation location.</para>
      <para>To install the Sequoia driver, you just have to add the <filename 
        class="libraryfile">sequoia-driver.jar</filename> file to the client 
        application classpath. This driver replaces the database native driver 
        in the client application. The database native driver will be used by 
        the Sequoia controller to access your database. Therefore, the Sequoia 
        driver and controller can be seen as a proxy between your application 
        and your database native driver.</para>
    </section>
    <!-- ========== Sequoia examples: RAIDb-1 out of the box ========== -->
    <section id="raidb1_out_of_the_box">
      <!-- TODO: Remove this section and make a tutorial out of it -->
      <title>Sequoia out of the box</title>
      <para>A demo featuring a RAIDb-1 configuration of HyperSonic SQL databases can be
        started by launching the <command>demo-raidb1.sh</command> or
        <command>demo-raidb1.bat</command> file from the <filename class="directory">
        demo</filename> directory in your Sequoia installation.</para>
      <para>This is especially useful if you are new to clustering, or new to 
        Sequoia. The setup used is as follows: </para>
      <itemizedlist>
        <listitem>
          <para>2 HyperSonic SQL databases are started on two different ports 
            (9001 and 9002)</para>
        </listitem>
        <listitem>
          <para>An extra HyperSonic SQL database is started on port 9003 to be 
            used as the recovery log database</para>
        </listitem>
        <listitem>
          <para>The Sequoia controller is configured to load automatically a 
            virtual database containing those two HyperSonic SQL backends. The 
            controller startup configuration file is found in 
            <filename>SEQUOIA_HOME/config/controller/controller-raidb1.xml</filename> 
            and the virtual database configuration file is 
            <filename>SEQUOIA_HOME/config/virtualdatabase/hsqldb-raidb1.xml</filename>.</para>
        </listitem>
        <listitem>
          <para>Once the RAIDb-1 configuration is loaded, you can connect to Sequoia using
            iSQL, a graphical SQL console bundled with Sequoia. You can start iSQL by using
            <command>isql.sh</command> or <command>isql.bat</command>.</para>
        </listitem>
      </itemizedlist>
      <para>The login to use for Sequoia is <literal>user</literal> with an empty 
        password. The login for both HSQL databases is <literal>test</literal> 
        with an empty password.</para>
      <note>
        <para>A tutorial in the documentation section of the Sequoia web site describes the
          usage of this demo.</para>
      </note>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Migrating from C-JDBC to Sequoia -->
  <!-- =============================================================== -->
  <section id="cjdbc_sequoia_migration">
    <title>Migrating from C-JDBC to Sequoia</title>
    <para> The C-JDBC name had to be changed due to Sun?s trademark of JDBC. Therefore, C-JDBC
      now becomes Sequoia. Sequoia is the continuation of C-JDBC and builds upon the same code
      base, so the migration should be straightforward for current users.</para>
    <section id="what_is_new_with_sequoia">
      <title>What is new with Sequoia?</title>
      <para>Sequoia is now backed by a team of 8 full-time engineers working on improving the
        technology and supporting the community. Our mission is to build industrial quality
        open source technology. Among the new major open source additions you will find a C++
        API and an ODBC driver for non-Java clients as well as a powerful Eclipse plug-in for
        the management console. The core C-JDBC technology is also greatly improved with a
        complete redesign of transaction scheduling for a better write parallelism, along
        with an upcoming, completely rewritten documentation. </para>
      <section>
        <title>Licensing</title>
        <para>C-JDBC is distributed under an LGPL open source license. While we like the
          spirit of the license and we think that an open source community can only grow if we
          contribute modifications back to the community, the LGPL is hard to enforce in
          practice and it is not always well understood by users who confuse it with the GPL.
          Therefore, the contributors and INRIA ,who is the main copyright holder, have
          agreed to re-license the code under an Apache version 2 license. This will ease code
          re-use and facilitate contributions for everybody in the community. </para>
      </section>
      <section>
        <title><ulink url="http://continuent.org">Continuent.org</ulink></title>
        <para>You might wonder why we have setup a new portal? The reason is mainly to offer a
          better support infrastructure to the community. Continuent.org projects uses a
          newer version of GForge and integrates JIRA for issue tracking. With JIRA, a more
          comfortable and flexible system, you can watch the progress of issues, vote on
          their resolution, see the project roadmap and so on. On Continuent.org, it is also
          much more flexible to start or host new projects related to the C-JDBC/Sequoia
          technology. We can easily host more external contributions or projects related to
          the technology. Don't hesitate to send your contributions! The current projects
          on Continuent.org are (we are very much in the tree names for Continuent
          projects!): </para>
        <itemizedlist>
          <listitem>
            <para><literal><ulink url="http://sequoia.continuent.org">
              Sequoia</ulink></literal>: the continuation of the C-JDBC project
              including the JDBC driver, core controller, text management console,
              documentation, ...</para>
          </listitem>
          <listitem>
            <para><literal><ulink url="http://hedera.continuent.org">
              Hedera</ulink></literal>: a replacement for Tribe that provides a more
              modular wrapping of group communications so that you have more choices than
              just JGroups. Other group communication libraries such as Appia are already
              available with Hedera.</para>
          </listitem>
          <listitem>
            <para><literal><ulink url="http://carob.continuent.org">Carob</ulink>
              </literal>: a C++ client library and API that implements the C-JDBC/Sequoia
              protocol with the controller and an ODBC driver for Sequoia</para>
          </listitem>
          <listitem>
            <para><literal><ulink url="http://oak.continuent.org">Oak</ulink>
              </literal>: the Eclipse plug-in that replaces the obsolete C-JDBC Swing
              management console</para>
          </listitem>
          <listitem>
            <para><literal><ulink url="http://appia.continuent.org">
              Appia</ulink></literal>: Appia is a layered communication framework 
              implemented by the University of Lisbon and providing extended configuration 
              and programming possibilities. Appia is composed by (1) a core that is used to 
              compose protocols and (2) a set of protocols that provide group communication, 
              ordering guarantees, atomic broadcast, among other properties.</para>
          </listitem>          
        </itemizedlist>
        <section>
          <title>C-JDBC and Sequoia</title>
          <para>So what will happen with C-JDBC? We are committed to support the technology
            and we will continue to support the community either through
            c-jdbc@objectweb.org or sequoia@continuent.org. The C-JDBC LGPL code will
            remain on ObjectWeb and the Sequoia APLv2 code will be on Continuent. Bugs
            reported on either side will be backported in best effort mode as we always did.
            </para>
        </section>
      </section>
    </section>
    <section id="migrating_cjdbc_config_to_sequoia">
      <title>Migrating your C-JDBC configuration to Sequoia</title>
      <para>Here are the steps to migrate your configuration from C-JDBC 2.0.2 to Sequoia
        2.2:</para>
      <orderedlist>
        <listitem>
          <para>Copy your <filename>controller.xml</filename> file from the C-JDBC
              <filename class="directory">config/controller</filename> directory to
            Sequoia <filename class="directory">config/controller</filename>
            directory </para>
        </listitem>
        <listitem>
          <para>Rename all instances of "C-JDBC" to "SEQUOIA". Be sure to update
            DOCTYPE</para>
        </listitem>
        <listitem>
          <para>Copy all virtual database configuration files from the C-JDBC <filename
              class="directory">config/virtualdatabase</filename> directory to
            Sequoia <filename class="directory">config/virtualdatabase</filename>
            directory</para>
        </listitem>
        <listitem>
          <para>Rename all instances of "C-JDBC" to "SEQUOIA". Be sure to update
            DOCTYPE</para>
        </listitem>
        <listitem>
          <para>Update the path of the backupers from
            org.objectweb.cjdbc.controller.backup.OctopusBackuper to
            org.continuent.sequoia.controller.backup.backupers.OctopusBackuper
            </para>
        </listitem>
        <listitem>
          <para>If using Distribution, add
            &lt;MessageTimeouts/></para>
        </listitem>
        <listitem>
          <para>Copy contents of drivers directory (except c-jdbc-driver.jar)</para>
        </listitem>
        <listitem>
          <para>Any manual changes to jgroups.xml should now be made to
            total-token.xml</para>
        </listitem>
      </orderedlist>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Sequoia Driver -->
  <!-- =============================================================== -->
  <section id="sequoia_driver">
    <title>Sequoia Driver</title>
    <!-- ========== Overview ========== -->
    <section id="driver_overview">
      <title>Overview</title>
      <para>The Sequoia driver is a generic JDBC driver that is designed to 
        replace any database specific JDBC driver that could be used by a 
        client. The client only has to know on which node the Sequoia controller 
        is running and the name of the database to access. The Sequoia driver 
        implements most of the JDBC 3.0 interface.</para>
      <para>Users reported successful usage of Sequoia with the following RDBMS: 
        <trademark class="registered">Oracle</trademark>, PostgreSQL, MySQL, 
        Apache Derby, <trademark class="registered">IBM DB2</trademark>, 
        <trademark class="registered">Sybase</trademark>, SAP DB (MySQL MaxDB), 
        HyperSonic SQL, Firebird, MS SQL Server and InstantDB.</para>
    </section>
    <!-- ========== Loading the Driver ========== -->
    <section id="loading_the_driver">
      <title>Loading the Driver</title>
      <para>The Sequoia driver can be loaded as any standard JDBC driver from 
        the client program using:</para>
      <programlisting> 
        Class.forName("org.continuent.sequoia.driver.Driver"); 
      </programlisting>
      <note>
        <para>The <filename class="libraryfile">sequoia-driver.jar</filename> 
          file must be in the client classpath else the driver will fail to 
          load.</para>
      </note>
    </section>
    <!-- ========== Sequoia JDBC URL ========== -->
    <section id="sequoia_jdbc_url">
      <title>Sequoia JDBC URL</title>
      <para>The JDBC URL expected for the use with Sequoia is the following: 
        <literal>jdbc:sequoia://host1:port1,host2:port2/database</literal>.</para>
      <para><literal>host</literal> is the machine name (or IP address) where 
        the Sequoia controller is running, <literal>port</literal> is the port 
        the controller is listening for client connections.</para>
      <para>At least one host must be specified but a list of comma separated 
        hosts can be specified. If several hosts are given, one is picked up 
        randomly from the list. If the currently selected controller fails, 
        another one is automatically picked up from the list.</para>
      <para>The port is optional is the URL and the default port number is 
        25322 if it is omitted. Those two examples are 
        equivalent:</para>
      <programlisting> 
        DriverManager.getConnection("jdbc:sequoia://localhost/tpcw"); 
        DriverManager.getConnection("jdbc:sequoia://localhost:25322/tpcw"); 
        </programlisting>
      <para>Examples using two controllers for fault tolerance:</para>
      <programlisting> 
        DriverManager.getConnection("jdbc:sequoia://c1.continuent.org,c2.objectweb.org/tpcw"); 
        DriverManager.getConnection("jdbc:sequoia://localhost,remote.continuent.org:2048/tpcw"); 
        DriverManager.getConnection("jdbc:sequoia://smpnode.com:25322,smpnode.com:1098/tpcw"); 
        </programlisting>
        
    <section id="url_options">
      <title>URL options</title>
      <para>The Sequoia driver accepts additional options to override the 
        default behavior of the driver. The options are appended at the end of 
        the Sequoia URL after a question mark followed by a list of ampersands 
        separated options. Here is an example:</para>
      <programlisting> 
        DriverManager.getConnection("jdbc:sequoia://host/db?user=me&amp;password=secret")</programlisting>
      <para>Another option is to use semicolons to delimit the start of options 
        and options themselves. Example:</para>
      <programlisting> 
        DriverManager.getConnection("jdbc:sequoia://host/db;user=me;password=secret")</programlisting>
      <para>The recognized options are:</para>
      <itemizedlist>
        <listitem>
          <para><literal>connectionPooling</literal>: By default the Sequoia 
            driver does transparent connection pooling on your behalf meaning 
            that when connection.close() is called, the connection is not 
            physically closed but rather put in a pool for reuse within the 
            next 5 seconds. Set this to false if you do not want the driver to 
            perform transparent connection pooling.</para>
        </listitem>
      </itemizedlist>      
      <itemizedlist>
        <listitem>
          <para><literal>debugLevel</literal>: Debug level that can be set to 
            'debug', 'info' or 'off' to display driver related information on 
            the standard output. Default is off.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>escapeBackslash</literal>: Set this to false if you 
            don't want to escape backslashes when performing escape processing 
            of PreparedStatements, default is true.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>escapeSingleQuote</literal>: Set this to false if you 
            don't want to escape single quotes (') when performing escape 
            processing of PreparedStatements, default is true</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>escapeCharacter</literal>: Character to prepend and 
            append to the String values when performing escape processing of 
            PreparedStatements, default is a single quote.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>user</literal>: user login</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>password</literal>: user password</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para> <literal>preferredController</literal>: defines the strategy 
            to use to choose a preferred controller to connect to.</para>
          <para> 
            <literal>jdbc:sequoia://node1,node2,node3/myDB?preferredController=ordered 
            </literal>: Always connect to node1, and if not available then try 
            to node2 and finally if none are available try node3.</para>
          <para> 
            <literal>jdbc:sequoia://node1,node2,node3/myDB?preferredController=random</literal>: 
            Pickup a controller node randomly (default strategy)</para>
          <para> 
            <literal>jdbc:sequoia://node1,node2:25343,node3/myDB?preferredController=node2:25343,node3 
            </literal>: Round-robin between node2 and node3, fallback to node1 
            if none of node2 and node3 is available.</para>
          <para> 
            <literal>jdbc:sequoia://node1,node2,node3/myDB?preferredController=roundRobin</literal>: 
            Round robin starting with first node in URL.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>retryIntervalInMs</literal>: once a controller has 
            died, the driver will try to reconnect to this controller every 
            retryIntervalInMs to see if the backend is back online. The default 
            is 5000 (5 seconds). </para>
        </listitem>
      </itemizedlist>
    </section>
    </section>
    <!-- ========== Getting a connection using a data source ========== -->
    <section id="getting_a_connection_using_data_source">
      <title>Getting a connection using a data source</title>
      <para>Another way to use the Sequoia driver is to use its 
        <literal>DataSource</literal> implementation. Data sources have been 
        introduced in JDBC 2.0 Standard Extension API and are also a part of 
        JDBC 3.0. They use the Java Naming and Directory Interface (JNDI) to 
        break the application dependence on the JDBC driver configuration 
        (i.e., driver class name, machine name, port number, etc.). With a data 
        source, the only thing an application has to know is the name assigned 
        to the <literal>DataSource</literal> object in the 
        <literal>jdbc</literal> naming subcontext of the JNDI namespace.</para>
      <para>The example below registers a data source object with a JNDI naming 
        service. It is typically used by an application server.</para>
      <programlisting>
      import org.continuent.sequoia.driver.DataSource;
      import javax.naming.Context;
      import javax.naming.InitialContext;
      import javax.naming.NamingException;
      ...
      private final static String NAME = "jdbc/sequoia";
      private final static String URL = "jdbc:sequoia://localhost:25322/mysql";
      
      // Initializing data source
      DataSource ds = new DataSource();
      ds.setUrl(URL);

      // Get initial context
      Context ctx;
      try {
        ctx = new InitialContext();
      } catch (javax.naming.NamingException _e) {
        ... // Naming exception
      }
		
      // Bind data source to a JNDI name
      try {
        ctx.bind(NAME, ds);
      } catch (javax.naming.NamingException _e) {
        ... // Naming exception
      }
      </programlisting>
      <para>The <literal>org.continuent.sequoia.driver.DataSource</literal> class 
        implements the <literal>javax.sql.DataSource</literal> JDBC 3.0 
        interface. The <literal>setUrl</literal> line initializes the data 
        source properties (the URL in this case). The data source object is 
        bound to a logical JNDI name by calling <literal>ctx.bind()</literal>. 
        In the example above, the JNDI name specifies a "jdbc" subcontext and a 
        "sequoia" logical name within this subcontext. </para>
      <para>Once a data source object is registered to JNDI, it can be used by 
        an application. The example below gets the data source using the JNDI 
        naming service. Such a piece of code is typically a part of an 
        application that uses JDBC. </para>
      <programlisting>
      import javax.naming.Context;
      import javax.naming.InitialContext;
      import javax.naming.NamingException;
      import java.sql.Connection;
      import javax.sql.DataSource;
      ...
      private final static String NAME = "jdbc/sequoia";

      // Lookup for the data source object
      try {
        Context ctx = new InitialContext();
        Object obj = ctx.lookup(NAME);
        if (null == obj) {
          ... // Something wrong: NAME not found
        }
        ctx.close( );
      } catch (javax.naming.NamingException _e) {
        ... // Naming exception
      }
      
      // Get a new JDBC connection
      try {
        DataSource ds = (DataSource) obj;
        Connection conn = ds.getConnection("user", "sequoia");
        ... // Use of the connection retrieved
        ...
      } catch (SQLException _e) {
        ... // SQL exception
      }
      </programlisting>
      <para>The <literal>ctx.lookup()</literal> line in the example uses the 
        retrieved initial JNDI naming context to do a lookup using the data 
        source logical name. The method returns a reference to a Java object 
        which is then narrowed to a <literal>javax.sql.DataSource</literal> 
        object. Such an object can be then used to open a new JDBC connection 
        by invoking one of its <literal>getConnection()</literal> methods. The 
        application code is completely independent of the driver details, such 
        as the <literal>Driver</literal> class name, URL, etc. (the user name 
        and password used by the connection can be also set by the application 
        server - look at the Sequoia javadoc documentation for more details). 
        The only information a JDBC application has to know is the logical name 
        of the data source object to use. </para>
      <note>
        <para>The URL used for the Sequoia data source is the same as for the 
          <literal>Driver</literal> described in the previous section.</para>
      </note>
    </section>
    <!-- ========== Stored procedures ========== -->
    <section id="stored_procedures">
      <title>Stored procedures</title>
      <para>Stored procedures are supported by Sequoia since version 1.0b6. Note 
        that Sequoia only support calls in the form <command>{call 
        &lt;procedure-name&gt;[&lt;arg1&gt;,&lt;arg2&gt;, ...]}</command> but 
        does not support <command>{? = call 
        &lt;procedure-name&gt;[&lt;arg1&gt;,&lt;arg2&gt;, 
        ...]}</command>.</para>
      <para>A call to a stored procedure is systematically broadcasted to all 
        backends since there is no way to know if the stored procedure will 
        update the database or not. Therefore, the query cache (see <xref 
        linkend="dtd_requestcache"></xref>), is completely flushed on every 
        stored procedure call. To prevent cache flushing, the user can force 
        the connection to read-only before calling the stored procedure. But 
        never set a connection to read-only when calling a stored procedure 
        that updates the database. If Sequoia detects a read-only connection, it 
        will not flush the cache. However, the call will still be broadcasted 
        to all nodes resulting in duplicated jobs on each backend. Here is an 
        example on how to prevent cache flushing when calling a stored 
        procedure that does only read-only:</para>
      <programlisting> 
        ... 
        CallableStatement cs = connection.prepareCall("{call myproc(?)}"); 
        cs.setString(1,"parameter1");
        // Force no cache flush  
        connection.setReadOny(true); 
        // Call the stored procedure without flushing the cache ... 
        ResultSet rs = cs.executeQuery(); 
      </programlisting>
      <para>In the case of horizontal scalability, only read-only stored procedures are not
        broadcasted. All other stored procedures returning an int or a ResultSet are
        executed by all backends at all controllers.</para>
      <note>
		<para>It is not allowed to set a connection to read-only in the middle 
			of a transaction. If you need to set a connection to read-only, you 
			must do so before starting the transaction.</para>
      </note>
    </section>
    <!-- ========== Blobs ========== -->
    <section id="using_blobs">
      <title>Blobs: Binary Large Objects</title>
      <para>You should not have to change your code for storing blobs into your database.
        Sequoia will transparently encode the blob in the protocol and forward it to your
        database driver.</para>
      <note>
        <itemizedlist>
          <listitem>
            <para>The column type used to store large objects with 
              <literal>MySQL</literal> is <literal>text</literal>.</para>
          </listitem>
          <listitem>
            <para>The column type used to store large objects with 
              <literal>PostgreSQL</literal> is <literal>bytea</literal>.</para>
          </listitem>
        </itemizedlist>
      </note>
      <para>Please refer to the following lines of code for storing and 
        retrieving of large objects:</para>
      <programlisting>
        // In the code below:
        // The signature of the readBinary method is:
        // byte[] readBinary(File file) throws IOException
        // it just read a file, and convert its content into an array of bytes
        
        // Store file in database 
        File fis = new File(storeFile); 
        query = "insert into ... values(...,?)"; 
        ps1 = con.prepareStatement(query); 
        if (callBlobMethods) 
        {
          org.continuent.sequoia.common.protocol.ByteArrayBlob bob = 
            new org.continuent.sequoia.common.protocol.ByteArrayBlob(readBinary(fis)); 
          ps1.setBlob(1, bob); 
        } 
        else 
        { 
          ps1.setBytes(1, readBinary(fis)); 
        } 
        ps1.executeUpdate();
        // Read File from database 
        query = "select * from ... where id=..."; 
        ps1 = con.prepareStatement(query); 
        ResultSet rs = ps1.executeQuery(); 
        rs.first(); 
        byte[] lisette; 
        if (callBlobMethods) 
        { 
          Blob blisette = rs.getBlob("blobcolumnname"); 
          lisette = blisette.getBytes((long) 1, (int) blisette.length());
        }
        else 
        {
          lisette = rs.getBytes("blobcolumnname"); 
        } 
      </programlisting>
    </section>
    <!-- ========== Clobs ========== -->
    <section id="using_clobs">
      <title>Clobs: Character Large Objects</title>
      <para> CLOB is a built-in type that stores a Character Large Object as a 
        column value in a row of a database table. By default drivers implement 
        Clob using an SQL locator (CLOB), which means that a Clob object 
        contains a logical pointer to the SQL CLOB data rather than the data 
        itself. A Clob object is valid for the duration of the transaction in 
        which it was created. </para>
      <para> Clobs in Sequoia are handled like strings. You can refer to the 
        section of code below to make good usage of clobs. This code is part of 
        the Sequoia test suite. </para>
      <programlisting> 
        String clob = "I am a clob"; 
        ps = con.prepareStatement("insert into ... values(...,?)"); 
        ps.setString(1, clob); 
        ps.executeUpdate(); 
        
        // Test retrieval 
        String ret; 
        ps = con.prepareStatement("Select * from ... where id=..."); 
        rs = ps.executeQuery(); 
        rs.first(); 
        clob = rs.getClob("name"); 
        ret = clob.getSubString((long) 0, (int) clob.length()); 
      </programlisting>
    </section>
    <!-- ========== ResultSet streaming ========== -->
    <section id="resultset_streaming">
      <title>ResultSet streaming</title>
      <para>In its default mode, when a query is executed on a backend, Sequoia 
        makes a copy of the backend's native ResultSet into a Sequoia 
        serializable ResultSet. If the result contains many rows or very large 
        objects, the controller might run out of memory when trying to copy the 
        whole ResultSet.</para>
      <para>It is possible to fetch ResultSets by blocks using the
        Statement.setFetchSize(int rows) method. In this case, the ResultSet will be
        copied by block of rows and returned when needed by the client. Note that the current
        implementation only allows to fetch forward streamable ResultSet, which basically
        means that you are only allowed to call ResultSet.next() on a streamable
        ResultSet.</para>
      <para>Sequoia will try to call setFetchSize() on the backend's driver to 
        let the backend driver also perform the necessary optimizations. 
        However, some driver requires a prior call to setCursorName() in which 
        case you will also have to call setCursorName() on Sequoia to pass it to 
        the backend's driver.</para>
      <para>A typical usage of the ResultSet streaming feature is as 
        follows:</para>
      <programlisting>
...        
Connection con = getSEQUOIAConnection();
con.setAutocommit(false);
Statement s = con.createStatement();
s.setCursorName("cursor name");
s.setFetchSize(10);
rs = s.executeQuery(sql);
while (rs.next())
{ // Every 10 calls, Sequoia will transfer a new block of rows
  XXX o = rs.getXXX("some column name");
}
...
con.commit();
      </programlisting>
      <note>
        <para>Streamable ResultSets are not cacheable. The result cache 
          automatically detects this kind of ResultSet and does not keep them 
          in the cache. However, as database specific ResultSets are copied 
          into Sequoia ResultSets, the memory footprint of the fetched blocks 
          will be twice the one obtained without Sequoia. If you have memory 
          restrictions, you can reduce your fetch size by half to reduce the 
          memory footprint of streamed ResultSets.</para>
        <para>Streamable ResultSets do not work properly in autocommit mode as 
            the connection used for retrieving the ResultSet is handed back to 
            the pool. The workaround is to always encapsulate the query in a 
            transaction. Note that databases such as PostgreSQL do not support 
            streamable ResultSets in autocommit mode as well.</para>
      </note>
    </section>
    <!-- ========== Current Limitations ========== -->
    <section id="current_driver_limitations">
      <title>Current Limitations</title>
      <para>The Sequoia driver currently does not support the following features:</para>
      <itemizedlist>
        <listitem>
          <para>java.sql.Array and java.sql.Ref types,</para>
        </listitem>
        <listitem>
          <para>Custom type mapping using
            java.sql.Connection.setTypeMap(java.util.Map map),</para>
        </listitem>
        <listitem>
          <para><literal>XAConnections</literal> (look at the <ulink
              url="http://xapool.experlog.com">XAPool project</ulink> for XA support
            with Sequoia),</para>
        </listitem>
        <listitem>
          <para>Streamable ResultSets do not work in autocommit mode.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  
  <section id="configuring-sequoia_with_3rd_party_software">
    <title>Configuring Sequoia with 3rd party software</title>  
    <!-- ========== Forenotes ========== -->	
	<section id="forenotes">
		<title>Forenotes on configuring Sequoia with your application</title>
    <para>If the application you are using Sequoia with requires a mapper, the best thing to do
      is to configure the mapping to be that of Sequoia's underlying databases. For example, if
      you were using JBoss with PostgreSQL , then using Sequoia on top of the PostgreSQL
      backends with JBoss would imply to still use the mapping for PostgreSQL while plugging
      the application server to Sequoia (using Sequoia's driver and Sequoia's url). </para>
	</section>
	
    <!-- ========== Configuring with Tomcat ========== -->
    <section id="configuring_sequoia_with_tomcat">
      <title>Configuring Sequoia with Jakarta Tomcat</title>
      <para>Copy the <filename>sequoia-driver.jar</filename> file to the 
        <filename class="directory">lib</filename> directory of your web 
        application (for example: <filename 
        class="directory">$TOMCAT_HOME/webapps/mywebapp/WEB-INF/lib</filename>).</para>
      <para>There are many ways to obtain connections from a Tomcat 
        application. Just ensure that you are using 
        <literal>org.continuent.sequoia.driver.Driver</literal> as the driver 
        class name and that the JDBC URL is a Sequoia URL (see <xref 
        linkend="sequoia_jdbc_url"/>).</para>
    </section>
    <!-- ========== Configuring Sequoia with JOnAS ========== -->
    <section id="configuring_sequoia_with_jonas">
      <title>Configuring Sequoia with JOnAS</title>
      <para>The <filename>sequoia-driver.jar</filename> file must be found in 
        the JOnAS CLASSPATH.</para>
      <para>Here is an example of a <filename>sequoia.properties</filename> file 
        to store in JONAS 3.x <filename class="directory">conf</filename> 
        directory (use the <filename class="directory">config</filename> 
        directory for JOnAS 2.x):</para>
      <programlisting> 
        ###################### Sequoia DataSource configuration example # 
        datasource.name      jdbc_1 
        datasource.url       jdbc:sequoia://someMachine/someDatabase 
        datasource.classname org.continuent.sequoia.driver.Driver 
        datasource.username  your-username 
        datasource.password  your-password 
      </programlisting>
    </section>
    <!-- ========== Configuring Sequoia with JBoss ========== -->
    <section id="configuring_sequoia_with_jboss">
      <title>Configuring Sequoia with JBoss</title>
      <para>Copy the <filename>sequoia-driver.jar</filename> file to <filename 
        class="directory">$JBOSS_DIST/server/default/lib</filename> for JBoss 
        3.x or to <filename 
        class="directory">$JBOSS_DIST/jboss/lib/ext</filename> for JBoss 
        2.x.</para>
      <para>Here is an example of a datasource configuration file to be used 
        with JBoss:</para>
      <programlisting> 
        &lt;?xml version="1.0" encoding="UTF-8"?> 
        &lt;!-- ===================================================================== --> 
        &lt;!--                                                                       --> 
        &lt;!-- JBoss Server Configuration                                            -->
        &lt;!--                                                                       --> 
        &lt;!-- ===================================================================== --> 

        &lt;!-- ===================================================================== --> 
        &lt;!-- Datasource config for Sequoia                                          -->
        &lt;!-- ===================================================================== --> 
        &lt;datasources> 
          &lt;local-tx-datasource> 
            &lt;jndi-name>sequoia-DS&lt;/jndi-name> 
            &lt;connection-url>jdbc:sequoia://localhost:25322/lscluster&lt;/connection-url> 
            &lt;driver-class>org.continuent.sequoia.driver.Driver&lt;/driver-class> 
            &lt;user-name>user&lt;/user-name> 
            &lt;password>tagada&lt;/password> 
          &lt;/local-tx-datasource> 
        &lt;/datasources> 
      </programlisting>
    </section>
    <!-- ========== Configuring Sequoia with BEA Weblogic Server 7.x/8.x ========== -->
    <section id="configuring_sequoia_with_weblogic">
      <title>Configuring Sequoia with BEA Weblogic Server 7.x/8.x</title>
      <para>Place the <filename>sequoia-driver.jar</filename> file in the 
        classpath of the Weblogic Server.</para>
      <para>Here is an example of a connection pool configuration for use with 
        Weblogic:</para>
      <programlisting>
    &lt;JDBCConnectionPool 
        DriverName="org.continuent.sequoia.driver.Driver"
        InitialCapacity="1"  MaxCapacity="15" 
        Name="sequoiaPool" Properties="user=username;password=password" 
        ShrinkingEnabled="true" SupportsLocalTransaction="true" 
        Targets="wlservername" URL="jdbc:sequoia://192.168.0.1/vdb" 
        XAPreparedStatementCacheSize="0"/>
      </programlisting>

      <para>Next, create the required <literal>TXDataSources</literal>:</para>

      <programlisting>
        &lt;JDBCTxDataSource EnableTwoPhaseCommit="true" 
          JNDIName="sequoia-DS" Name="Sequoia TX Data Source" 
          PoolName="sequoiaPool" RowPrefetchEnabled="true" Targets="wlservername"/>
      </programlisting>
    </section>
    <!-- ========== Configuring Sequoia with Hibernate ========== -->
    <section id="configuring_sequoia_with_hibernate">
      <title>Configuring Sequoia with Hibernate</title>
      <para>Sequoia just has to be defined as any JDBC driver in Hibernate, 
        leaving the syntax set to the proper database. Here is a configuration 
        example to use Hibernate with a Sequoia cluster made of Sybase 
        backends:</para>
      <programlisting>
## Sequoia
hibernate.dialect                 net.sf.hibernate.dialect.SybaseDialect
hibernate.connection.driver_class org.continuent.sequoia.driver.Driver
hibernate.connection.username     user
hibernate.connection.password     pass
hibernate.connection.url          jdbc:sequoia://localhost:25322/test        
      </programlisting>
    </section>
    
    <section id="using_sequence_with_hibernate">
      <title>Using sequences with Hibernate, Sequoia and PostgreSQL</title>
      <para>Our Hibernate dialect is as follows:</para>
      <programlisting> 
        import net.sf.hibernate.dialect.PostgreSQLDialect; 
        public class SEQUOIAPostgreSQLDialect extends PostgreSQLDialect 
        { 
          public String getSequenceNextValString(String sequenceName) 
          { 
            return "{call nextval('"+sequenceName+"')}"; 
          } 
        } 
      </programlisting>
      <para> We simply extend the default PostgreSQL Dialect and override the 
        getSequenceNextValString() method and tell it to use "{call ..." so 
        that all the sequences in the cluster get incremented. </para>
      <para> We then changed our Hibernate conf file to user to our custom 
        dialect instead of net.sf.hibernate.dialect.PostgreSQLDialect. </para>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Sequoia Controller -->
  <!-- =============================================================== -->
  <section id="sequoia_controller">
    <title>Sequoia controller</title>
    <!-- ========== Design Overview ========== -->
    <section id="design_overview">
      <title>Design Overview</title>
      <para>The Sequoia controller is made of several components as shown in 
        <xref linkend="fig_controller_overview"/>. The controller hosts 
        <emphasis>virtual databases</emphasis>. A <emphasis>virtual 
        database</emphasis> gives the illusion of a single database to the 
        user. It exports the same database name and login/password as those 
        used in the client application. Therefore the client application can 
        run unmodified with Sequoia.</para>
      <para>When the client application connects to the database using an URL 
        like <literal>jdbc:sequoia://host:25322/myDB</literal>, the Sequoia driver 
        tries to connect to a Sequoia controller running on port 
        <literal>25322</literal> on node <literal>host</literal>. Once the 
        connection is established the login and password are sent with the 
        <literal>myDB</literal> database name to be checked by the 
        controller.</para>
        
      <para>A virtual database contains the following components:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis>authentication manager</emphasis>: it matches the 
            virtual database login/password (provided by the application to the 
            Sequoia driver) with the real login/password to use on each backend. 
            The authentication manager is only involved at connection 
            establishment time.</para>
        </listitem>
        <listitem>
          <para><emphasis>backup manager</emphasis>: manages a list of generic or
            database specific Backupers that are in charge of performing database dump and
            restore operation. Backupers should also take care of transferring dumps from
            one controller to another.</para>
        </listitem>
        <listitem>
          <para><emphasis>request manager</emphasis>: it handles the requests 
            coming from a connection with a Sequoia driver. It is composed of 
            several components:</para>
          <itemizedlist>
            <listitem>
              <para><emphasis>scheduler</emphasis>: it is responsible for 
                scheduling the requests. Each RAIDb level has its own 
                scheduler.</para>
            </listitem>
            <listitem>
              <para><emphasis>request caches</emphasis>: these are optional 
                components that can cache query parsing, the result set and 
                result metadata of queries.</para>
            </listitem>
            <listitem>
              <para><emphasis>load balancer</emphasis>: it balances the load on 
                the underlying backends according to the chosen RAIDb level 
                configuration.</para>
            </listitem>
            <listitem>
              <para><emphasis>recovery log</emphasis>: it handles checkpoints 
                and allows backends to dynamically recover from a failure or to 
                be dynamically added to a running cluster.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><emphasis>database backend</emphasis>: it represents the real 
            database backend running the RDBMS engine. A <emphasis>connection 
            manager</emphasis> mainly provides connection pooling on top of the 
            database JDBC native driver.</para>
        </listitem>
      </itemizedlist>
      <figure id="fig_controller_overview">
        <title>Sequoia controller design overview</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/sequoia_controller.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata align="center" fileref="images/sequoia_controller.gif" 
              format="GIF" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Each virtual database and its components are configured using an 
        XML configuration file that is sent from the administration console to 
        the Sequoia controller.
      </para>
      <note><para>A <ulink url="http://c-jdbc.objectweb.org/current/doc/RR-C-JDBC.pdf">
        research report details RAIDb and C-JDBC implementation</ulink>. Other
        documents and presentations about C-JDBC can be found in the 
        <ulink url="http://c-jdbc.objectweb.org/doc">documentation section of 
          the web site</ulink>.
        </para></note>
    </section>
    <!-- ========== Starting the Controller ========== -->
    <section id="starting_controller">
      <title>Starting the Controller</title>
      <para>The <filename class="directory">bin</filename> directory of the 
        Sequoia distribution contains the scripts to start the controller. Unix 
        users must start the controller with <command>controller.sh</command> 
        whereas Windows users will use <command>controller.bat</command>. 
        </para>
      <para>Sequoia Controller startup is tuned via a configuration file, called
        <filename>controller.xml</filename>, included under the <filename
          class="directory">config/controller</filename> directory of your Sequoia
        installation. A simple configuration file looks like this:</para>
      <para>A standard Sequoia Controller configuration file looks like this:</para>
      <programlisting>
&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
&lt;!DOCTYPE SEQUOIA-CONTROLLER PUBLIC "-//Continuent//DTD SEQUOIA-CONTROLLER @VERSION@//EN"  "http://sequoia.continuent.org/dtds/sequoia-controller-@VERSION@.dtd">
&lt;SEQUOIA-CONTROLLER>
	&lt;Controller port="25322">
    &lt;Report hideSensitiveData="true" generateOnFatal="true"/>
    &lt;JmxSettings>
      &lt;RmiJmxAdaptor/>
    &lt;/JmxSettings>
  &lt;/Controller>
&lt;/SEQUOIA-CONTROLLER>
      </programlisting>
      <para>You can specify at startup a different file than 
        <filename>config/controller/controller.xml</filename>. This is useful if you have 
        to startup many identical controllers from the network. You can then 
        use the command <command>controller.sh -f filename</command> on Unix 
        machines or <command>controller.bat -f filename</command> on 
        windows.</para>
        <para>For more information you can refer to the 
          controller-configuration.xml example in the example directory of 
          sequoia.</para>
      <!-- TODO: Command line options of the controller. -->
     <para>Next section describes how to write a controller configuration file.
     </para>
    </section>

    <!-- ========== Configuring the controller ========== -->
    <section id="writing_the_controller_config_file">
    <title>Writing the controller configuration file</title>
    <para>The controller is entirely configurable via an xml file, by default 
      it is <filename>controller.xml</filename> located in the <filename 
      class="directory">config/controller</filename> of the Sequoia installation. This 
      section details how to write such a file. </para>
    
    <section id="dtd_controller_parameters">
    <title>Controller Parameters</title>
    <para>The root element of the controller configuration is defined as follows
    </para>
    <programlisting>
&lt;!ELEMENT Controller (Internationalization?, Report?, JmxSettings?, 
                                    VirtualDatabase*, SecuritySettings?)&gt;
&lt;!ATTLIST Controller
  port             CDATA "25322"
  ipAddress        CDATA "127.0.0.1"
  backlogSize      CDATA "10"
>
    </programlisting>
    <para>All sub-elements of Controller are defined in the next sections. Here
      is a brief overview of each of them:</para>
    <itemizedlist>
      <listitem>
      	<para><literal>Internationalization</literal>: defines the language
      	  setting for Sequoia console and error messages.</para>
      </listitem>
      <listitem>
        <para><literal>Report</literal>: if this option is enabled, Sequoia can
          automatically generate a report on fatal errors or shutdown. If you
          experience any problem with Sequoia, you can directly send the report
          on the mailing list to get a quick diagnostic of what happened.</para>
      </listitem>
      <listitem>
        <para><literal>JmxSettings</literal>: JMX is the technology used for 
          management and monitoring in Sequoia. These functionalities can be 
          accessed through HTTP with an Internet browser or through the RMI 
          connector used by the Sequoia console.</para>
      </listitem>
      <listitem>
        <para><literal>VirtualDatabase</literal>: Defines a virtual database to 
          load automatically at controller startup given a reference to its 
          configuration file.</para>
      </listitem>
      <listitem>
        <para><literal>SecuritySettings</literal>: Allows to filter accesses to 
          a controller based on access lists.</para>
      </listitem>
    </itemizedlist>
    
    <para>The attributes of a Controller element are defined as follows:</para>
    <itemizedlist>
      <listitem>
        <para><literal>port</literal>: the port number on which clients (Sequoia 
          drivers) will connect. The default port number is 
          <emphasis>25322</emphasis>.</para>
        <note>
          <para>A port number below 1024 will require running the controller 
            with privileged rights (root user under Unix).</para>
        </note>
      </listitem>
      <listitem>
        <para><literal>ipAddress</literal>: This can be defined to bind a 
          specific IP address in case of a host with multiple IP addresses. 
          This can be ignored if there is only one IP address available and 
          will be replaced by <literal>127.0.0.1</literal>.</para>
      </listitem>
      <listitem>
        <para><literal>backlogSize</literal>: the server socket backlog size 
          (number of connections that can wait in the accept queue before the 
          system returns "connection refused" to the client). Default is 10. 
          Tune this value according to your operating system, but the default 
          value should be fine for most settings.</para>
      </listitem>
    </itemizedlist>
    <para>If your machine has multiple network adapters, you can for the
        Sequoia Controller to bind a specific IP address like this:</para>
    <programlisting>
&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
&lt;!DOCTYPE SEQUOIA-CONTROLLER PUBLIC "-//Continuent//DTD SEQUOIA-CONTROLLER @VERSION@//EN"  "http://sequoia.continuent.org/dtds/sequoia-controller-@VERSION@.dtd">
&lt;SEQUOIA-CONTROLLER>
	&lt;Controller port="25322" ipAddress="192.168.0.1">
		&lt;JmxSettings enabled="false"/>
	&lt;/Controller>
&lt;/SEQUOIA-CONTROLLER>
    </programlisting>
    </section>
    
    <!-- ========== Internationalization ========== -->
    <section id="dtd_controller_internationalization">
    <title>Internationalization</title>
    <para>You can use this element to override the default locale retrieved by 
      java. English is the only language looked at at the moment.</para>
    <programlisting>
    &lt;!ELEMENT Internationalization EMPTY>
    &lt;!ATTLIST Internationalization language (en|fr|it|jp) "en"&gt;
    </programlisting>
    </section>
    
    <!-- ========== Report ========== -->
    <section id="dtd_controller_report">
    <title>Report</title>
    <para>A report can be define in case you want to get a trace of what 
      happened during the execution of the controller. If this element is 
      included in the <filename>controller.xml</filename> report is enabled and 
      will output a report, under certain conditions, in a file named 
      <filename>sequoia.report</filename>.</para>
    <programlisting>
&lt;!ELEMENT Report EMPTY>
&lt;!ATTLIST Report
     hideSensitiveData  (true|false) "true"
     generateOnShutdown (true|false) "true"
     generateOnFatal    (true|false) "true"
     enableFileLogging  (true|false) "true"
     reportLocation     CDATA        #IMPLIED
>
    </programlisting>
    <itemizedlist>
      <listitem>
        <para><literal>hideSensitiveData</literal>: will replace passwords with 
          '*****'.</para>
      </listitem>
      <listitem>
        <para><literal>generateOnShutdown</literal>: tells the controller to 
          generate a report when it has received a shutdown command.</para>
      </listitem>
      <listitem>
        <para><literal>generateOnFatal</literal>: tells the controller to 
          generate a report when it cannot recover from an error. </para>
      </listitem>
      <listitem>
        <para><literal>enableFileLogging</literal>: logs all the console output 
          into a file and include this file into the report.</para>
      </listitem>
      <listitem>
        <para><literal>reportLocation</literal>: specify the path where to 
          create the report, default is
	  <filename class="directory"><literal>SEQUOIA_HOME</literal>/log</filename> directory.</para>
      </listitem>
    </itemizedlist>
    </section>
    
    <!-- ========== Configuring JMX ========== -->
    <section id="dtd_controller_jmx">
    <title>JMX</title>
    <para>JMX is used to remotely administrate the controller. You can use the 
      bundled Sequoia console or use your own code to access JMX MBeans via the 
      protocol adaptor. Sequoia proposes both the RMI and HTTP adaptors of the 
      <ulink url="http://mx4j.sourceforge.net/">MX4J</ulink> JMX server. You 
      can override the default port numbers for each adaptor if they conflict 
      with another application that is already using them (i.e. another Sequoia 
      controller on the same machine).</para>
    <programlisting>
    &lt;!ELEMENT JmxSettings (HttpJmxAdaptor?, RmiJmxAdaptor?)&gt;
    &lt;!ELEMENT HttpJmxAdaptor EMPTY>
    &lt;!ATTLIST HttpJmxAdaptor
      port CDATA "8090"
    &gt;

     &lt;!ELEMENT RmiJmxAdaptor (SSL?)&gt;
     &lt;!ATTLIST RmiJmxAdaptor
       port         CDATA        "1090"
       username     CDATA        #IMPLIED
       password     CDATA        #IMPLIED
     &gt;


     &lt;!ELEMENT SSL EMPTY&gt;
     &lt;!ATTLIST SSL
       keyStore			CDATA        #REQUIRED
       keyStorePassword		CDATA        #REQUIRED
       keyStoreKeyPassword	CDATA        #IMPLIED
       isClientAuthNeeded	(true|false) "false"
       trustStore		CDATA        #IMPLIED
       trustStorePassword	CDATA        #IMPLIED
     &gt;
     </programlisting>
     

     <para>Configure ssl for encryption and/or authentication.</para>
      <itemizedlist>
        <listitem>
          <para><literal>keyStore</literal>: The file where the keys are stored
          </para>
        </listitem>
        <listitem>
          <para><literal>keyStorePassword</literal>: the password to the keyStore
          </para>
        </listitem>
        <listitem>
          <para><literal>keyStoreKeyPassword</literal>: the password to the key, if none is specified the same password as for the store is used
          </para>
        </listitem>
        <listitem>
          <para><literal>isClientAuthNeeded</literal>: if set to false ssl is used for encryption, the server is only accepting trusted clients (the client certificate has to be in the trusted store)
          </para>
        </listitem>
        <listitem>
          <para><literal>trustStore</literal>: the file where the trusted certificates are stored, if none is specified the same store as for the key is used
          </para>
        </listitem>
        <listitem>
          <para><literal>trustStorePassword</literal>: the password to the trustStore, if none is specified the same password as for the keyStore is used</para>
        </listitem>
      </itemizedlist>


      <para>You have to enable the RMI adaptor if you want to use the Sequoia 
        console to administrate the controller remotely. To enable the RMI JMX 
        adaptor, use this setting:</para>
     <programlisting>
     &lt;JmxSettings&gt;
     	 &lt;RmiJmxAdaptor/&gt;
		 &lt;/JmxSettings&gt;
     </programlisting>
     </section>
     
     <section id="dtd_controller_database">
     <title>Virtual Database</title>
      <para>This element specifies virtual databases to load at controller 
        startup.</para>
      <programlisting>
&lt;!ELEMENT VirtualDatabase EMPTY&gt;
&lt;!ATTLIST VirtualDatabase 
    configFile          CDATA #REQUIRED
    virtualDatabaseName CDATA #REQUIRED
    autoEnableBackends  (true | false | force) "true"
    checkpointName      CDATA ""
&gt;
      </programlisting>
      <itemizedlist>
        <listitem>
          <para><literal>configFile</literal>: The path to the virtual database 
            configuration file. See <xref linkend="configuration"></xref> to 
            learn how to write a virtual database configuration file.</para>
        </listitem>
        <listitem>
          <para><literal>virtualDatabaseName</literal>: The name of the virtual 
            database since the configuration file can contain multiple virtual 
            database definitions.</para>
        </listitem>
        <listitem>
          <para><literal>autoEnableBackends</literal>: set to true by default 
            to reenable backends from their last known state as stored during 
            last shutdown. If backends where not properly shutdown, nothing 
            will happen. You can specify false to let the backends in disabled 
            state at startup. The force option should only be used if you know 
            exactly what you are doing and override backend status by providing 
            a new checkpoint. <emphasis>Warning!</emphasis> Use this setting 
            carefully as it might break your database consistency if you do not 
            provide a valid checkpoint.Force is considered the same as true if 
            no recovery log has been defined.</para>
        </listitem>
        <listitem>
          <para><literal>checkpointName</literal>: the checkpoint name to use with 
            the recovery log to enable backend from a known coherent state. If 
            the checkpoint is omitted, the last known checkpoint is used.</para>
        </listitem>
      </itemizedlist>
            
      <para>Example:</para>
      <programlisting>
&lt;VirtualDatabase configFile="/databases/MySQLDb.xml" virtualDatabaseName="rubis" autoEnableBackends="true"/&gt;
      </programlisting>
      <para>This will enable a virtual database named <literal>rubis</literal> 
        taken from a configuration file named 
        <filename>/databases/MySQLDb.xml</filename> and will enable all 
        backends of the database from the last known checkpoint.</para>
      </section>
      
      <section id="dtd_controller_security">
      <title>Security</title>
      <para>Security settings define the policy to adopt for some 
        functionalities that may compromise the security of the controller. 
        These settings depends on your environment and can be relaxed if you 
        are running in a secure network. The less security settings you have, 
        the faster the controller will run. A SecuritySettings element is 
        defined as follows:</para>
      <programlisting>
      &lt;!ELEMENT SecuritySettings (Jar?, Accept?, Block?, SSL?)&gt;
      &lt;!ATTLIST SecuritySettings
        defaultConnect (true|false) "true"
      &gt;
      </programlisting>
      <para><literal>defaultConnect</literal>: is used to allow (true) or 
        refuse (false) connections to the controller. This default setting can 
        be then be tuned with access lists defined in <literal>Accept</literal> 
        and <literal>Block</literal> elements (see below).</para>
        
      <para>Additional database drivers can be uploaded dynamically to the 
        controller. As the controller has no way to check if this is a real 
        JDBC driver or some malicious code hidden a JDBC driver interface, you 
        have to be very careful if you enable this option and anybody can 
        connect from anywhere to your controller.</para>
      <programlisting>
&lt;!ELEMENT Jar EMPTY&gt;
&lt;!ATTLIST Jar
	allowAdditionalDriver (true|false) "true"
&gt;
      </programlisting>

      <para>You can control who can connect to the controller by setting access 
        lists based on IP addresses to accept or block. 
        <literal>defaultConnect</literal> is set in 
        <literal>SecuritySettings</literal> defined above. Default is to accept 
        all connections if no security manager is enabled.</para>
      <programlisting>
&lt;!ELEMENT Accept (Hostname|IpAddress|IpRange)*&gt;
&lt;!ELEMENT Block (Hostname|IpAddress|IpRange)*&gt;

&lt;!ELEMENT Hostname EMPTY&gt;
&lt;!ATTLIST Hostname 
     value CDATA #REQUIRED
&gt;
      </programlisting>

      <para>IpAddress value is an IPv4 address (ex:192.168.1.12):</para>
      <programlisting>
&lt;!ELEMENT IpAddress EMPTY&gt;
&lt;!ATTLIST IpAddress  
     value CDATA #REQUIRED
&gt;
      </programlisting>

      <para>IpRange value is based on IPv4 addresses and has the following 
        form: 192.168.1.*.</para>
      <programlisting>
&lt;!ELEMENT IpRange EMPTY&gt;
&lt;!ATTLIST IpRange  
     value CDATA #REQUIRED
&gt;
      </programlisting>
      
      <para>Here is a full security configuration example:</para>
      <programlisting>
&lt;SecuritySettings defaultConnect="false"&gt;
  &lt;Jar allowAdditionalDriver="true"/&gt;
  &lt;Shutdown&gt;
    &lt;Client allow="true" onlyLocalhost="true"/&gt;
    &lt;Console allow="false"/&gt;
  &lt;/Shutdown&gt;
  &lt;Accept&gt;
    &lt;IpRange value="192.168.*.*"/&gt;
  &lt;/Accept&gt;
&lt;/SecuritySettings&gt;
      </programlisting>
      <para>This setting accepts driver connections only from machines having 
        an IP address starting with 192.168, allows loading of additional 
        drivers via the console, refuses shutdown from the console, but allows 
        it from the local machine.</para>
     </section>
   </section> <!-- End of writing controller configuration section -->
    
    <!-- ========== Configuring the Log ========== -->
    <section id="configuring_the_log">
      <title>Configuring the Log</title>
      <para>Sequoia uses the <ulink 
        url="http://jakarta.apache.org/log4j/">Log4j</ulink> logging framework. 
        The <filename>log4j.properties</filename> configuration file is located 
        in the <filename class="directory">/sequoia/config</filename> directory 
        of your installation. Here is a brief description of the loggers 
        available in the configuration file:</para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.core.controller</literal>
            : Controller related activities mainly for bootstrap and virtual database
            adding/removal operations.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.xml.Handler</literal>
            : XML configuration file parsing and handling.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.VirtualDatabase</literal>
            : Virtual database related operations. A specific
            <literal>log4j.logger.org.continuent.sequoia.controller.VirtualDatabase.virtualDatabaseName</literal>
            logger is automatically created for each virtual database. This allows to tune
            different logging levels for each virtual database.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.VirtualDatabase.request</literal>
            : Log the incoming requests and transactions in files that can be replayed by the
            Request Player tool provided with Sequoia.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.distributedvirtualdatabase.request</literal>
            : Log distributed request execution when using horizontal scalability (a.k.a.
            controller replication).</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.backup</literal>
            : Log backup manager and backuper related activities from dump/restore
            operations.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.VirtualDatabaseServerThread</literal>
            : The server thread accepts client connections and manages the worker
            threads.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.VirtualDatabaseWorkerThread</literal>
            : Each worker thread handle a session with a client Sequoia driver.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.RequestManager</literal>
            : Log the request flows between the different Request Manager components
            (scheduler, cache, load balancer, recovery log).</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.scheduler</literal>
            : Log the request ordering and synchronization performed by the
            scheduler.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.cache</literal>
            : SQL Query cache related activities.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.loadbalancer</literal>
            : Log how requests are balanced on the backends.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.connection</literal>
            : Connection pooling related information.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.recoverylog</literal>
            : Sequoia Recovery Log information.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.continuent.sequoia.controller.console.jmx</literal>
            : JMX management system logging.</para>
        </listitem>
        <listitem>
          <para><literal>log4j.logger.org.continuent.hedera.channels</literal>:
            Hedera low level group communication channel.</para>
        </listitem>
        <listitem>
          <para><literal>log4j.logger.org.continuent.hedera.gms</literal>: Hedera
            Group Membership Service (GMS).</para>
        </listitem>
        <listitem>
          <para><literal>log4j.logger.org.continuent.tribe.discovery</literal>:
            Tribe Discovery Service (used by GMS).</para>
        </listitem>
        <listitem>
          <para> <literal>log4j.logger.org.continuent.hedera.adapters</literal>:
            Hedera Multicast Dispatcher building block for application level message
            handling.</para>
        </listitem>
        <listitem>
          <para><literal>log4j.logger.org.jgroups</literal>: JGroups core messages
            when Hedera is used with JGroups.</para>
        </listitem>
        <listitem>
          <para><literal>log4j.logger.org.jgroups.protocols</literal>: JGroups
            protocol stack messages when Hedera is used with JGroups.</para>
        </listitem>
      </itemizedlist>
    </section>
    <!-- ========== Recovery Log ========== -->
    <section id="recovery_log">
      <title>Recovery Log</title>
      <para>When you want to add a database to your cluster, you do not want to stop the system,
        replicate the current database state to the new database (that may take a long while)
        and then restart the system. The Recovery Log helps you in the process of dynamically
        adding a new backend (or recovering a previously failed backend) without stopping
        the system.</para>
      <para>The Recovery Log records the write operations and transactions that are
        performed by the Sequoia controller between checkpoints. A checkpoint is just a
        logical index in the log that reflect the recovery log state at a given time. As of
        Sequoia 2.0, checkpoints are automatically managed by the controller and are
        generated when needed on behalf of the administrator when a backend is disabled or
        enter a backup phase. When re-enabling the backend, the Recovery Log replays all
        write queries and transactions that the backend missed during the time it was offline
        and it comes back to the enabled state once it is synchronized with the other
        nodes.</para>
      <para>Since version 2.0, the backup infrastructure has completely changed and is
        based on Backupers. We provide a generic Backuper based on <ulink
          url="http://octopus.enhydra.org/">Enhydra Octopus</ulink> to copy, backup
        and restore content of backends through JDBC. Even if Octopus is supposed to handle
        most common databases, it might fail for some specific databases or data types. In
        that case, we strongly recommend to use or implement a database specific
        Backuper.</para> <note>
      <para>Octopus currently fails to backup/restore empty databases. You need at least to
        have one table in your database if you don't want the backup operation to fail with
        Octopus.</para> </note>
      <section>
        <title>A practical example</title>
        <para>Your Web site is running with a single database and you want to use Sequoia with
          three nodes using full replication (RAIDb-1). You have two new backends ready to be
          installed. You can start the Sequoia console and connect to the controller. Start
          the administration module by connecting to the virtual database. Type:
          <command>backup
          &lt;backend name&gt; &lt;dump name&gt; &lt;backuper name&gt; &lt;path to
          backup directory&gt;</command>. If you want to use Octopus you will use a command
          line like <command>backup node1 dump1 Octopus /var/backups</command>. During
          the backup, the update requests are logged in the recovery log, so no update is lost.
          If the backend was in the enabled state when backup was initiated, it will
          automatically replay the recovery log to resynchronize itself and return to the
          enabled state.</para>
        <para>To restore the dump on another backend, just type <command>restore
          &lt;newbackend&gt;
          &lt;dumpname&gt;</command> and the appropriate backuper (Octopus in our
          previous example) will be used to restore the dump. After restoring the dump, you
          can enable the backend at any time so that the recovery log replays all the missing
          requests since the dump was taken.</para>
        <para>Here is the set of commands to use in the Sequoia console if node1 is your
          existing backend and you want to dynamically add node2 and node3:</para>
        
        
        <programlisting>
backup node1 initial_dump Octopus /var/backups
restore node2 initial_dump
restore node3 initial_dump
enable node2
enable node3
        </programlisting>
        <note>
        <para>Note that these steps can be automated by scripting the console.</para>
        </note>
        <para>If a node crashes, use the administration console to restore the dump on the
          node using the restore command. Once the dump is restored, re-enable the backend
          from the stored checkpoint and the Recovery Log will automatically replay all the
          write queries to rebuild a consistent database state on the node.</para>
        <para>To prevent the recovery log from being too large, you can periodically perform
          backup operations. This will also lower the recovery time since the part of the log
          to replay will be smaller. You can delete older dumps and logs if you do not need them
          anymore.</para>
      </section>
      <section id="understanding_checkpoints">
        <title>Understanding checkpoints</title>
        <para>A checkpoint is a reference used by the recovery log to replay missing
          requests. If a backend is disabled from the console for maintenance, the
          controller will automatically create a checkpoint (in C-JDBC, the checkpoint
          name had to be provided manually through the console). Once the backend is enabled
          again, the controller retrieves its last known checkpoint from the recovery log
          and replays all the requests that the disabled backend missed since it was
          disabled. A checkpoint is nothing more than a reference in time. </para>
      </section>
      <section>
        <title>A fault tolerant Recovery Log</title>
        <para>As the Sequoia recovery log can be stored in a database providing a JDBC driver,
          it is possible to make the recovery log fault tolerant by redirecting it to a Sequoia
          controller (even self) that will distribute and replicate the log content on
          several backends.</para>
        <para>The JDBC Recovery Log configuration is detailed in <xref
            linkend="dtd_recoverylog"/>.</para>
      </section>
    </section>
    
    <!-- ========== Controller replication ========== -->
		<section id="controller_replication">
			<title>Controller replication</title>
      <para>To prevent the Sequoia controller from being a single point of 
        failure, Sequoia provides controller replication also called horizontal 
        scalability. A virtual database can be replicated in several 
        controllers that can be added dynamically at runtime. Controllers use 
        the JGroups group communication middleware to synchronize updates in a 
        distributed way. The JGroups stack configuration is found in 
        <filename>config/jgroups.xml</filename> and should not be altered 
        unless you specifically know what you are doing. Keep in mind that 
        total order reliable multicast is needed to ensure proper 
        synchronization of the controllers. More information about JGroups can 
        be found on <ulink url="http://www.jgroups.org">the JGroups web 
        site</ulink>. Note that JGroups requires proper network settings, here 
        are a few guidelines:</para>
      <itemizedlist>
        <listitem>
          <para>a default route must be defined (check with /sbin/route under Linux) for the
            network adapter which is bound by JGroups (usually eth0). If such route does not
            exist, either the group communication initialization will block or
            controllers will not be able to see each other even on the local host. If you don't
            have any default entry in your routing table you can use a command like
            '/sbin/route add default eth0' to define this default route. </para>
        </listitem>
        <listitem>
          <para> issues have been reported with DHCP that can either block (under Windows) or
            just fail to properly set a default route and leads to the issue reported above. We
            strongly discourage the use of DHCP, you should use fixed IP addresses instead.
            </para>
        </listitem>
        <listitem>
          <para> name resolution should be properly set so that the IP address/machine name
            matching works both ways. Often improper /etc/hosts or DNS configuration leads
            to group communication initialization problems. In particular, under Linux,
            the IP address associated to the name returned by the 'hostname' command must not
            resolve to 127.0.0.1 else controllers will not see each other.</para>
        </listitem>
      </itemizedlist>

      <para>Horizontal scalability can also be provided using Appia. 
        The Appia stack configurations are found in 
        <filename>config/appia.xml</filename>. This file contains six different configurations, 
        six templates for communication channels and their respective channel instantiations. These are the
		combinations of two total order implementations (sequencer based  and token based total order) 
		using different transport protocols: TCP, UDP and UDP multicast. Instructions to change the default
        configuration are in the header of the file. All the defined configurations
        ensure total order reliable multicast. More information about Appia can 
        be found on the <ulink url="http://appia.continuent.org">web site</ulink>. 
        Note that Appia also requires proper network settings, here 
        are a some guidelines:</para>
      <itemizedlist>
        <listitem>
          <para>a default route must be defined (check with /sbin/route under Linux) for the
            network adapter which is bound by Appia (usually eth0). If such route does not
            exist, controllers will not be able to see each other. If you don't
            have any default entry in your routing table you can use a command like
            '/sbin/route add default eth0' to define this default route. </para>
        </listitem>
        <listitem>
          <para> name resolution should be properly set so that the IP address/machine name
            matching works both ways. Often improper /etc/hosts or DNS configuration leads
            to group communication initialization problems. In particular, under Linux,
            the IP address associated to the name returned by the 'hostname' command must not
            resolve to 127.0.0.1 else controllers will not see each other.</para>
        </listitem>
        <listitem>
          <para> Appia does not need to use fixed IP addresses, unless you want to bind a controller
          to a specific IP address. To discover other controllers Appia uses a gossip service. 
          The gossip service can be configured to use a multicast address (if your network supports it)
          or you can start a gossip server. This server can also be replicated and is used just to 
          help the dynamic discovery of new nodes.
          </para>
        </listitem>        
      </itemizedlist>

			<para>In order for a virtual database to be replicated, you must define a 
				<literal>Distribution</literal> element in the virtual database 
				configuration file (see <xref linkend="distribution"/>). There are 
				several constraints for different controllers to replicate a virtual 
				database:</para>
			<itemizedlist>
        <listitem>
          <para>give the list of all controllers that you plan to use for 
            replication of your virtual database in the Sequoia driver URL. Even 
            if all controllers are not online at all times, the driver will 
            automatically detect the alive controllers: 
            jdbc:sequoia://node1,node2,node3,node4/myDB</para>
        </listitem>
				<listitem>
					<para>the virtual database must have the same name and use the same 
						groupName (in the Distribution element).</para>
				</listitem>
				<listitem>
					<para>each controller must have its own set of backends and no 
						backends should be shared between controllers (Sequoia checks the 
						database URLs, having different backend names is not 
						sufficient).</para>
				</listitem>
        <listitem>
          <para>each controller must have its own recovery log, recovery logs 
            cannot be shared. It is possible for a controller not to have a 
            recovery log but this controller will have no recovery 
            capabilities.</para>
        </listitem>
				<listitem>
					<para>the authentication managers must support the same logins.</para>
				</listitem>
				<listitem>
					<para>schedulers and load balancers must implement the same RAIDb 
						configuration.</para>
				</listitem>
				<listitem>
					<para>database schemas (if defined) must be compatible according to 
						the RAIDb level you are using.</para>
				</listitem>
			</itemizedlist>
      <note>
        <para>As backends cannot be shared between controllers, it is not 
          possible to use a SingleDB load balancer with controller replication. 
          If each controller only has a single database backend attached to it, 
          then you must use a RAIDb-1 configuration since in fact you have 2 
          replicated backends in the cluster.</para>
      </note>
			<para>Several configuration file examples are available in the <filename 
				class="directory">doc/examples/HorizontalScalability</filename> 
				directory of your Sequoia distribution.</para>
      <note>
        <para>You can find more information in the document titled "Sequoia 
          Horizontal Scalability - A controller replication user guide" 
          available from the Sequoia web site.</para>
      </note>
		</section>

    <!-- ========== Current Limitations ========== -->
	<section id="current_controller_limitations">
		<title>Current Limitations</title>
		<para>The Sequoia controller in its @VERSION@ release has the following 
			limitations:</para>
		<itemizedlist>
      <listitem>
        <para>GRANT/REVOKE commands will be sent to the database engines but 
          this will not add or remove users from the virtual database 
          authentication manager.</para>
      </listitem>
			<listitem>
				<para>network partition/reconciliation is not supported,</para>
			</listitem>
			<listitem>
				<para>distributed joins are not supported which means that you 
					must ensure that every query can be executed by at least a 
					single backend,</para>
			</listitem>
			<listitem>
				<para><literal>RAIDb-1ec</literal> and 
					<literal>RAIDb-2ec</literal> levels are not 
					supported,</para>
			</listitem>
		</itemizedlist>
	</section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Administration Console -->
  <!-- =============================================================== -->
  <section id="administration_console">
    <title>Administration console</title>
    <para>The Sequoia administration console is based on JMX technologies. The text mode
      console is a JMX client based on the standard RMI connector for JMX but you can also use a
      generic a JMX administration console through HTTP from any web browser to see all the
      MBeans registered in the sequoia domain. An Eclipse plug-in is provided by the <ulink
        url="http://oak.continuent.org">Oak project</ulink>.</para>
    <para> You can start the administration console using the console.sh/.bat script.</para>
    <!-- ========== Jmx Notifications ========== -->	
	<section id="jmx_notifications">
		<title>Jmx Notifications List</title>
    <para>Here is a list of the JMX remote notifications generated by Sequoia.</para>
    <!-- TODO: explain how to listen to these notifications with an sample program
      -->
    <itemizedlist>
      <listitem>
        <para><literal>sequoia.controller.virtualdatabases.removed</literal> a 
          virtual database has been removed.</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.controller.virtualdatabase.added</literal> a 
          virtual database has been added to the controller</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.dump.list</literal> the 
          list of dump files has been updated</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.added</literal> a backend 
          has been added to the virtual database</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.distributed.controller.added</literal> a 
          controller has joined the group</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.disabled</literal> a 
          backend has been disabled</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.enabled</literal> a 
          backend has been enabled</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.recovering</literal> a 
          backend is recovering a dump file</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.recovery.failed</literal> 
          Recovery of a dump file failed</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.replaying.failed</literal> 
          Recovery log replay failed</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.backingup</literal> a 
          backend is backing up</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.enable.write</literal> a 
          backend is now write enabled</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.removed</literal> a 
          backend has been removed from the virtual database</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.disabling</literal> a 
          backend is now in state disabling (finishing pending transactions and 
          pending requests)</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.unknown</literal> The 
          backend state has been completely lost. Recovery needed</para>
      </listitem>
      <listitem>
        <para><literal>sequoia.virtualdatabase.backend.replaying</literal> a 
          backend is replaying requests from the recovery log</para>
      </listitem>
    </itemizedlist>
	</section>
	
    <!-- ========== Starting the console ========== -->
    <section id="starting_console">
      <title>Starting the Administration Console</title>
      <para>The <filename class="directory">bin</filename> directory of the 
        Sequoia distribution contains the scripts to start the console. Unix 
        users must start the console with <command>console.sh -t</command> whereas 
        Windows users have to start <command>console.bat -t</command>.</para>
      <para>The console script accepts several options:</para>
      <itemizedlist>
        <listitem>
          <para><option>-d</option> or <option>--debug</option>: show
          stack trace when error occurs.</para>
        </listitem>
        <listitem>
          <para><option>-f</option> or <option>--file</option>: Use a
          given file as the source of commands instead of reading
          commands interactively.</para>
        </listitem>
        <listitem>
          <para><option>-h</option> or <option>--help</option>:
          displays usage information.</para>
        </listitem>
        <listitem>
          <para><option>-i</option> or <option>--ip</option>: IP
          address of the host name where the JMX Server hosting the
          controller is running (the default is '0.0.0.0').</para>
        </listitem>
        <listitem>
          <para><option>-p</option> or <option>--port</option>:
        JMX/RMI port number of (the default is 1090).</para>
        </listitem>
        <listitem>
          <para><option>-s</option> or <option>--secret</option>:
        Password for JMX connection.</para>
        </listitem>
        <listitem>
          <para><option>-u</option> or <option>--username</option>:
          username for JMX connection.</para>
        </listitem>
        <listitem>
          <para><option>-v</option> or <option>--version</option>:
          displays version information.</para>
        </listitem>
        <listitem>
          <para><option>-t</option> or <option>--text</option>:
          force the console to start in text mode. By default, it will try to start in graphic mode
		  </para>
        </listitem>
      </itemizedlist>

      <para>For example, <command>console.sh -t -i 192.168.0.1 -p
        1234</command> will connect the console to the controller
        using the RMI JMX adaptor listening on port 1234 on
        <literal>192.168.0.1</literal>.</para>

      <para>The console has an online help that is accessible by
        typing <command>help</command> at any time.</para>
    </section>
    <!-- ========== Console Quickstart ========== -->
    <section id="console_quickstart">
      <title>Console Quickstart</title>
      <para>Here is a quick description of the steps needed to make a 
        controller ready to serve requests:</para>
      <orderedlist>
        <listitem>
          <para>Start the controller using <command>controller.sh</command> or 
            <command>controller.bat</command> (see <xref 
            linkend="starting_controller"/>).</para>
        </listitem>
        <listitem>
          <para>Start the console using <command>console.sh -t</command> or 
            <command>console.bat -t</command> (see <xref 
            linkend="starting_console"/>).</para>
        </listitem>
        <listitem>
          <para>Load a configuration file using <command>load 
            &lt;complete-path>/config.xml</command>. The controller 
            configuration files are described in <xref 
            linkend="configuration"/>.</para>
        </listitem>
        <listitem>
          <para>Connect to the virtual database with the administrator login 
            using the <command>admin</command> command (see example 
            below).</para>
        </listitem>
        <listitem>
          <para>Enable all backends using the <command>enableAll</command> 
            command.</para>
        </listitem>
        <listitem>
          <para>Come back to the main menu using the <command>quit</command> 
            command.</para>
        </listitem>
        <listitem>
          <para>Check the configuration using the <command>getInfo</command> 
            command.</para>
        </listitem>
      </orderedlist>
      <para>Here is an example of a controller configuration and startup:</para>
      <programlisting>
<![CDATA[ 
[emmanuel@gre-home bin]$ console.sh -t
Launching the Sequoia controller console
Initializing Controller module...
Initializing VirtualDatabase Administration module...
Initializing Monitoring module...
Initializing SQL Console module...
Sequoia driver (v. 2.0) successfully loaded.
  
gre-home:1090 >help
Commands available for the Controller module are:
admin <virtualdatabase name>
   Administrate a virtual database
connect controller <controller hostname> <jmx port>
   Connect to a Sequoia controller
drop virtualdatabase <virtualdatabase name>
   Drop a virtual database from the controller
help
   Print this help message
history [<commandIndex>]
   Display history of commands for this module
load virtualdatabase config <virtualdatabase xml file>
   Send a virtual database XML configuration file to the controller and load it
monitor <virtualdatabase name>
   Monitor a virtual database
quit
   Quit this console
reload logging configuration
   Refresh the trace system by reloading the logging configuration file
save configuration
   Save the current configuration of the virtual databases as an XML file
show controller config
   Show Controller configuration
show logging config
   Show logging configuration and the most recent traces
show virtualdatabases
   Show the names of the virtual databases for this controller
shutdown [mode]
   Shutdown the controller and all its virtual databases. Mode parameter must be:
        1 -- wait for all client connections to be closed, does not work with a connection pool
        2 -- mode safe, default value, waits for all current transactions to complete
        3 -- mode force, immediate shutdown without consistency: recovery will be needed on restart
sql client <sequoia url>
   Open a SQL client console for the virtual database specified by the Sequoia URL
upload driver <driver file>
   Upload a driver to the controller

gre-home:1090 > <userinput>show virtualdatabases</userinput>
myDB
gre-home:1090 > <userinput>admin myDB</userinput>
Virtual database Administrator Login > <userinput>admin</userinput>
Virtual database Administrator Password > <userinput>*****</userinput>
Ready to administrate virtual database myDB
myDB(admin) > help
Commands available for the VirtualDatabase Administration module are:
backup <backend name> <dump name> <backuper name> <path> [<tables>]
   Backup a backend into a dump file and associate a checkpoint with this dump
delete dump <dump name>
   Delete a dump
disable <backend name | *>
   Disable the specified backend and automatically set a checkpoint
        * means that all backends of this virtual database must be disabled
enable <backend name | *>
   Enable the specified backend
        * means that all backends of this virtual database must be enabled
expert <on|off>
   Switch to expert mode (commands for advanced users are available)
help
   Print this help message
history [<commandIndex>]
   Display history of commands for this module
quit
   Quit this console
restore <backend name> <dump name> [<tables>]
   Starts the recovery process of the given backend for a given dump name
show backend <backend name | *>
   Show information on backend of this virtual database
        * means to show information for all the backends of this virtual database
show backends
   Show the names of the backends of this virtual database on the current controller
show backupers
   Show the backupers available for backup
show controllers
   Show the names of the controllers hosting this virtual database
show dumps
   Show all dumps available for database recovery
show virtualdatabase config
   Show the XML configuration of the virtual database
transfer dump <dump name> <controller name> [nocopy]
   Make a dump available for restore on another controller.
Optional 'nocopy' (default: false) flag specifies not to copy the dump.

myDB(admin) > <userinput>show backend *</userinput>
+--------------------------+-----------------------------------+
| Backend Name             | localhost                         |
| Driver                   | org.hsqldb.jdbcDriver             |
| URL                      | jdbc:hsqldb:hsql://localhost:9001 |
| Active transactions      | 0                                 |
| Pending Requests         | 0                                 |
| Read Enabled             | true                              |
| Write Enabled            | true                              |
| Is Initialized           | true                              |
| Static Schema            | false                             |
| Connection Managers      | 1                                 |
| Total Active Connections | 5                                 |
| Total Requests           | 0                                 |
| Total Transactions       | 0                                 |
| Last known checkpoint    | <unknown>                         |
+--------------------------+-----------------------------------+
| Backend Name             | localhost2                        |
| Driver                   | org.hsqldb.jdbcDriver             |
| URL                      | jdbc:hsqldb:hsql://localhost:9002 |
| Active transactions      | 0                                 |
| Pending Requests         | 0                                 |
| Read Enabled             | true                              |
| Write Enabled            | true                              |
| Is Initialized           | true                              |
| Static Schema            | false                             |
| Connection Managers      | 1                                 |
| Total Active Connections | 5                                 |
| Total Requests           | 0                                 |
| Total Transactions       | 0                                 |
| Last known checkpoint    | <unknown>                         |
+--------------------------+-----------------------------------+
]]>
      </programlisting>
    </section>
    <!-- ========== Console Main Menu ========== -->
    <section id="console_main_menu">
      <title>Console Main Menu</title>
      <para>The graphical version of the console provides a shell-like history 
        (more precisely a tcsh-like behavior). You can recall a previous 
        command by using the arrow keys (up and down) to browse the history. If 
        you prefix a command by <literal>!</literal>, the console will browse 
        the history and complete the command with the latest command in the 
        history starting with the command prefix (completion occurs when you 
        press the tab key). In the graphical version, you can also access all 
        the commands of the different module using the right button of the 
        mouse. </para>
      <note>
        <para>All the commands issued can also be recalled using the history 
          menu in the contextual menu that appears on a right-button 
          click.</para>
      </note>
      <para>Commands available from the console main menu are:</para>
      <itemizedlist>
        <listitem>
          <para><command>admin &lt;virtualdatabase name&gt;</command>: Administrate a virtual database</para>
        </listitem>
        <listitem>
          <para><command>connect controller &lt;controller hostname&gt; &lt;jmx port&gt;</command>: connect to a Sequoia controller</para>
        </listitem>
        <listitem>
          <para><command>drop virtualdatabase &lt;virtualdatabase name&gt;</command>: Drop a virtual database from the controller</para>
        </listitem>
        <listitem>
          <para><command>help</command>:  Print this help message</para>
        </listitem>
        <listitem>
          <para><command>history [&lt;commandIndex&gt;]</command>:  Display history of commands for this module</para>
        </listitem>
        <listitem>
          <para><command>load virtualdatabase config &lt;virtualdatabase xml file&gt;</command>: Send a virtual database XML 
          configuration file to the controller and load it</para>
        </listitem>
        <listitem>
          <para><command>monitor &lt;virtualdatabase name&gt;</command>: Monitor a virtual database</para>
        </listitem>
        <listitem>
          <para><command>quit</command>: Quit this console</para>
        </listitem>
        <listitem>
          <para><command>reload logging configuration</command>: Refresh the trace system by reloading the logging configuration file</para>
        </listitem>
        <listitem>
          <para><command>save configuration</command>: Save the current configuration of the virtual databases as an XML file</para>
        </listitem>
        <listitem>
          <para><command>show controller config</command>: Show Controller configuration</para>
        </listitem>
        <listitem>
          <para><command>show logging config</command>: Show logging configuration and the most recent traces</para>
        </listitem>
        <listitem>
          <para><command>show virtualdatabases</command>: Show the names of the virtual databases for this controller</para>
        </listitem>
        <listitem>
          <para><command>shutdown [<literal>mode</literal>]</command>: shutdown 
            the controller and all its virtual databases.</para>
          <para>Three shutdown modes are provided. If not specified, the 
            default mode is the shutdown mode immediate.</para>
          <itemizedlist>
            <listitem>
              <para>Shutdown mode wait (mode <literal>1</literal>): wait for 
                all client connections to be closed, does not work if the 
                client uses a connection pool with persistent 
                connections.</para>
            </listitem>
            <listitem>
              <para>Shutdown mode safe (mode <literal>2</literal>): default 
                value, waits for all current transactions to complete before 
                shutting down. transaction and shutdown.</para>
            </listitem>
            <listitem>
              <para>Shutdown mode force (mode <literal>3</literal>): does not 
                wait for transactions completion and kill all connections. 
                Backends are disabled without consistency and a full recovery 
                will be needed on restart.</para>
            </listitem>
          </itemizedlist>
          <para>E.g: <command>shutdown 2</command>.</para>
        </listitem>
        <listitem>
          <para><command>sql client &lt;sequoia url&gt;</command>: Open a SQL client console for the virtual database specified by the 
          Sequoia URL</para>
        </listitem>
        <listitem>
          <para><command>upload driver &lt;driver file&gt;</command>: Upload a driver to the controller</para>
        </listitem>
      </itemizedlist>
    </section>
    <!-- ========== Administrator Menu ========== -->
    <section id="administrator_menu">
      <title>Administrator Menu</title>
      <para>Once the configuration file has been loaded on the controller, all 
        backends are in the disabled state. You must enable them all or one by 
        one to allow them to execute requests. Sequoia does not check that 
        database contents are synchronized and you must ensure that all 
        backends are in a coherent state prior to starting the controller. To 
        ensure that backends remain synchronized on startup, you must use 
        checkpoints (see <xref linkend="understanding_checkpoints"/>).</para>
        <para>If you properly shutdown the controller using the wait or safe 
          mode, database backend states are properly recorded and their state 
          is automatically restored when they are enabled.</para>
      <section id="administrator_standard_commands">
      <title>Administrator Standard Commands</title>
      <para>Standard commands available from the console administrator menu are:</para>
      <itemizedlist>
        <listitem>
          <para><command>backup &lt;backend name&gt; &lt;dump name&gt; &lt;backuper
            name&gt; &lt;path&gt; [&lt;tables&gt;]</command>: Backup a backend into a
            dump file and associate a checkpoint with this dump. Note that the console will
            ask for a login and password to connect to the backend to backup. This is specific
            to the Backuper that you are using but this should usually be a valid
            login/password on the database engine that you are backuping. The login must be
            granted access on all tables from the controller node.</para>
        </listitem>
        <listitem>
          <para><command>delete dump &lt;dump name&gt;</command>: Delete a dump</para>
        </listitem>
        <listitem>
          <para><command>disable &lt;backend name | *&gt;
            &lt;checkpoint&gt;</command>: Disable the specified backend and store the
            given checkpoint (* means that all backends of this virtual database must be
            disabled)</para>
        </listitem>
        <listitem>
          <para><command>enable &lt;backend name | *&gt;</command>: Enable the
            specified backend from its last known checkpoint (* means that all backends of
            this virtual database must be enabled)</para>
        </listitem>
        <listitem>
          <para><command>expert &lt;on|off&gt;</command>: Switch to expert mode
            (commands for advanced users are available)</para>
        </listitem>
        <listitem>
          <para><command>help</command>: Print this help message</para>
        </listitem>
        <listitem>
          <para><command>history [&lt;commandIndex&gt;]</command>: Display history
            of commands for this module</para>
        </listitem>
        <listitem>
          <para><command>quit</command>: Quit this console</para>
        </listitem>
        <listitem>
          <para><command>restore &lt;backend name&gt; &lt;dump name&gt;
            [&lt;tables&gt;]</command>: Starts the recovery process of the given backend
            using the given dump name. Note that the console will ask for a login and password
            to connect to the backend to restore This is specific to the Backuper that you are
            using but this should usually be a valid login/password (real login in the Sequoia
            terminology) on the database engine that you are restoring. Note that this login
            must be granted the right to create new databases and tables.</para>
        </listitem>
        <listitem>
          <para><command>show backend &lt;backend name | *&gt;</command>: Show
            information on backend of this virtual database (* means to show information for
            all the backends of this virtual database) </para>
        </listitem>
        <listitem>
          <para><command>show backends</command>: Show the names of the backends of this
            virtual database on the current controller </para>
        </listitem>
        <listitem>
          <para><command>show backupers</command>: Show the backupers available for
            backup</para>
        </listitem>
        <listitem>
          <para><command>show controllers</command>: Show the names of the controllers
            hosting this virtual database</para>
        </listitem>
        <listitem>
          <para><command>show dumps</command>: Show all dumps available for database
            recovery</para>
        </listitem>
        <listitem>
          <para><command>show virtualdatabase config</command>: Show the XML
            configuration of the virtual database</para>
        </listitem>
        <listitem>
          <para><command>transfer dump &lt;dump name&gt; &lt;controller
            name&gt;</command>: Transfer a dump from the current controller to another
            controller. An example is <command>transfer dump dump1
            controller2.emic.com:1090</command></para>
        </listitem>      
      </itemizedlist>
      </section>
      <section id="administrator_expert_commands">
      <title>Administrator Expert Commands</title>
      <para>Expert commands are not available by default. use the command expert on to make them available.</para>
      <itemizedlist>
        <listitem>
          <para><command>clone backend config &lt;backend from&gt; &lt;backend to&gt;
            &lt;url&gt; [driverPath=&lt;value&gt;] [driver=&lt;value&gt;]
            [connectionTestStatement=&lt;value&gt;]</command>: Clone the
            configuration of a backend in the current virtual database (this virtually
            allows to add a new backend)</para>
        </listitem>
        <listitem>
          <para><command>disable read &lt;backend name&gt;</command>: Disable read
            requests on a backend</para>
        </listitem>
        <listitem>
          <para><command>enable read &lt;backend name&gt;</command>: Enable read
            requests on a backend</para>
        </listitem>
        <listitem>
          <para><command>force checkpoint &lt;backend name&gt; &lt;checkpoint
            name&gt;</command>: Force the last know checkpoint of a disabled
            backend</para>
        </listitem>
        <listitem>
          <para><command>force disable &lt;backend name | *&gt;</command>: Force the
            disabling of a backend without storing any checkpoints. The backend will not be
            in a consistent state after this operation! (* means that all backends of this
            virtual database must be disabled by force)</para>
        </listitem>
        <listitem>
          <para><command>force enable &lt;backend name | *&gt;</command>: Force the
            enabling of a backend without checking for checkpoints. This command can break
            the cluster consistency, only use it if you know what you are doing! (* means that
            all backends of this virtual database must be enabled by force)</para>
        </listitem>
        <listitem>
          <para><command>force path &lt;dump name&gt; &lt;new path&gt;</command>:
            Update the path of the dump</para>
        </listitem>
        <listitem>
          <para><command>get backend schema &lt;backend name&gt; &lt;file
            name&gt;</command>: Display backend schema or save it to a file</para>
        </listitem>
        <listitem>
          <para><command>purge log &lt;checkpoint name&gt;</command>: Purge the
            recovery log upto specified checkpoint. All the entries of the recovery log
            prior to that checkpoint will be deleted.</para>
        </listitem>
        <listitem>
          <para><command>restore log &lt;dump name&gt; &lt;controller
            name&gt;</command>: Copy the local recovery log from the specified checkpoint
            onto the specified remote controller. All previous recovery log content on the
            remote controller will be erased.</para>
        </listitem>
        <listitem>
          <para><command>show checkpoints</command>: Show all checkpoints available in
            the recovery log.</para>
        </listitem>
        <listitem>
          <para><command>transfer backend &lt;backend name&gt; &lt;controller jmx
            address&gt;</command>: Transfer a backend from a controller to an other
            controller</para>
        </listitem>
      </itemizedlist> 
      </section>	  
    </section>
	  
	  <!-- Automated Backup with Jmx -->
      <section id="automated_backup_with_jmx">
        <title>Automated Backup With Jmx</title>
        <para>Marc Wick has given an example of a cron file to do a daily backup using the jmx connector in Sequoia.
	The complete sources can be found in the example file:DBBackup.java in the jmx directory 
	of the examples.
	</para>
        <programlisting>
    JMXServiceURL address = new JMXServiceURL("rmi", host, 0, "/jndi/jrmp");

    Map environment = new HashMap();
    environment.put(Context.INITIAL_CONTEXT_FACTORY,
        "com.sun.jndi.rmi.registry.RegistryContextFactory");
    environment.put(Context.PROVIDER_URL, "rmi://" + host + ":" + port);
    environment.put(JMXConnector.CREDENTIALS, PasswordAuthenticator
        .createCredentials("jmxuser", "jmxpassword"));

    JMXConnector connector = JMXConnectorFactory.connect(address, environment);
    ObjectName db = JmxConstants.getVirtualDbObjectName("databaseName");

    ...
    
    MBeanServerConnection delegateConnection = connector
        .getMBeanServerConnection(subj);

    // we create a proxy to the virtual database
    VirtualDatabaseMBean proxy = (VirtualDatabaseMBean) MBeanServerInvocationHandler
        .newProxyInstance(delegateConnection, db, VirtualDatabaseMBean.class,
            false);

    SimpleDateFormat fmt = new SimpleDateFormat("yyyy_MM_dd");
    String checkpointName = fmt.format(new Date());

    // we disable the backend and set a checkpoint
    proxy.disableBackendForCheckpoint("node1", checkpointName);

    // we call the database specific backup tool for the backup
    runDatabaseBackupTool();

    // we enable the backend again
    proxy.enableBackend("node1");
	</programlisting>
	<para>The runDatabaseBackupTool() method is completely open and can call 
	any external program (like pg_dump, mysql_dump...)
	</para>
	<note>
	<para>This method does not use octopus and as a consequence, the generated 
	backup cannot be restored on a a different database vendor than the one 
	it was issued from.
	As a great benefit though, the backup process will gain in speed, and 
	the metadata will be completely conformed to that database vendor.
	</para>
	</note>
      </section>
	  
    <section id="recovering_from_a_failed_controller_in_distributed_mode">
      <title>Recoverying from a failed controller in distributed mode</title>
      <para> In a distributed controller configuration, when a controller goes down, here is
        the list of action to take to recover the failed controller: </para>
      <itemizedlist>
        <listitem><para>If the controller does not have any dump available, connect to a
          controller that has database dumps and use the <command>transfer dump</command>
          command to copy the dump to the recovering controller.</para>
        </listitem>
        <listitem><para>During its failure, the recovery log of the controller missed
          queries that were executed by the cluster and it is therefore necessary to
          re-synchronize its recovery log. This can be achieve using the <command>recover
          log</command> from the same controller you used to transfer the dump.</para></listitem>
        <listitem><para>Once the previous operations are completed, you can safely
          restore the dump on the backends attached to the controller. Then, enabling the
          backends will resynchronize them with the other nodes of the cluster.</para>
          </listitem>
      </itemizedlist>
    </section>
	  
    <!-- ========== Virtual Database Console Menu ========== -->
    <section id="virtual_database_console_menu">
      <title>Virtual Database Console Menu</title>
      <para>Sequoia is now bundled with a graphical SQL console called Squirrel 
        that you can launch from the <filename class="directory">bin</filename> 
        directory of the Sequoia installation, using either 
        <filename>squirrel.sh</filename> or 
        <filename>squirrel.bat</filename>.You can also directly issue SQL 
        statements from the virtual database console menu. The other commands 
        available from the virtual database console menu are:</para>
      <itemizedlist>
        <listitem>
          <para><command>begin</command>:  Start a transaction</para>
        </listitem>
        <listitem>
          <para><command>commit</command>: Commit a transaction</para>
        </listitem>
        <listitem>
          <para><command>fetchsize &lt;x&gt;</command>: Set the ResultSet fetch size to x rows per block</para>
        </listitem>
        <listitem>
          <para><command>help</command>: Print this help message</para>
        </listitem>
        <listitem>
          <para><command>history [&lt;commandIndex&gt;]</command>:  Display history of commands for this module</para>
        </listitem>
        <listitem>
          <para><command>load &lt;file name&gt;</command>:  Execute all SQL statements contained in file</para>
        </listitem>
        <listitem>
          <para><command>maxrows &lt;x&gt;</command>:  Limits the maximum number of rows to get from the database to x</para>
        </listitem>
        <listitem>
          <para><command>quit</command>: Quit this console</para>
        </listitem>
        <listitem>
          <para><command>rollback [&lt;savepoint name&gt;]</command>:  Rollback a transaction (to an optional savepoint)</para>
        </listitem>
        <listitem>
          <para><command>savepoint &lt;savepoint name&gt;</command>:  Create a savepoint for the current transaction</para>
        </listitem>
        <listitem>
          <para><command>setisolation &lt;x&gt;</command>: Set the connection transaction isolation level to x</para>
          <itemizedlist>
            <listitem><para>0 - TRANSACTION_NONE</para>
            </listitem>
            <listitem><para>1 - TRANSACTION_READ_UNCOMMITTED</para>
            </listitem>
            <listitem><para>2 - TRANSACTION_READ_COMMITTED</para>
            </listitem>
            <listitem><para>4 - TRANSACTION_REPEATABLE_READ</para>
            </listitem>
            <listitem><para>8 - TRANSACTION_SERIALIZABLE</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><command>show tables</command>:  Display all the tables of this virtual database</para>
        </listitem>
        <listitem>
          <para><command>timeout &lt;x&gt;</command>: Set the query timeout to x seconds (default is 60 seconds)</para>
        </listitem>
        <listitem>
          <para><command>{call proc_name(?,?,...)}</command>: Call a stored procedure</para>
        </listitem>
       </itemizedlist>
      <para>Here is an example of a session with the virtual database 
        console:</para>
      <programlisting>
localhost:1090 > <command>sql client jdbc:sequoia://localhost/myDB</command>
 > Login     : <command>user</command>
 > Password  : <command>******</command>
Connected to jdbc:sequoia://localhost/myDB
jdbc:sequoia://localhost/myDB (user) > <command>begin</command>
Transaction started
jdbc:sequoia://localhost/myDB (user) > <command>select * from regions</command>
... result to be displayed here ...
jdbc:sequoia://localhost/myDB (user) > <command>commit</command>
jdbc:sequoia://localhost/myDB (user) > <command>quit</command>
      </programlisting>
    </section>
        </section>
  
  <!-- =============================================================== -->
  <!-- Section: RAIDb Basics -->
  <!-- =============================================================== -->
  <section id="raidb_basics">
    <title>RAIDb Basics</title>
    <!-- ========== RAIDb Definition ========== -->
    <section id="raidb_definitions">
      <title>RAIDb Definition</title>
      <para>RAIDb stands for <emphasis>Redundant Array of Inexpensive 
        Databases</emphasis>. This acronym has been used in reference to the 
        RAID (<emphasis>Redundant Array of Inexpensive Disks</emphasis>) 
        concept that achieves scalability and high availability of disk 
        subsystems at a low cost. RAIDb aims at providing better performance 
        and fault tolerance than a single database by combining multiple 
        inexpensive database instances into an array of databases.</para>
      <para>One of the goals of RAIDb is to hide the distribution complexity 
        and to provide the database clients with the view of a single database. 
        As for RAID, a controller sits in front of the underlying resources. 
        The clients send their requests to the RAIDb controller that balances 
        them among the set of RDBMS backends.</para>
    </section>
    <!-- ========== RAIDb-0 ========== -->
    <section id="raidb0">
      <title>RAIDb-0</title>
      <para>RAIDb-0 consists in <emphasis>partitioning</emphasis> the database 
        tables among the database backend nodes. A table itself cannot be 
        partitioned but the different tables can be distributed on different 
        backend nodes. RAIDb-0 requires at least two database backends, 
        provides moderate performance scalability but does not offer fault 
        tolerance. <xref linkend="fig_raidb-0_example"/> shows an example of a 
        RAIDb-0 configuration.</para>
      <figure id="fig_raidb-0_example">
        <title>RAIDb-0 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-0.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-0.gif" align="center" format="GIF" 
              scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <!-- ========== RAIDb-1 ========== -->
    <section id="raidb1">
      <title>RAIDb-1</title>
      <para>RAIDb-1 offers a <emphasis>full mirroring</emphasis> or 
        <emphasis>full replication</emphasis> of the database on the backends. 
        It offers the best fault tolerance scheme since the system is still 
        available with only one backend. On the minus side, there is no speedup 
        on writes (<literal>UPDATE</literal>, <literal>INSERT</literal>, 
        <literal>DELETE</literal> requests) since they have to be broadcasted 
        to all nodes. <xref linkend="fig_raidb-1_example"/> shows an example of 
        a RAIDb-1 configuration.</para>
      <figure id="fig_raidb-1_example">
        <title>RAIDb-1 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-1.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-1.gif" align="center" format="GIF" 
              scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <!-- ========== RAIDb-2 ========== -->
    <section id="raidb2">
      <title>RAIDb-2</title>
      <para>RAIDb-2 is a tradeoff between RAIDb-0 and RAIDb-1. It provides 
        partial replication to tune the degree of replication of each database 
        table to obtain the best read/write throughput. RAIDb-2 requires that 
        each database table is available on at least two nodes. <xref 
        linkend="fig_raidb-2_example"/> shows an example of a RAIDb-2 
        configuration.</para>
      <figure id="fig_raidb-2_example">
        <title>RAIDb-2 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-2.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-2.gif" align="center" format="GIF" 
              scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <!-- ========== Nested RAIDb levels ========== -->
    <section id="nested_raidb_levels">
      <title>Nested RAIDb Levels</title>
      <para>It is possible to compose several RAIDb levels to build large scale 
        configurations or meet specific needs. The next example is a RAIDb-1-0 
        configuration where a top level RAIDb-1 controller dispatches the 
        requests to three full databases implemented with a RAIDb-0 controller. 
        <xref linkend="fig_raidb-1-0_example"/> shows an example of a RAIDb-1-0 
        configuration.</para>
      <figure id="fig_raidb-1-0_example">
        <title>RAIDb-1-0 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-1-0.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-1-0.gif" align="center" 
              format="GIF" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>This last example (<xref linkend="fig_raidb-0-1_example"/>) shows a 
        RAIDb-0-1 composition. The top level is a RAIDb-0 controller and fault 
        tolerance is achieved on each partition using a RAIDb-1 
        controller.</para>
      <figure id="fig_raidb-0-1_example">
        <title>RAIDb-0-1 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-0-1.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata align="center" fileref="images/RAIDb-0-1.gif" 
              format="GIF" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Virtual database configuration -->
  <!-- =============================================================== -->
  <section id="configuration">
    <title>Virtual database configuration</title>
    <!-- ========== Writing a configuration file ========== -->
    <section id="writing_a_virtual_database_configuration_file">
      <title>Writing a Virtual Database Configuration File</title>
      <para>The Sequoia controller configuration file must conform to the Sequoia 
        DTD that can be found in the <filename class="directory">xml</filename> 
        directory of the Sequoia distribution. The DTD is extensively documented 
        and the most up-to-date information will be found in the 
        <filename>xml/sequoia-x.y.dtd</filename> file. Several configuration 
        file examples are available in the <filename 
        class="directory">doc/examples</filename> directory.</para>
      <para>Here is an example of how a minimal Sequoia configuration file 
        should look like:</para>
      <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?>

&lt;!DOCTYPE SEQUOIA PUBLIC "-//Continuent//DTD SEQUOIA 1.0//EN"
                        "http://sequoia.continuent.org/dtds/sequoia-@VERSION@.dtd">

&lt;SEQUOIA> 
  &lt;VirtualDatabase name="vdbName">
        
    &lt;Distribution/>
        
    &lt;AuthenticationManager> ...  &lt;/AuthenticationManager>

    &lt;DatabaseBackend name="node1" driver="com.myDriver.class"
                     url="jdbc:protocol://host/myDB" connectionTestStatement="select 1">
       ...
    &lt;/DatabaseBackend>

    &lt;RequestManager>
      &lt;RequestScheduler>
         ...
      &lt;/RequestScheduler>

      &lt;LoadBalancer>
         ...
      &lt;/LoadBalancer>
    &lt;/RequestManager>
  &lt;/VirtualDatabase>
&lt;/SEQUOIA>
      </programlisting>
      <para>The next sections describes the different elements composing an XML 
        configuration file.</para>
    </section>
    <!-- ========== Virtual Database ========== -->
    <section id="dtd_virtualdatabase">
      <title>Virtual Database</title>
      <para>A virtual database element is defined as follows:</para>
      <programlisting>
&lt;!ELEMENT VirtualDatabase (Distribution?, Monitoring?, Backup?,AuthenticationManager, DatabaseBackend+, RequestManager)>     
&lt;!ATTLIST VirtualDatabase 
       name               CDATA #REQUIRED
       maxNbOfConnections CDATA #IMPLIED
       poolThreads        (true | false) "true"
       minNbOfThreads     CDATA #IMPLIED
       maxNbOfThreads     CDATA #IMPLIED
       maxThreadIdleTime  CDATA #IMPLIED
       sqlDumpLength      CDATA "40"
       useStaticResultSetMetaData CDATA "true"
>
      </programlisting>

      <para>A virtual database is the database exposed to the user. It 
        contains:</para>
      <itemizedlist>
        <listitem>
          <para>a set of real database backends,</para>
        </listitem>
        <listitem>
          <para>an authentication manager that matches the virtual database and 
            real backends login/password,</para>
        </listitem>
        <listitem>
          <para>a request manager that defines the behavior of the controller 
            for this virtual database,</para>
        </listitem>
      </itemizedlist>
      <para>Here is a brief description of each virtual database 
        attribute:</para>
      <itemizedlist>
        <listitem>
          <para><literal>name</literal>: name of the virtual database to be 
            used in the JDBC URL 
            (<literal>jdbc:sequoia://host/<option>VirtualDatabaseName</option></literal>).</para>
        </listitem>
        <listitem>
          <para><literal>maxNbOfConnections</literal>: maximum number of 
            concurrent connections accepted for this virtual database. The 
            controller stops accepting client connections when 
            <literal>maxNbOfConnections</literal> concurrent connections are 
            running. Default is 0 (no limit).</para>
        </listitem>
        <listitem>
          <para><literal>poolThreads</literal>: if <literal>false</literal>, 
            one thread is created for each connection and dies when the 
            connection closes. If set to <literal>true</literal>, threads are 
            created on-demand and kept in a pool to be reused to serve multiple 
            connections. Default is <literal>true</literal>.</para>
        </listitem>
        <listitem>
          <para><literal>minNbOfThreads</literal>: minimum number of threads to 
            keep in the pool (if <literal>poolThreads</literal> is set to 
            <literal>true</literal>). Default is 0.</para>
        </listitem>
        <listitem>
          <para><literal>maxNbOfThreads</literal>: maximum number of threads in 
            the pool (if <literal>poolThreads</literal> is set to 
            <literal>true</literal>). Default is 0 (no limit).</para>
        </listitem>
        <listitem>
          <para><literal>maxThreadIdleTime</literal>: maximum time in seconds a 
            thread can remain idle before being removed from the pool. Default 
            is 60 seconds (a thread that has not serve any request in the past 
            60 seconds will be killed).</para>
        </listitem>
        <listitem>
          <para><literal>sqlDumpLength</literal>: maximum number of characters of a SQL
            statement to display in traces and exception messages. 0 means no limit and the
            full statement is inserted in the message (be careful especially if you are using
            large objects. Default is 40.</para>
        </listitem>
        <listitem>
          <para><literal>useStaticResultSetMetaData</literal>: when fetching
            DatabaseMetaData, Sequoia returns built-in ResultSetMetaData that conforms
            to the JDBC standard (default set to true). If your application relies on
            specific extensions of the database driver, you can disable this feature so that
            ResultSetMetaData is always fetched from the driver (slower but
            transparent).</para>
        </listitem>
      </itemizedlist>
    
    <!-- ========== Distribution ========== -->
    <section id="distribution">
    	<title>Distribution</title>
      <para>A Distribution element defines the group communication settings when a virtual
        database is replicated by multiple controllers (feature called horizontal
        scalability). A Distribution element is defined as follows:</para>
      <programlisting>
&lt;!ELEMENT Distribution (MessageTimeouts)>
&lt;!ATTLIST Distribution
  groupName              CDATA #IMPLIED
  hederaPropertiesFile   CDATA "/hedera_jgroups.properties"
>
      </programlisting>
      <itemizedlist>
        <listitem>
          <para><literal>MessageTimeouts</literal>: Tunable message timeouts for
            messages sent to the group of controllers. The timeouts are usually properly
            tuned by default and don't need to be modified.</para>
          <para><literal>groupName</literal>: group name to be used by the JGroups
            communication layer. If no name is provided, the virtual database name is used
            instead.</para> <note>
          <para>The JGroups stack configuration is defined in
            <filename>config/total-token.xml</filename>. Refer to the JGroups
            documentation if you want to alter the JGroups configuration. </para> </note>
          <note>
          <para>When a controller fails, all backends attached to it are automatically
            disabled. A full recovery process is then needed for these nodes. To learn more
            about this issue, read the <ulink
              url="http://c-jdbc.objectweb.org/current/doc/C-JDBC_horizontal_scalability.pdf">
            horizontal scalability design document</ulink>.</para> </note>
        </listitem>
        <listitem>
          <para><literal>hederaPropertiesFile</literal>: file name of the Hedera
            configuration file to use to setup the group communication for this virtual
            database. The default configuration use JGroups, but this value can be changed
            to use Appia instead.</para>
        </listitem>
      </itemizedlist>
      <section id="configuring_hedera">
        <title>Configuring Hedera group communication</title>
        <para>Hedera is a group communication wrapper that provides various high-level
          facilities such as distributed remote procedure calls. Hedera default
          configuration for Sequoia relies on the JGroups group communication library. You
          must specify the JGroups factory and the name of the JGroups configuration file
          in the Hedera configuration file usually called
          <filename>hedera_jgroups.properties</filename>. Here is an example of such
          file:</para>
        <programlisting>
hedera.factory=org.continuent.hedera.factory.JGroupsGroupCommunicationFactory
hedera.channel.jgroups.config=/total-token.xml
hedera.channel.jgroups.fragmentSize=32000          
        </programlisting>
        <para>
        You can change the configuration of Hedera to use Appia, instead of JGroups. 
        To change the configuration of Hedera to use Appia, change the 
          <literal>hederaPropertiesFile</literal> parameter of the 
          <literal>Distribution</literal> element to <literal>/hedera_appia.properties</literal>. 
          The default Appia configuration uses the file
        <filename>appia.xml</filename>. Here is an example of a configuration that uses Appia:</para>
        <programlisting>
     &lt;Distribution hederaPropertiesFile="/hedera_appia.properties">
       &lt;MessageTimeouts/>
     &lt;/Distribution>
        </programlisting>
        <note><para>It is possible to have one Hedera configuration file per virtual
        database. Therefore group communication settings are per virtual
        database.</para></note>
      </section>
      <section id="controller_replication_requirements">
        <title>Controller replication requirements</title>
        <para>When you replicate a virtual database in multiple controllers, there are some
          rules that you must follow:</para>
      </section>
    </section>

    <!-- ========== SQL Monitoring ========== -->
    <section id="dtd_sql_monitoring">
    <title>Monitoring</title>
    
	<note>
    <para>Warning! Monitoring can possibly lead to a memory leak and should only be used on a
      short period of time There is also a JMX method on the VirtualDatabaseMBean to set this on
      and off while online: </para>
		<programlisting>
			void setMonitoringToActive(boolean active) throws VirtualDatabaseException;
		</programlisting>
	</note>
	
    <para>Monitoring provides a generic section for different monitoring 
      modules. At the moment, only <quote>SQLMonitoring</quote> is provided. 
      </para>
    
    <programlisting>
&lt;!ELEMENT Monitoring (SQLMonitoring*)>

&lt;!ELEMENT SQLMonitoring (SQLMonitoringRule*)>
&lt;!ATTLIST SQLMonitoring
    defaultMonitoring (on | off) "on"
>
    </programlisting>
    
    <para>SQL Monitoring provides statistics (count, error, cache hits, 
      timing) for SQL queries. It is possible to define rules to turn 
      monitoring on or off for specific query patterns.</para>
    <para><literal>defaultMonitoring</literal>: defines the default rule if a 
      request should be monitored (on) or not (off) if no specific rule matches 
      the request. </para>
    
    <programlisting>
&lt;!ELEMENT SQLMonitoringRule EMPTY>
&lt;!ATTLIST SQLMonitoringRule
    queryPattern    CDATA #REQUIRED
    caseSensitive   (true | false) "false"
    applyToSkeleton (true | false) "false"
    monitoring      (on | off) "on"
>
    </programlisting>
    <para>A SQLMonitoringRule Defines a specific monitoring rule for all 
      queries that match the given pattern.</para>
    <itemizedlist>
      <listitem>
        <para><literal>queryPattern</literal>: a regular expression understood 
          by the Jakarta Regexp API. For more information on Regexp format, go 
          to <ulink url="http://jakarta.apache.org/regexp">Jakarta Regexp web 
          site</ulink>.</para>
      </listitem>
      <listitem>
        <para><literal>caseSensitive</literal>: true if the pattern matching 
          must be case sensitive.</para>
      </listitem>
      <listitem>
        <para><literal>applytoSkeleton</literal>: true if the pattern must 
          apply to the query skeleton (found in PrepareStatement), false if the 
          instantiated query should be used. Example: - 
          <emphasis>skeleton</emphasis>: <literal>SELECT * FROM t WHERE 
          x=?</literal> - <emphasis>instantiated query</emphasis>: 
          <literal>SELECT * FROM t WHERE x=12</literal> </para>
      </listitem>
      <listitem>
        <para><literal>monitoring</literal>: on to activate the monitoring for 
          this rule, off to disable it.</para>
      </listitem>
    </itemizedlist>
   
    <para>Examples: </para>
    <itemizedlist>
      <listitem>
        <para><literal>&lt;SQLMonitoring queryPattern="^delete" 
          monitorRequest="off"/></literal> will turn monitoring off for all 
          delete queries. </para>
      </listitem>
      <listitem>
        <para><literal>&lt;SQLMonitoring queryPattern="select * from users *" 
          monitorRequest="on"/></literal> will turn monitoring on for all 
          select queries on the users table. </para>
        <note>
          <para><emphasis>!Warning!</emphasis> This is different from 
            <literal>&lt;SQLMonitoring queryPattern="select \* from users *" 
            monitorRequest="on"/></literal> which turns monitoring on for the 
            "select * from users ..." kind of queries. </para>
        </note>
      </listitem>
    </itemizedlist>
 
    </section>
    
    </section> <!-- End virtual Database -->
	
    <!-- ========== Backup Manager ========== -->
	<section id="dtd_backupmanager">
      <title>Backup Manager</title>
      <para>A Backup Manager defines a number of Backuper in charge of performing
        backup/restore operations on backends. This element is defined as follows:</para>
	  <programlisting>
&lt;!ELEMENT Backup (Backuper+)>

&lt;!ELEMENT Backuper EMPTY>
&lt;!ATTLIST Backuper
    backuperName CDATA #REQUIRED
    className    CDATA #REQUIRED
    options      CDATA #IMPLIED
>
      </programlisting>

    <para> A Backuper is defined by a logical backuperName used by the administration console
      when performing a backup operation. The className specifies the implementation of the
      Backuper. Backuper specific options can be provided as well (this can be the path to a
      properties files or a set of attributes). Check your Backuper documentation for its
      specific options. </para>
    <para>Here is an example to use the Octopus Backuper for a virtual database:</para>
    <programlisting>
&lt;Backup>
  &lt;Backuper backuperName="Octopus" className="org.continuent.sequoia.controller.backup.backupers.OctopusBackuper"/>
&lt;/Backup>      
    </programlisting>
    <note>
      <para>Octopus does not have access to the Sequoia classloader for drivers and therefore
        it needs database drivers to be accessible from the controller classpath. A good
        solution is to unjar the drivers in the drivers/ directory of Sequoia.</para>
      <para>Octopus dumps are by default stored in a compressed .zip format.</para>
    </note>
	</section>
    <!-- ========== Authentication Manager ========== -->
    <section id="dtd_authenticationmanager">
      <title>Authentication Manager</title>
      <para>An authentication manager element is defined as follows:</para>
      <programlisting>
&lt;!ELEMENT AuthenticationManager (Admin+, VirtualUsers)>

&lt;!ELEMENT Admin (User+)>

&lt;!ELEMENT User EMPTY>
&lt;!ATTLIST User
    username CDATA #REQUIRED
    password CDATA #REQUIRED
>

&lt;!ELEMENT VirtualUsers (VirtualLogin+)>

&lt;!ELEMENT VirtualLogin (TrustedLogin*)>
&lt;!ATTLIST VirtualLogin 
    vLogin    CDATA #REQUIRED
    vPassword CDATA #REQUIRED
>
&lt;!ELEMENT TrustedLogin EMPTY>
      </programlisting>

      <para>An authentication manager defines:</para>
      <orderedlist>
        <listitem>
          <para>an administrator login to be used by the console to access the virtual
            database administration menu (see <xref linkend="administrator_menu"/>)
            that allows enabling the backends,</para>
        </listitem>
        <listitem>
          <para>"virtual logins" that are used by the client application and that are mapped
            to "real logins" for each backend.</para>
        </listitem>
        <listitem>
          <para>"trusted logins" will be used in the future to allow reusing other form of
            authentication from within Sequoia.</para>
        </listitem>
      </orderedlist>
      <para>Here is an example of an authentication manager definition:</para>
      <programlisting>
    &lt;AuthenticationManager>
      &lt;Admin>
      	&lt;User username="admin" password="adminPwd"/>
      &lt;/Admin> 
      &lt;VirtualUsers>
        &lt;VirtualLogin vLogin="user1" vPassword="userPwd1"/>
        &lt;VirtualLogin vLogin="user2" vPassword=""/>
      &lt;/VirtualUsers>
    &lt;/AuthenticationManager>
      </programlisting>
      <para>In this example, the virtual database has one administrator. The admin can use
        the login/password "admin/adminPwd" to log in the console.</para>
      <para>Two virtual logins are defined: <literal>user1</literal> and 
        <literal>user2</literal> with <literal>userPwd1</literal> and no password, 
        respectively. These logins are those used by the client application and 
        given to the Sequoia driver.</para>
      <para>The connection manager to use with each of the virtual has to be defined
        in the DatabaseBackend section. Each DatabaseBackend has to define a pool
        connection manager for each of the virtual user specified here.
      </para>
    </section>
    <!-- ========== Database Backend ========== -->
    <section id="dtd_databasebackend">
      <title>Database Backend</title>
      <para>Each database backend must be given a unique name (it is a logical 
        name but it is convenient to use the same name as the real machine 
        name). The database schema is automatically gathered from the backend 
        when it is added to the virtual database. However, you can specify a 
        static database schema (refer to <xref linkend="dtd_databaseschema"/>) 
        to be used instead. Finally, a specific connection manager (see <xref 
        linkend="dtd_connectionmanager"/>) defines the connection pooling 
        strategy for each virtual login on each backend.</para>
      <para>A database backend element is defined as follows:</para>
      <programlisting>
&lt;!ELEMENT DatabaseBackend (DatabaseSchema?, RewritingRule*, ConnectionManager+)>
&lt;!ATTLIST DatabaseBackend 
    name                     CDATA #REQUIRED
    driver                   CDATA #REQUIRED
    driverPath               CDATA #IMPLIED
    url                      CDATA #REQUIRED
    connectionTestStatement  CDATA #REQUIRED  
    nbOfBackendWorkerThreads CDATA "5"
>
      </programlisting>
      <para>Here is a brief description of database backend attributes:</para>
      <itemizedlist>
        <listitem>
          <para><literal>name</literal>: the unique logical name identifying 
            this backend.</para>
        </listitem>
        <listitem>
          <para><literal>driver</literal>: the database native JDBC driver 
            class name.</para>
        </listitem>
        <listitem>
          <para><literal>driverPath</literal>: name of the directory or jar 
            file containing the native driver files. If driverPath is omitted, 
            the driver must be in the <filename 
            class="directory">drivers/</filename> directory. If several driver 
            jar files are in the same directory, the first jar file containing 
            the class name specified in the <literal>driver</literal> attribute 
            is used. Note that drivers are loaded in separate classloaders 
            which allows you to use different versions of the same driver on 
            different backends just by specifying the right jar file.</para>
        </listitem>
        <listitem>
          <para><literal>url</literal>: the JDBC URL to connect to this 
            database backend.</para>
        </listitem>	
        <listitem>
          <para><literal>connectionTestStatement</literal>: SQL statement to 
            send on a connection to check if the connection is still valid. 
            This is used when Sequoia suspects a connection to be broken after 
            the failure of a request. This statement should not update the 
            database because if the connection is still valid the database 
            state should remain the same. Here are the settings for the most 
            popular databases:</para>
          <itemizedlist>
            <listitem>
              <para>for MySQL use <command>select 1</command></para>
            </listitem>
            <listitem>
              <para>for PostgreSQL use <command>select now()</command>.</para>
            </listitem>
            <listitem>
              <para>for Apache Derby use <command>values 1</command>.</para>
            </listitem>
            <listitem>
              <para>for HSQL use <command>call now()</command>.</para>
            </listitem>
            <listitem>
              <para>for SAP DB (MySQL MaxDB) use <command>select count(*) from 
                versions</command>.</para>
            </listitem>
            <listitem>
              <para>for Oracle use <command>select * from dual</command>.</para>
            </listitem>
            <listitem>
              <para>for Firebird use <command>select 1 from 
                rdb$types</command>.</para>
            </listitem>
            <listitem>
              <para>for InstantDB use <command>set date format 
                "yyyy/mm/dd"</command>.</para>
            </listitem>
            <listitem>
              <para>for Interbase use <command>select * from 
                rdb$types</command>.</para>
            </listitem>
            <listitem>
              <para>for Microsoft SQL server 2000 <command>select 
                1</command>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><literal>nbOfBackendWorkerThreads</literal>: defines the number of
            BackendWorkerThread that can process writes in parallel (minimum is 2, default
            is 5). A large number of threads will generally not improve write
            performance.</para>
        </listitem>
      </itemizedlist>
      <para>Here is a complete example of a database backend element including 
        its connection manager definition:</para>
      <programlisting>
&lt;DatabaseBackend name="node1" driver="org.gjt.mm.mysql.Driver"
      url="jdbc:mysql://node1.objectweb.org/rubis" connectionTestStatement="select 1">
  &lt;ConnectionManager vLogin="user1" rLogin="ruser1" rPassword="rpass1">
    &lt;SimpleConnectionManager/>
  &lt;/ConnectionManager>
  &lt;ConnectionManager vLogin="user2">
    &lt;VariablePoolConnectionManager initPoolSize="10" 
                                   minPoolSize="5"
                                   maxPoolSize="100"/>
  &lt;/ConnectionManager>
&lt;/DatabaseBackend>
      </programlisting>
    
    <!-- ========== Rewriting Rules Definition ========== -->
    <section id="dtd_rewriting_rules">
    <title>Rewriting requests on backends</title>
    <para>If your cluster is made of database engines from different vendors, 
      client requests might not be understood by all database backends. If your 
      application was written for PostgreSQL and you want to add MySQL 
      backends, some request might have to be adapted to execute correctly on 
      MySQL. You can specify rules to rewrite queries on the fly on a specific
      backend. A RewritingRule element defines how a query matching a given pattern 
      should be rewritten.</para>
    <programlisting>
&lt;!ELEMENT RewritingRule EMPTY>
&lt;!ATTLIST RewritingRule 
    queryPattern  CDATA #REQUIRED
    rewrite       CDATA #REQUIRED
    matchingType  (simple | pattern) "simple"
    caseSensitive (true | false) "false"
    stopOnMatch   (true | false) "false"
>
    </programlisting>
    <itemizedlist>
    	<listitem>
        <para><literal>queryPattern</literal>: SQL query pattern to match.</para>
    	</listitem>
    	<listitem>
    		<para><literal>rewrite</literal>: rewritten SQL query.</para>
    	</listitem>
    	<listitem>
        <para><literal>matchingType</literal>: <option>simple</option>: means that
          the first occurrence of queryPattern in the request will be replaced by the string
          specified in rewrite. <option>pattern</option>: uses a pattern based
          match/replace. A pattern uses <literal>?x</literal> where x is a logical number
          assigned to the pattern. Example: <literal>select ?1 from ?2 where
          x=?3</literal>.</para>
    	</listitem>
    	<listitem>
        <para><literal>caseSensitive</literal>: true if matching must be case 
          sensitive.</para>
    	</listitem>
    	<listitem>
    		<para><literal>stopOnMatch</literal>: rules are applied in the order they are 
      defined. If one rule matches and stopOnMatch is set to true, next rules 
      are ignored. If stopOnMatch is set to false, if another rule matches the 
      rewritten query, the query will be rewritten again.</para>
    	</listitem>
    </itemizedlist>

    <para>Examples: </para>
    <programlisting>
 &lt;RewritingRule queryPattern="from user" rewrite="from &quot;user;&quot;" 
    matchingType="simple"/></programlisting>
    <para>will rewrite the query <literal>select * from user where x=y</literal> as 
 <literal>select * from "user" where x=y</literal>.
    </para>
    <programlisting>
 &lt;RewritingRule queryPattern="select * from t where x=?1" 
    rewrite="select x from y where y=?1" matchingType="pattern"/></programlisting>
    <para>will rewrite the query <literal>select * from t where x=435</literal> to 
  <literal>select x from y where y=435</literal>
    </para>
   
   <programlisting>
 &lt;RewritingRule queryPattern="?1 LIMIT ?2,?3" rewrite="?1 LIMIT ?3,?2" 
    matchingType="pattern"/></programlisting>
    <para>will rewrite the query <literal>select * from t limit 
      10,20</literal> to <literal>select * from t limit 20,10</literal></para>
  
   </section>
    
    <!-- ========== Database Schema Definition ========== -->
    <section id="dtd_databaseschema">
      <title>Database Schema Definition</title>
      
      <para>DatabaseSchema groups static and dynamic definitions for 
        gathering, constructing and validating the in-memory schema used for 
        load balancing and caching.</para>
      <para>A Database schema is defined as follow</para>
         <programlisting>
&lt;!ELEMENT DatabaseSchema (DatabaseStaticSchema?)&gt;
&lt;!ATTLIST DatabaseSchema
 dynamicPrecision (static|table|column|procedures|all) "all"
 gatherSystemTables (true | false) "false"
 schemaName CDATA #IMPLIED
&gt;
       </programlisting>
       
      <itemizedlist>
        <listitem>
          <para><literal>dynamicSchemaPrecision</literal>: if set to 
            <option>static</option>, the controller will not check schemas and 
            stored procedures, it will entirely rely on the statically defined 
            schema. If set to something else than "static" it will get 
            information from the backend to check validity of static schema at 
            given level. <option>table</option> level will check for table 
            names only, <option>column</option> level will check for column 
            names, <option>procedures</option> will gather all executable 
            stored procedures. All, includes all information that can be 
            collected.</para>
        </listitem>
        <listitem>
          <para><literal>gatherSystemTables</literal>: true if system tables 
           and views should be retrieved, false otherwise  (default).</para>
        </listitem>
        <listitem>
          <para><literal>schemaName</literal>: if no schemaName is specified all 
           objects visible to the user are gathered, otherwise only the objects 
           belonging to the specified schema are used. </para>
        </listitem>
      </itemizedlist>
       <note>
        <para>Default option for constructing the schema is to collect all 
          information, even if a static schema is defined especially for 
          checking validity of input. This can be really slow if the database 
          has quite a number of stored procedures defined. </para>
       </note>
         
      <para>A static database schema can be defined to override the schema 
      automatically gathered by the controller. However, the schema must 
      remain compatible with the schema gathered from the backend.</para>
      <para>A database schema element is defined as follows:</para>    
      <programlisting>
&lt;!ELEMENT DatabaseStaticSchema (DatabaseProcedure*,DatabaseTable+)>

&lt;!ELEMENT DatabaseProcedure (DatabaseProcedureParameter*)>
&lt;!ATTLIST DatabaseProcedure 
     name       CDATA #REQUIRED
     returnType (resultUnknown | noResult | returnsResult) "resultUnknown"
>

&lt;!ELEMENT DatabaseTable (DatabaseColumn+)>
&lt;!ATTLIST DatabaseTable 
    tableName   CDATA #REQUIRED
    nbOfColumns CDATA #REQUIRED
>

&lt;!ELEMENT DatabaseColumn EMPTY>
&lt;!ATTLIST DatabaseColumn 
    columnName CDATA #REQUIRED
    isUnique   (true | false) "false"
>
      </programlisting>
      
      <para>The <literal>isUnique</literal> attribute should be set to 
        <literal>true</literal> if the column has a <literal>UNIQUE</literal> 
        constraint. This is the case for primary keys (composed primary keys 
        are not yet supported). This affects only cache behavior and select 
        statements parsing.</para>
      <para>Here is an example of a database schema definition:</para>
      <programlisting>
&lt;DatabaseStaticSchema>
   &lt;DatabaseTable tableName="users" nbOfColumns="10">
      &lt;DatabaseColumn columnName="id" isUnique="true"/>
      &lt;DatabaseColumn columnName="firstname" isUnique="false"/>
      &lt;DatabaseColumn columnName="lastname" isUnique="false"/>
      &lt;DatabaseColumn columnName="nickname" isUnique="false"/>
      &lt;DatabaseColumn columnName="password" isUnique="false"/>
      &lt;DatabaseColumn columnName="email" isUnique="false"/>
      &lt;DatabaseColumn columnName="rating" isUnique="false"/>
      &lt;DatabaseColumn columnName="balance" isUnique="false"/>
      &lt;DatabaseColumn columnName="creation_date" isUnique="false"/>
      &lt;DatabaseColumn columnName="region" isUnique="false"/>
   &lt;/DatabaseTable>

   &lt;DatabaseTable tableName="regions" nbOfColumns="2">
     &lt;DatabaseColumn columnName="id" isUnique="true"/>
     &lt;DatabaseColumn columnName="name" isUnique="false"/>
   &lt;/DatabaseTable>
&lt;/DatabaseStaticSchema>
      </programlisting>
    </section>
    <!-- ========== Connection Managers ========== -->
    <section id="dtd_connectionmanager">
      <title>Connection Manager</title>
      <para>One connection manager must be defined for each virtual login (vLogin) the
        backend belongs to. The real user login/password (rLogin/rPassword) combination
        used to connect to the physical database backend is set by default to the same as the
        virtual login/password. An example of a connection manager definition is available
        in <xref linkend="dtd_databasebackend"/>.</para>
      <para>The connection manager element complete definition is as 
        follows:</para>
      <programlisting>
&lt;!ELEMENT ConnectionManager (SimpleConnectionManager |
                             FailFastPoolConnectionManager |
                             RandomWaitPoolConnectionManager |
                             VariablePoolConnectionManager)>
&lt;!ATTLIST ConnectionManager 
    vLogin    CDATA #REQUIRED
    rLogin    CDATA #IMPLIED
    rPassword CDATA #IMPLIED
>

&lt;!ELEMENT SimpleConnectionManager EMPTY>

&lt;!ELEMENT FailFastPoolConnectionManager EMPTY>
&lt;!ATTLIST FailFastPoolConnectionManager
    poolSize CDATA #REQUIRED
>

&lt;!ELEMENT RandomWaitPoolConnectionManager EMPTY>
&lt;!ATTLIST RandomWaitPoolConnectionManager
    poolSize CDATA #REQUIRED
    timeout  CDATA #IMPLIED
>

&lt;!ELEMENT VariablePoolConnectionManager EMPTY>
&lt;!ATTLIST VariablePoolConnectionManager
    initPoolSize CDATA #REQUIRED
    minPoolSize  CDATA #IMPLIED
    maxPoolSize  CDATA #IMPLIED
    idleTimeout  CDATA #IMPLIED
    waitTimeout  CDATA #IMPLIED
>
      </programlisting>
      <para>Sequoia offers several connection managers that are described 
        hereafter:</para>
      <itemizedlist>
        <listitem>
          <para><literal>SimpleConnectionManager</literal>: basic connection 
            manager that opens a new connection on each request and closes it 
            at the end. It is useful if the underlying driver already 
            implements connection pooling for example.</para>
        </listitem>
        <listitem>
          <para><literal>FailFastPoolConnectionManager</literal>: offers 
            connection pooling and fails fast when the pool is empty. 
            <literal>poolSize</literal> is the size of the pool.</para>
          <para>All connections are initialized at startup time and if the pool 
            size is too large it is adjusted to the largest number of 
            connections available. Once the pool is empty, 
            <literal>null</literal> is returned instead of a connection. 
            Therefore incoming requests will fail until at least one connection 
            is freed. No system overload should occur with this connection 
            manager, but if the pool size is too small, many requests will 
            fail.</para>
        </listitem>
        <listitem>
          <para><literal>RandomWaitPoolConnectionManager</literal>: provides 
            connection pooling and wait when the pool is empty until a 
            connection is freed. This connection manager accepts the following 
            attributes:</para>
          <itemizedlist>
            <listitem>
              <para><literal>poolSize</literal>: this is the size of the 
                pool.</para>
            </listitem>
            <listitem>
              <para><literal>timeout</literal>: this is the maximum time in 
                seconds to wait for a connection to be freed. Default is 0 and 
                means no timeout, that is to say that we wait until one 
                connection is freed.</para>
            </listitem>
          </itemizedlist>
          <para>All connections are initialized at startup time and if the pool 
            size is too large it is adjusted to the largest number of 
            connections available. Once the pool is empty, the requests wait 
            until a connection is freed or the specified timeout has elapsed. 
            The FIFO<footnote><para>First In First Out.</para></footnote> order 
            of connection request is not ensured by this connection manager 
            since it relies on the Java wait/notify mechanism.</para>
        </listitem>
        <listitem>
          <para><literal>VariablePoolConnectionManager</literal>: provides 
            connection pooling with a dynamically adjustable pool size. This 
            connection manager accepts the following attributes:</para>
          <itemizedlist>
            <listitem>
              <para><literal>initPoolSize</literal>: initial pool size to be 
                initialized at startup.</para>
            </listitem>
            <listitem>
              <para><literal>minPoolSize</literal>: minimum number of 
                connections to keep in the pool. Default is equal to 
                <literal>initPoolSize</literal>.</para>
            </listitem>
            <listitem>
              <para><literal>maxPoolSize</literal>: maximum number of 
                connections in this pool. Default is 0 and means no 
                limit.</para>
            </listitem>
            <listitem>
              <para><literal>idleTimeout</literal>: time in seconds a 
                connection can stay idle before being released (removed from 
                the pool). Default is 0 and means that once allocated, 
                connections are never released.</para>
            </listitem>
            <listitem>
              <para><literal>waitTimeout</literal>: this is the maximum time in 
                seconds to wait for a connection to be freed. Default is 0 and 
                means no timeout, that is to say that we wait until one 
                connection is freed.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
    
    </section> <!-- End database backend -->
    
    <!-- ========== Request Manager ========== -->
    <section id="dtd_requestmanager">
      <title>Request Manager</title>
      <para>The request manager is composed of a scheduler (see <xref 
        linkend="dtd_requestscheduler"/>), an optional query cache (see <xref 
        linkend="dtd_requestcache"/>), a load balancer (see <xref 
        linkend="dtd_loadbalancer"/>) and an optional recovery log (see <xref 
        linkend="dtd_recoverylog"/>).</para>
      <para>If requests need to be parsed, it can be done sequentially when 
        needed (<literal>backgroundParsing</literal> is set to 
        <literal>false</literal> which is the default value) or forced to be 
        performed in background by a separate thread (it means a new thread is 
        created for each request that need to be parsed).</para>
      <para>Parsing is by default case insensitive 
        (<literal>caseSensitiveParsing</literal> is set to 
        <literal>false</literal>) which means that table and column names will 
        be matched to the database schema without checking the case. If you 
        want to enforce the parsing to be case sensitive and reject queries 
        that do not use the same case for table and column names as the ones 
        fetched from the database, set <literal>caseSensitiveParsing</literal> 
        to <literal>true</literal>.</para>
      <para>A timeout in seconds can be defined for begin/commit/rollback 
        operations. If no value is given, the default timeout is set to 60 
        seconds. Warning! A value of 0 means no timeout and waits forever until 
        completion.</para>
      <para>The request manager element definition is as follows:</para>
      <programlisting>
&lt;!ELEMENT RequestManager (RequestScheduler, RequestCache?, LoadBalancer, RecoveryLog?)>
&lt;!ATTLIST RequestManager
    backgroundParsing    (true | false) #IMPLIED
    caseSensitiveParsing (true | false) #IMPLIED
    beginTimeout      CDATA #IMPLIED
    commitTimeout     CDATA #IMPLIED
    rollbackTimeout   CDATA #IMPLIED
>
      </programlisting>
      
      <!-- ========== Macros Handler ========== -->
      <section id="dtd_macrohandler">
        <title>Macros Handler</title>
        <para> Sequoia can interpret and replace on-the-fly macros with a value 
          computed by the controller (the RequestManager in fact). This 
          prevents different backends to generate different values when 
          interpreting the macros which could result in data inconsistencies. 
          The supported macros are the following: </para>
        <itemizedlist>
          <listitem>
            <para><literal>rand</literal>: RAND() can be replaced with an int, long, float or 
              double value.</para>
          </listitem>
	</itemizedlist>
	<para>all the date macros (now, currentDate, currentTime, timeOfDay 
              and currentTimestamp) can be replaced by one of the following: 
        </para>
	<itemizedlist>
          <listitem>    
            <para><literal>off</literal>: do not replace the macro</para>
            <para><literal>date</literal>: java.sql.Date.toString() build from current time at 
              controller (example: 2001-02-17)</para>
            <para><literal>time</literal>: java.sql.Time.toString() build from current time at 
              controller (example: 19:07:32).</para>
            <para><literal>timestamp</literal>: java.sql.Timestamp.toString() build from current 
              time at controller (example: 2001-02-17 19:07:32-05).</para>
          </listitem>
          <listitem>
            <para><literal>timeResolution</literal>:defines the timer precision to 
              use when rewriting a query that contains a date macro. Default is 
              0 millisecond which is the highest precision. A value of 1000 
              corresponds to a 1 second precision, 60000 to a 1 minute 
              precision and so on. </para>
          </listitem>
        </itemizedlist>
	
	<para>The MacroHandling element definition is as follows:</para>
        <programlisting> 
&lt;!ELEMENT MacroHandling EMPTY> 
&lt;!ATTLIST MacroHandling 
        rand (off | int | long | float | double) "float" 
        now  (off | date | time | timestamp) "timestamp" 
        currentDate (off | date | time | timestamp) "date" 
        currentTime (off | date | time | timestamp) "time" 
        timeOfDay (off | date | time | timestamp) "timestamp" 
        currentTimestamp (off | date | time | timestamp) "timestamp" 
        timeResolution CDATA "0" 
> 
         </programlisting>
	 
	 <note>
        <para>A default Macrohandling element is instantiated and used if nothing is
	specified in the configuration file.</para>
       </note>
      </section>
      
      <!-- ===== Request Schedulers ===== -->
      <section id="dtd_requestscheduler">
        <title>Request Scheduler</title>
        <para>The request scheduler is responsible for scheduling the requests 
          and ensuring a serializable execution order. Different schedulers are 
          provided for each RAIDb level (see <xref linkend="raidb_basics"/>). 
          Optimized schedulers are also provided for use with a single database 
          backend (SingleDB configuration).</para>
        <para>The request scheduler element definition is as follows:</para>
	<programlisting>
&lt;!ELEMENT RequestScheduler (SingleDBScheduler | RAIDb-0Scheduler |
                            RAIDb-1Scheduler | RAIDb-2Scheduler)>

&lt;!ELEMENT SingleDBScheduler EMPTY>
&lt;!ATTLIST SingleDBScheduler
    level (passThrough | pessimisticTransaction) #REQUIRED
>

&lt;!ELEMENT RAIDb-0Scheduler EMPTY>
&lt;!ATTLIST RAIDb-0Scheduler 
    level (passThrough) #REQUIRED
>

&lt;!ELEMENT RAIDb-1Scheduler EMPTY>
&lt;!ATTLIST RAIDb-1Scheduler
    level (passThrough) #REQUIRED
>

&lt;!ELEMENT RAIDb-2Scheduler EMPTY>
&lt;!ATTLIST RAIDb-2Scheduler
    level (passThrough) #REQUIRED
>
	</programlisting>
        <para>Here is a brief definition of the meaning of each 
          scheduler:</para>
        <itemizedlist>
          <listitem>
            <para><literal>passThrough</literal>: queries are just assigned a 
              unique identifier and forwarded as is to the load balancer 
              letting each database perform the scheduling and the locking. 
              Therefore you will obtain the locking granularity provided by 
              the database which should be row-level locking. The load balancer
              will just ensure that the writes are sent in the same order to 
              all backends.</para>
          </listitem>
          <listitem>
            <para><literal>pessimisticTransaction</literal>: this is a 
              pessimistic transactional level scheduler that schedules 
              transactions in a safe way (without possible deadlocks) but 
              providing less parallelism for writes compared to optimistic 
              scheduling (this is only sensitive on write heavy workloads). 
            </para>
          </listitem>
        </itemizedlist>
      </section>
      <!-- ===== Request Caches ===== -->
      <section id="dtd_requestcache">
        <title>Request Cache</title>
        <para>A Request Cache can be composed of different caches that differ 
          in the type of data they cache:</para>
          <itemizedlist>
            <listitem>
              <para><literal>MetadataCache:</literal> this cache improves the 
                ResultSet creation time by keeping the various field 
                information with their metadata. It is strongly encouraged to 
                use this cache that reduces both CPU and memory usage.</para>
            </listitem>
            <listitem>
              <para><literal>ParsingCache:</literal> allows to parse a request 
                only once for all its executions. This reduces the CPU load on 
                the controller.</para>
            </listitem>
            <listitem>
              <para><literal>ResultCache:</literal> this cache keeps the 
                results associated to a given request. Cache entries can be 
                invalidated according to various policies. This cache reduces 
                the load on the database backends.</para>
            </listitem>
          </itemizedlist>
          <para>A RequestCache element is defined as follows:</para>
        <programlisting>
&lt;!ELEMENT RequestCache (MetadataCache?, ParsingCache?, ResultCache?)&gt;
        </programlisting>
        <section id="dtd_metadatacache">
          <title>Metadata Cache</title>
          <para>The MetadataCache caches ResultSet metadata and fields meta 
            information associated to a query execution so that each time a 
            query is executed, we don't have to gather all metadata from the 
            underlying driver and we can build Sequoia ResultSet much more 
            efficiently both in terms of speed and memory usage. Note that if 
            you use PreparedStatements, the query skeleton is used for matching 
            the cache instead of the instantiated query.</para>
          <para> Example: <literal>SELECT * FROM t WHERE x=?</literal> hits on 
            the same cache entry for all queries of this form for any value of 
            x.</para>
          <para>A MetadataCache element is defined as follows:</para>
          <programlisting>
&lt;!ELEMENT MetadataCache EMPTY&gt;
&lt;!ATTLIST MetadataCache
    maxNbOfMetadata CDATA "10000"
    maxNbOfField    CDATA "0"
&gt;            
          </programlisting>
          <para><literal>maxNbOfMetadata:</literal> maximum number of metadata 
            entries to keep in the cache (default is 10000 and 0 means 
            unlimited)</para>
          <para><literal>maxNbOfField:</literal> maximum number of field 
            entries to keep in the cache (0 means unlimited and is the default 
            setting).</para>
        </section>
        <section id="dtd_parsingcache">
          <title>Parsing Cache</title>
          <para>Parsing requests is a resource consuming process. The 
            ParsingCache caches the result of the parsing processing so that a 
            request is only parsed once for all its executions. If you are 
            using PreparedStatements, the ParsingCache can store the query 
            skeleton meaning that the cached parsing will match any instances 
            of the skeleton. </para>
          <para> Example: <literal>SELECT * FROM t WHERE x=?</literal> will be 
            parsed only once for any value of x.</para>
          <para>A MetadataCache element is defined as follows:</para>
          <programlisting>
&lt;!ELEMENT ParsingCache EMPTY&gt;
&lt;!ATTLIST ParsingCache
    backgroundParsing (true | false) "false"
    maxNbOfEntries    CDATA "5000"       
&gt;            
          </programlisting>
          <para> Request parsing can be done sequentially when needed 
            (backgroundParsing set to false which is the default value) or 
            forced to be performed in background by a separate thread (it means 
            a new thread is created for each request that need to be 
            parsed).</para>
          <para> <literal>maxNbOfEntries:</literal> Defines the maximum number 
            of entries to keep in the cache. The cache uses a LRU (Least 
            Recently Used) replacing policy meaning that the oldest entries 
            from the cache are removed when it is full. Default is 0 and means 
            no limit on cache size. </para>
        </section>
        <section id="dtd_resultcache">
          <title>Result Cache</title>
          <para>The ResultCache caches results of queries. A query and its ResultSet are
            stored in the cache so that if the sames query is executed, the ResultSet stored in
            the cache is returned.</para>
          <para>ResultCacheRule elements define the cache coherency and policy. Default
            cache behavior is eager consistency for all queries (ResultSet returned by the
            cache are always coherent and up-to-date). See below (ResultCacheRule
            element) to relax the cache consistency to achieve better performance.</para>
          <note><para> Note that ResultSet caching is disabled if no result cache element is
          found in the configuration file</para></note>
          <para>If two exact same requests are to be executed at the same time, only one is
            executed and the second one waits until the completion of the first one (this is
            the default <literal>pendingTimeout</literal> value which is 0). To prevent
            the second request from waiting forever, a
            <literal>pendingTimeout</literal> value in seconds can be defined for the
            waiting request. If the timeout expires, the request is executed in parallel
            with the first one.</para>
          <para>A result cache element is described as follows:</para>
          
          <programlisting>
&lt;!ELEMENT ResultCache (DefaultResultCacheRule?, ResultCacheRule*)&gt;
&lt;!ATTLIST ResultCache 
    granularity   (database | table | column | columnUnique) "database"
    maxNbOfEntries CDATA "100000"
    pendingTimeout CDATA "0"
&gt;
        </programlisting>
          <para revisionflag="changed">The result cache
            <literal>granularity</literal> defines how entries are removed from the
            cache. <literal>database</literal> flush the whole cache on every write
            access. This is the default cache setting. <literal>table</literal> and
            <literal>column</literal> provide table-based and column-based
            invalidations, respectively. <literal>columnUnique</literal> can
            optimize requests that select a unique primary key (useful with EJB entity
            beans). </para>
          <para>You can specify the maximum number of entries (default is 100000) to limit
            the cache size. This is obviously not as efficient as setting a cache size, but in
            the latter case we would have to spend a lot of time computing size of result sets
            from queries (Java does not provide a sizeof operator!). We offer size display in
            bytes when viewing the cache from the console though.</para>
          <para revisionflag="added">Finer grain tuning of the cache is based on rules
            matching query pattern. A queryPattern are regular expressions to match
            according to Jakarta Regexp (see <ulink
              url="http://jakarta.apache.org/regexp">their web site</ulink> for more
            information). A default cache rule defines the policy if no other rule
            matches:</para>
          
          <programlisting>
	&lt;!ELEMENT DefaultResultCacheRule (NoCaching | EagerCaching | RelaxedCaching)&gt;
	&lt;!ATTLIST DefaultResultCacheRule
	    timestampResolution CDATA "1000"
	&gt;
	
	&lt;!ELEMENT ResultCacheRule (NoCaching | EagerCaching | RelaxedCaching)&gt;
	&lt;!ATTLIST ResultCacheRule
	    queryPattern        CDATA #REQUIRED
	    caseSensitive       (true | false) "false"
	    applyToSkeleton     (true | false) "false"
	    timestampResolution CDATA "1000"
	&gt;
        </programlisting>
          <itemizedlist>
            <listitem>
              <para><literal>queryPattern</literal>: the regular expression to
                match.</para>
            </listitem>
            <listitem>
              <para><literal>caseSensitive</literal>: true if the pattern matching
                must be case sensitive</para>
            </listitem>
            <listitem>
              <para><literal>applytoSkeleton</literal>: true if the pattern must apply
                to the query skeleton (found in PrepareStatement), false if the
                instantiated query should be used. Example: skeleton is <literal>SELECT *
                FROM t WHERE x=?</literal> and instantiated query is <literal>SELECT *
                FROM t WHERE x=12</literal>.</para>
            </listitem>
            <listitem>
              <para><literal>timestampResolution</literal>: If a query contains a
                NOW() macro, it is replaced with the current date on the controller.
                timestampResolution indicates the resolution (in milliseconds) to use
                when replacing NOW() with the current date. If the resolution is below 1
                second (value &lt;1000ms), the request is never kept in the cache because
                there is almost no chance that the same request will come with the same
                timestamp. Note that this timestamp is for the cache only and you can use a
                greater resolution for the load balancer (see below).</para>
            </listitem>
          </itemizedlist> <note>
          <para>If timestampResolution is set to 60000, every execution of a query like
            <literal>SELECT * FROM x WHERE date=NOW()</literal> will be replaced with the
            same value for 1 minute (i.e. <literal>SELECT * FROM x WHERE date="2012-11-15
            08:03:00.000"</literal>) and therefore the cache entry may be hit for 1 minute.
            </para> </note>
          <para>To define a default rule that disable caching use:</para>
          
          <programlisting>
&lt;DefaultResultCacheRule&gt;
  &lt;NoCaching/&gt;
&lt;/DefaultResultCacheRule&gt;
	</programlisting>
          <para>If no default rule is provided, the following default rule is
            assumed:</para>
          
          
          <programlisting>
&lt;ResultCacheRule queryPattern="default" timestampResolution="1000"&gt;
  &lt;EagerCaching/&gt;
&lt;/ResultCacheRule&gt;
	</programlisting>
          
          <para>Each cache rule can have a different caching behavior. The available
            behavior are the following:</para>
          
          <programlisting>
&lt;!ELEMENT NoCaching EMPTY&gt;
&lt;!ELEMENT EagerCaching EMPTY&gt;
&lt;!ELEMENT RelaxedCaching EMPTY&gt;
&lt;!ATTLIST RelaxedCaching 
     timeout        CDATA "60"
     keepIfNotDirty (true | false) "true"
&gt;
	</programlisting>
          <itemizedlist>
            <listitem>
              <para><literal>NoCaching</literal> means we do not put the match in the
                cache</para>
            </listitem>
            <listitem>
              <para><literal>EagerCaching</literal> means that all entries in the cache
                are always coherent and any update query (insert,delete,update,...) will
                automatically invalidate the corresponding entry in the cache. This was
                the previous cache behavior for all queries</para>
            </listitem>
            <listitem>
              <para><literal>RelaxedCaching</literal> means that a
                <option>timeout</option> is set for this entry and the entry is kept in the
                cache until the timeout expires. When the timeout expires, if no write has
                modified the corresponding result and <option>keepIfNotDirty</option>
                is set to true, the entry is kept in the cache and the timeout is rearmed
                (reset) with its initial value.</para>
            </listitem>
          </itemizedlist> <note>
          <para>RelaxedCaching may provide stale data. The timeout defines the maximum
            staleness of a cache entry. It means that the cache may return an entry that is out
            of date.</para> </note>
          <para>Here is a cache rule example:</para>
          
          <programlisting>
&lt;ResultCacheRule queryPattern="select ? from b where id=?" applyToSkeleton="true"&gt;
  &lt;RelaxedCaching timeOut="6000" keepIfNotDirty="true"/&gt;
&lt;/ResultCacheRule&gt;
	</programlisting>
        </section>
      </section>
      <!-- ===== Load Balancers ===== -->
      <section id="dtd_loadbalancer">
        <title>Load Balancer</title>
        <para>The load balancer defines the way requests will be distributed among the
          backends according to a RAIDb level (see <xref linkend="raidb_basics"/>). It is
          possible to enforce a specific transaction isolation level on all connections
          (note that this will have no effect if the underlying database does not support this
          transaction isolation). By default, the default transaction isolation level
          will be used and no specific isolation will be enforced on the connections. The
          following load balancers are available:</para>
        <itemizedlist>
          <listitem>
            <para><literal>SingleDB</literal>: load balancer for a single 
                database backend instance. This is only available if you use a 
                single controller.</para>
          </listitem>
          <listitem>
            <para><literal>ParallelDB</literal>: load balancer to use with a 
              parallel database such as Oracle Parallel Server or Middle-R. 
              Both read and write are load balanced on the backends, letting 
              the parallel database replicating writes.</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-0</literal>: full database partitioning (no 
              table can be replicated) with an optional policy specifying where 
              new tables are created.</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-1</literal>: full database mirroring (all 
              tables are replicated everywhere) with an optional policy 
              specifying how distributed queries (writes/commit/rollback) 
              completion is handled (when the first, a majority or all backends 
              complete).</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-1ec</literal>: full database mirroring (like 
              RAIDb-1) with error checking for byzantine failure 
              detection.</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-2</literal>: partial replication (each table 
              must be at least replicated once) with optional policies for new 
              table creation (like RAIDb-0) and distributed queries completion 
              (like RAIDb-1).</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-2ec</literal>: partial replication (like 
              RAIDb-2) with error checking for byzantine failure 
              detection.</para>
          </listitem>
        </itemizedlist>
        <para>The load balancer element definition is as follows:</para>
	<programlisting>
&lt;!ELEMENT LoadBalancer (SingleDB | ParallelDB | RAIDb-0 | RAIDb-1 | RAIDb-1ec | RAIDb-2 | RAIDb-2ec)>
&lt;!ATTLIST LoadBalancer
   transactionIsolation (databaseDefault | readUncommitted | readCommitted | repeatableRead | serializable) "databaseDefault"
>
	</programlisting>
        <!-- ===== SingleDB ===== -->
        <section id="dtd_loadbalancer_SingleDB">
          <title><literal>SingleDB</literal> load balancer</title>
          <para>The <literal>SingleDB</literal> load balancer does not need any 
            specific parameter. The definition of the 
            <literal>SingleDB</literal> element is as follows:</para>
          <programlisting> &lt;!ELEMENT SingleDB EMPTY> </programlisting>
        </section>
        <!-- ===== ParallelDB ===== -->
        <section id="dtd_loadbalancer_ParallelDB">
          <title><literal>ParallelDB</literal> load balancer</title>
          <para>The <literal>ParallelDB</literal> load balancer must be used 
            with a SingleDB request scheduler. This load balancer provides two 
            implementations: <literal>ParallelDB-RoundRobin</literal> and 
            <literal>ParallelDB-LeastPendingRequestsFirst</literal> providing 
            round robin and least pending request first load balancing 
            policies, respectively. ParallelDB load balancers are designed to 
            provide load balancing and failover on top of parallel databases 
            such as Oracle Parallel Server or Middle-R. It means that read and 
            write requests are just sent to one alive backends, the parallel 
            database being responsible for maintaining the consistency between 
            the backends. The definition of the <literal>ParallelDB</literal> 
            element is as follows:</para>
          <programlisting>
&lt;!ELEMENT ParallelDB (ParallelDB-RoundRobin | ParallelDB-LeastPendingRequestsFirst)>

&lt;!ELEMENT ParallelDB-RoundRobin EMPTY>
&lt;!ELEMENT ParallelDB-LeastPendingRequestsFirst EMPTY>
          </programlisting>
          <para>No specific settings are required for these load balancers.
            They do not require request parsing which means that requests are
            just forwarded as is to the backends (rewriting rules are still
            applied but no automatic transformation is performed).</para>
        </section>
        <!-- == RAIDb-0 == -->
        <section id="dtd_loadbalancer_RAIDb0">
          <title><literal>RAIDb-0</literal> load balancer</title>
          <para>The <literal>RAIDb-0</literal> load balancer accepts a policy 
            to specify where new tables are created. The definition of the 
            <literal>RAIDb-0</literal> element is as follows:</para>
	  <programlisting>
&lt;!ELEMENT RAIDb-0 (MacroHandling?,CreateTable*)>

&lt;!ELEMENT CreateTable (BackendName*)>
&lt;!ATTLIST CreateTable 
    tableName     CDATA #IMPLIED
    policy        (random | roundRobin | all) #REQUIRED
    numberOfNodes CDATA #REQUIRED
>
    
&lt;!-- BackendName simply identifies a backend by its logical name -->
&lt;!ELEMENT BackendName EMPTY>
&lt;!ATTLIST BackendName
    name CDATA #REQUIRED
>
</programlisting>
          <para>If <literal>MacroHandling</literal> is omitted, a default
            MacroHandling element is added.</para>
          <para><literal>CreateTable</literal> defines the policy to adopt when 
            creating a new table. This policy is based on the given list of 
            <literal>BackendName</literal> nodes (which might be a subset of 
            the complete set of backends). If the backend list is omitted, then 
            all enabled backends are taken at decision time. The attributes 
            have the following meaning:</para>
          <itemizedlist>
            <listitem>
              <para><literal>numberOfNodes</literal> represents the number of 
                backends to pickup from the <literal>BackendName</literal> list 
                to apply the policy (it must be set to 1 for 
                <literal>RAIDb-0</literal> load balancers and can never be 
                greater than the number of nodes declared in the 
                <literal>BackendName</literal> list).</para>
            </listitem>
            <listitem>
              <para><literal>policy</literal> works as follows:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>random</literal>: 
                    <literal>numberOfNodes</literal> backends are picked up 
                    randomly from the <literal>BackendName</literal> list and 
                    the table is created on these nodes.</para>
                </listitem>
                <listitem>
                  <para><literal>roundRobin</literal>: 
                    <literal>numberOfNodes</literal> backends are picked up 
                    from the <literal>BackendName</literal> list using a 
                    round-robin algorithm and the table is created on these 
                    nodes.</para>
                </listitem>
                <listitem>
                  <para><literal>all</literal>: the table is created on 
                    <emphasis>all</emphasis> nodes in the 
                    <literal>BackendName</literal> list 
                    (<literal>numberOfNodes</literal> is ignored).</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
          <para>Here is an example of a <literal>RAIDb-0</literal> controller 
            with three nodes where new tables are created randomly on the first 
            two nodes:</para>
	  <programlisting>
...
&lt;DatabaseBackend name="node1" ...
&lt;DatabaseBackend name="node2" ...
&lt;DatabaseBackend name="node3" ...
...

&lt;LoadBalancer>
  &lt;RAIDb-0>
    &lt;CreateTable policy="random" numberOfNodes="1">
      &lt;BackendName name="node1" />
      &lt;BackendName name="node2" />
    &lt;/CreateTable>
  &lt;/RAIDb-0>
&lt;/LoadBalancer>
	  </programlisting>
        </section>
        <!-- == RAIDb-1 == -->
        <section id="dtd_loadbalancer_RAIDb1">
          <title><literal>RAIDb-1:full mirroring </literal> load balancer</title>
          <para>A RAIDb-1 load balancer is defined as follows:</para>
          
          
          <programlisting>
&lt;!ELEMENT RAIDb-1 (WaitForCompletion?, MacroHandling?, (RAIDb-1-RoundRobin | 
           RAIDb-1-WeightedRoundRobin | RAIDb-1-LeastPendingRequestsFirst))>

&lt;!ELEMENT RAIDb-1-RoundRobin EMPTY>
&lt;!ELEMENT RAIDb-1-WeightedRoundRobin (BackendWeight)>
&lt;!ELEMENT RAIDb-1-LeastPendingRequestsFirst EMPTY>

&lt;!ELEMENT WaitForCompletion EMPTY>
&lt;!ATTLIST WaitForCompletion
    policy (first | majority | all) "first"
    deadlockTimeoutInMs CDATA "30000"
>

&lt;!ELEMENT BackendWeight EMPTY>
&lt;!ATTLIST BackendWeight
    name   CDATA #REQUIRED
    weight CDATA #REQUIRED
>
          </programlisting>
          <para>If <literal>WaitForCompletion</literal> is omitted, the default
            behaviour is to return the result as soon as one backend has completed.
            deadlockTimeout defines the time in milliseconds to wait before starting the
            deadlock detection computation. This should typically be larger than the
            database deadlock timeout settings. Default is 30000 (30 seconds) but should
            typically be larger than the largest query execution time. 0 disables the
            deadlock detection.</para>
          <para>If MacroHandling is omitted, a default MacroHandling element is
            added.</para>
          <para>The <literal>RAIDb-1</literal> load balancer accepts a policy to specify
            distributed queries completion. Several load balancing policies are
            proposed:</para>
          <itemizedlist>
            <listitem>
              <para><literal>RoundRobin</literal>: simple round-robin load
                balancing. The first request is sent to the first node, the second request to
                the second node, etc... Once a request has been sent to the last backend, the
                next request is sent to the first backend and so on.</para>
            </listitem>
            <listitem>
              <para><literal>WeightedRoundRobin</literal>: same as round-robin but a
                weight is associated to each backend. A backend that has a weight of 2 will get
                two times more requests than a backend with a backend with a weight of
                1.</para>
            </listitem>
            <listitem>
              <para><literal>LeastPendingRequestsFirst</literal>: the request is
                sent to the backend that has the least pending requests to execute (that can
                be considered as the shortest pending request queue).</para>
            </listitem>
          </itemizedlist>
          <para>The definition of the <literal>RAIDb-1</literal> element is as
            follows:</para>
          <para><literal>WaitForCompletion</literal> defines the policy to adopt when
            waiting for the completion of a request. Policy works as follows:</para>
          <itemizedlist>
            <listitem>
              <para><literal>first</literal>: returns the result as soon as one node has
                completed.</para>
            </listitem>
            <listitem>
              <para><literal>majority</literal>: returns the result as soon as a
                majority of nodes (n/2+1) has completed.</para>
            </listitem>
            <listitem>
              <para><literal>all</literal>: waits for all nodes to complete before
                returning the result to the client.</para>
            </listitem>
          </itemizedlist>
        </section>
        <!-- == RAIDb-1ec == -->
        <section id="dtd_loadbalancer_RAIDb1ec">
          <title><literal>RAIDb-1ec</literal> load balancer</title>
          <para>The RAIDb-1 with error checking must provide an error checking 
            policy (defined below). The optional 
            <literal>WaitForCompletion</literal> policy only concern write 
            requests (<literal>INSERT</literal>, <literal>DELETE</literal>, 
            <literal>UPDATE</literal>, commit, ...).</para>
          <note>
            <para><literal>RAIDb-1ec</literal> is not operational in Sequoia 
              v1.0alpha.</para>
          </note>
          <para>The definition of the <literal>RAIDb-1ec</literal> element is 
            as follows:</para>
	  <programlisting>
&lt;!ELEMENT RAIDb-1ec (WaitForCompletion?, ErrorChecking, (RAIDb-1ec-RoundRobin | 
                     RAIDb-1ec-WeightedRoundRobin))>
&lt;!ATTLIST RAIDb-1ec
    nbOfConcurrentReads CDATA #REQUIRED
>

&lt;!ELEMENT RAIDb-1ec-RoundRobin EMPTY>
&lt;!ELEMENT RAIDb-1ec-WeightedRoundRobin (BackendWeight)>

&lt;!ELEMENT ErrorChecking EMPTY>
&lt;!ATTLIST ErrorChecking 
    policy        (random | roundRobin | all) #REQUIRED
    numberOfNodes CDATA #REQUIRED
>
	  </programlisting>
          <para>Error checking policy (for RAIDb-1ec and RAIDb2-ec). Error 
            checking is used to detect byzantine failures of nodes. It means 
            detecting when a node sends funny results in a non-deterministic 
            way. Error checking allows read queries to be sent to more than one 
            database, and the results are compared. A majority of nodes must 
            agree on the result that will be sent to the client. Error checking 
            policies are defined as follows:</para>
          <itemizedlist>
            <listitem>
              <para><literal>random</literal>: <literal>numberOfNodes</literal> 
                backends are picked up randomly; the read request is sent to 
                these backends and results are compared.</para>
            </listitem>
            <listitem>
              <para><literal>roundRobin</literal>: 
                <literal>numberOfNodes</literal> backends are picked up using a 
                round-robin algorithm ; the read request is send to these 
                backends and results are compared.</para>
            </listitem>
            <listitem>
              <para><literal>all</literal>: the request is sent to 
                <emphasis>all</emphasis> nodes 
                (<literal>numberOfNodes</literal> is ignored) and the results 
                compared.</para>
            </listitem>
          </itemizedlist>
          <para><literal>numberOfNodes</literal> must be greater or equal to 
            3.</para>
        </section>
        <!-- == RAIDb-2 == -->
        <section id="dtd_loadbalancer_RAIDb2">
          <title><literal>RAIDb-2 : distributed mirroring</literal> load balancer</title>
          <para>The definition of the <literal>RAIDb-2</literal> element is as 
            follows:</para>
	  <programlisting>
&lt;!ELEMENT RAIDb-2 (CreateTable*, WaitForCompletion?, MacroHandling?, (RAIDb-2-RoundRobin | 
 RAIDb-2-WeightedRoundRobin | RAIDb-2-LeastPendingRequestsFirst))>


&lt;!ELEMENT RAIDb-2-RoundRobin EMPTY>
&lt;!ELEMENT RAIDb-2-WeightedRoundRobin (BackendWeight)>
&lt;!ELEMENT RAIDb-2-LeastPendingRequestsFirst EMPTY>
	  </programlisting>
          
          <para>If MacroHandling is omitted, a default MacroHandling element is added.</para>
          <para>The <literal>RAIDb-2</literal> load balancer accepts a policy 
            to specify where new tables are created and how distributed queries 
            completion should be handled. Several load balancing policies are 
            proposed:</para>
          <itemizedlist>
            <listitem>
              <para><literal>RoundRobin</literal>: simple round-robin load 
                balancing. The first request is sent to the first node, the 
                second request to the second node, etc... Once a request has 
                been sent to the last backend, the next request is sent to the 
                first backend and so on.</para>
            </listitem>
            <listitem>
              <para><literal>WeightedRoundRobin</literal>: same as round-robin 
                but a weight is associated to each backend. A backend that has 
                a weight of 2 will get two times more requests than a backend 
                with a backend with a weight of 1.</para>
            </listitem>
            <listitem>
              <para><literal>LeastPendingRequestsFirst</literal>: the request 
                is sent to the backend that has the least pending requests to 
                execute (that can be considered as the shortest pending request 
                queue).</para>
            </listitem>
          </itemizedlist>
          <para>The <literal>CreateTable</literal> element definition is 
            defined in <xref linkend="dtd_loadbalancer_RAIDb0"/>.</para>
          <para>The <literal>WaitForCompletion</literal> element definition is 
            defined in <xref linkend="dtd_loadbalancer_RAIDb1"/>.</para>
        </section>

        <!-- == RAIDb-2ec == -->
        <section id="dtd_loadbalancer_RAIDb2ec">
          <title><literal>RAIDb-2ec</literal> load balancer</title>
          <para>The RAIDb-2 with error checking must provide an error checking 
            policy as in <literal>RAIDb-1ec</literal> (see <xref 
            linkend="dtd_loadbalancer_RAIDb1ec"/>). The other elements are 
            similar to those defined for <literal>RAIDb-2</literal> controller 
            (see <xref linkend="dtd_loadbalancer_RAIDb2"/>).</para>
          <note>
            <para><literal>RAIDb-2ec</literal> is not operational in Sequoia 
              v1.0alpha.</para>
          </note>
          <para>The definition of the <literal>RAIDb-2ec</literal> element is 
            as follows:</para>
	  <programlisting>
&lt;!ELEMENT RAIDb-2ec (CreateTable*, WaitForCompletion?, ErrorChecking,
                     (RAIDb-2ec-RoundRobin | RAIDb-2ec-WeightedRoundRobin))>
&lt;!ATTLIST RAIDb-2ec 
    nbOfConcurrentReads CDATA #REQUIRED
>

&lt;!ELEMENT RAIDb-2ec-RoundRobin EMPTY>
&lt;!ELEMENT RAIDb-2ec-WeightedRoundRobin (BackendWeight)>
	  </programlisting>
        </section>
      </section>
      <!-- ===== Recovery Log ===== -->
      <section id="dtd_recoverylog">
        <title>Recovery Log</title>
        <para>The Sequoia Recovery Log stores write queries and transactions 
          between logical checkpoints defined by the user. The log can be 
          only be stored in a database (or cluster of databases) using a 
          <literal>JDBCRecoveryLog</literal> element.</para>
        <para>The definition of a <literal>RecoveryLog</literal> element is as 
          follows:</para>
	<programlisting>
&lt;!ELEMENT RecoveryLog (JDBCRecoveryLog)>
	</programlisting>
        <section id="dtd_jdbcrecoverylog">
          <title>Recoverylog</title>
          <para>The RecoveryLog stores the recovery information in a database. To
            access this database, you must provide the driver class name to load (driver), an
            optional jar file or directory where to find the class to load (driverPath), the
            JDBC url to access the database as well as a valid login/password.</para>
          <para>A timeout in seconds can be defined for the sql requests. If no value is given,
            the default timeout is set to 60 seconds. Warning! 0 means no timeout and wait
            forever until completion.</para>
          <para> recoveryBatchSize is used to speedup the recovery process and allow
            several queries to be accumulated into a batch on the recovering backend.
            Increasing this value beyond a certain limit will not increase performance and
            will consume a significant amount of memory. Default is 10 and minimum is 1.
            </para>
          <para>The recovery information is stored in 4 tables defined in the
            RecoveryLogTable, CheckpointTable, BackendLogTable and DumpTable
            elements.</para>
          <para>The definition of a <literal>RecoveryLog</literal> element is as
            follows:</para>
          
          <programlisting>
&lt;!ELEMENT RecoveryLog (RecoveryLogTable, CheckpointTable, BackendTable, DumpTable)>

&lt;!ATTLIST RecoveryLog 
    driver            CDATA #REQUIRED
    driverPath        CDATA #IMPLIED
    url               CDATA #REQUIRED
    login             CDATA #REQUIRED
    password          CDATA #REQUIRED
    requestTimeout    CDATA "60"
    recoveryBatchSize CDATA "10"
>
&lt;!ELEMENT RecoveryLogTable EMPTY>
&lt;!ATTLIST RecoveryLogTable 
    createTable              CDATA "CREATE TABLE"
    tableName                CDATA "logtable"
    logIdColumnType          CDATA "BIGINT NOT NULL"
    vloginColumnType         CDATA "VARCHAR NOT NULL"
    sqlColumnName            CDATA "sql"
    sqlColumnType            CDATA "VARCHAR NOT NULL"
    autoConnTranColumnType   CDATA "CHAR(1) NOT NULL"
    transactionIdColumnType  CDATA "BIGINT NOT NULL"
    requestIdColumnType      CDATA "BIGINT"
    execTimeColumnType       CDATA "BIGINT"
    updateCountColumnType    CDATA "INT"
    extraStatementDefinition CDATA ",PRIMARY KEY (log_id)"
>

&lt;!ELEMENT CheckpointTable EMPTY>
&lt;!ATTLIST CheckpointTable 
    createTable              CDATA "CREATE TABLE"
    tableName                CDATA "checkpointtable"
    checkpointNameColumnType CDATA "VARCHAR NOT NULL"
    logIdColumnType          CDATA "BIGINT"
    extraStatementDefinition CDATA ",PRIMARY KEY (name)"
>

&lt;!ELEMENT BackendTable EMPTY>
&lt;!ATTLIST BackendTable 
    createTable                  CDATA "CREATE TABLE"
    tableName                    CDATA "backendtable"  
    databaseNameColumnType       CDATA "VARCHAR NOT NULL"
    backendNameColumnType        CDATA "VARCHAR NOT NULL"
    backendStateColumnType       CDATA "INTEGER"
    checkpointNameColumnType     CDATA "VARCHAR NOT NULL"
    extraStatementDefinition     CDATA ""
>

&lt;!ELEMENT DumpTable EMPTY>
&lt;!ATTLIST DumpTable
    createTable              CDATA "CREATE TABLE"
    tableName                CDATA "dumptable"
    dumpNameColumnType       CDATA "VARCHAR NOT NULL"
    dumpDateColumnType       CDATA "TIMESTAMP"
    dumpPathColumnType       CDATA "VARCHAR NOT NULL"
    dumpFormatColumnType     CDATA "VARCHAR NOT NULL"
    checkpointNameColumnType CDATA "VARCHAR NOT NULL"  
    backendNameColumnType    CDATA "VARCHAR NOT NULL"
    tablesColumnName         CDATA "tables"
    tablesColumnType         CDATA "VARCHAR NOT NULL"
>
	  </programlisting>
          <para>The <literal>RecoveryLog</literal> element requires the following
            attributes:</para>
          <itemizedlist>
            <listitem>
              <para><option>driver</option>: the driver class name</para>
            </listitem>
            <listitem>
              <para><option>url</option>: the JDBC URL to access the database</para>
            </listitem>
            <listitem>
              <para><option>login</option>: the user login to connect to the
                database</para>
            </listitem>
            <listitem>
              <para><option>password</option>: the user password to connect to the
                database</para>
            </listitem>
            <listitem>
              <para><option>requestTimeout</option>: optional timeout request in
                second that will be used to replay the log queries. Default timeout is 60
                seconds and 0 means no timeout (wait forever until a request
                complete).</para>
            </listitem>
            <listitem>
              <para><option>recoveryBatchSize</option>: used to speedup the recovery
                process and allow several queries to be accumulated into a batch on the
                recovering backend. Increasing this value beyond a certain limit will not
                increase performance and will consume a significant amount of memory.
                Default is 10 and minimum is 1. </para>
            </listitem>
          </itemizedlist>
          <para>The <literal>RecoveryLogTable</literal> defines how the
            JDBCRecoveryLog log table is created. The log table name
            (<option>tableName</option>) must conform to the syntax of a database table
            name. The log table stores a unique request id (<option>id</option>), the
            virtual login (<option>vlogin</option>)to use to execute the sql statement
            (<option>sql</option>) in the given transaction
            (<option>transactionId</option>). The statement used by the
            RecoveryLog to create the log table uses the RecoveryLogTable attributes
            as follows:</para>
          
          <programlisting>
  createTable tableName (
    log_id         logIdColumnType,
    vlogin         vloginColumnType,
    sqlColumnName  sqlColumnType,
    auto_conn_tran autoConnTranColumnType,
    transaction_id transactionIdColumnType,
    request_id     requestIdColumnType,
    exec_time      execTimeColumnType,
    update_count   updateCountColumnType,
    extraStatementDefinition)
    	</programlisting>
          <para>If all default values are used, the log table is created using the following
            statement:</para>
          
          <programlisting>
  CREATE TABLE logtable (
    log_id         BIGINT NOT NULL UNIQUE,
    vlogin         VARCHAR NOT NULL, 
    sql            VARCHAR NOT NULL, 
    auto_conn_tran CHAR(1) NOT NULL,
    transaction_id BIGINT NOT NULL
    request_id     BIGINT,
    exec_time      BIGINT,
    update_count   INT,
    PRIMARY KEY (log_id)
    )
    	</programlisting>
          <para>The <literal>CheckpointTable</literal> stores the checkpoint name and
            the corresponding index in the recovery log table. The statement used by the
            JDBCRecoveryLog to create the checkpoint table uses the CheckpointTable
            attributes as follows:</para>
          
          <programlisting>
  CREATE TABLE <option>tableName</option> (
    name   <option>checkpointNameColumnType</option>,
    log_id <option>logIdColumnType</option>
    <option>extraStatementDefinition</option>)
	  </programlisting>
          <para>If all default values are used, the log table is created using the following
            statement:</para>
          
          <programlisting>
  CREATE TABLE checkpointtable (
    name   VARCHAR NOT NULL,
    log_id BIGINT,
    PRIMARY KEY(name))
    	</programlisting>
          
          <para> The <literal>BackendLogTable</literal> stores the states of the
            different backends of a virtual database. It stores the name of the backend, the
            database it belongs to and the last known checkpoint of a backend when the backend
            is disabled, and the state the backend was in when the database was last shutdown.
            If all default values are used, the log table is created using the following
            statement: </para>
          
          <programlisting>
  CREATE TABLE backendtable (
    database_name   VARCHAR NOT NULL,
    backend_name    VARCHAR NOT NULL,
    backend_state   INTEGER,
    checkpoint_name VARCHAR NOT NULL
    )
  </programlisting>
          
          <para>Here is an example on how to define a JDBCRecoveryLog to work with a HSQL
            database:</para>
          
          <programlisting>
&lt;RecoveryLog>
   &lt;RecoveryLog driver="org.hsqldb.jdbcDriver" url="jdbc:hsqldb:hsql://localhost" login="sa" password="">
      &lt;RecoveryLogTable 
         tableName="recovery"
         logIdColumnType="INTEGER NOT NULL" 
         sqlColumnType="VARCHAR NOT NULL" 
        extraStatementDefinition=",PRIMARY KEY (id)"/>
      &lt;CheckpointTable tableName="checkpoint"/>
	  &lt;BackendLogTable tableName="backendTable"/>
   &lt;/JDBCRecoveryLog>
&lt;/RecoveryLog>
          </programlisting>
          <para> The <literal>DumpTable</literal> stores the dump names and associated
            meta-data such as the corresponding checkpoint name. The statement used by the
            JDBCRecoveryLog to create the dump table uses the DumpTable attributes as
            follows:</para>
          
          <programlisting>
  createTable tableName (
    dump_name       dumpNameColumnType,
    dump_date       dumpDateColumnType,
    dump_path       dumpPathColumnType,
    dump_format     dumpTypeColumnType,
    checkpoint_name checkpointNameColumnType,
    backend_name    backendNameColumnType,
    tables          tablesColumnType
    extraStatementDefinition)
            </programlisting>
          <para> dump_name is the dump logical name, dump_date the date at which the backup
            was started, dump_path the path where the dump can be found, dump_format an
            implementation specific text form that specifies the method used for the dump,
            checkpoint_name is the name of the checkpoint associated to this dump, tables is
            the list of tables that are contained in this dump (* means all tables). If all
            default values are used, the log table is created using the following statement:</para>
          <programlisting>
  CREATE TABLE DumpTable (
    dump_name       VARCHAR NOT NULL,
    dump_date       TIMESTAMP,
    dump_path       VARCHAR NOT NULL,
    dump_format     VARCHAR NOT NULL,
    checkpoint_name VARCHAR NOT NULL,
    backend_name    VARCHAR NOT NULL,
    tables          VARCHAR NOT NULL
    )
          </programlisting>
          </section>
      </section>
    </section>
    <!-- ========== Configuration Examples ========== -->
    <section id="ssl_configuration">
       <title>SSL Configuration</title>
    	<para>
    	SSL may be used for encryption as well as authentication for all connections to sequoia.
    	</para>
    	<para>
        SSL support for sequoia is based on the Java Secure Socket Extension (JSSE). JSSE has been integrated into the Java 2 SDK, Standard Edition, v 1.4. For java 1.3 it can be installed as an optional package. (available at http://java.sun.com/products/jsse/)
    	</para>
     	<section id="ssl_controller">
           <title>Controller</title>
     	   <para>
           On the controller side ssl can be configured for all jmx connections and the virtual database accessed via the sequoia driver with the xml element SSL in the controller configuration :
     	   </para>
     	   <programlisting>
              &lt;!ELEMENT SSL EMPTY>
              &lt;!ATTLIST SSL
                  keyStore              CDATA        #IMPLIED
                  keyStorePassword      CDATA        #IMPLIED
                  keyStoreKeyPassword   CDATA        #IMPLIED
                  isClientAuthNeeded    (true|false) "false"
                  trustStore            CDATA        #IMPLIED
                  trustStorePassword    CDATA        #IMPLIED
              >
            </programlisting>
            <itemizedlist>
                <listitem>
                	<para>keyStore: The file where the keys are stored</para>
                </listitem>
                <listitem>
                	<para>keyStorePassword: the password to the keyStore</para>
                </listitem>
                <listitem>
                	<para>keyStoreKeyPassword: the password to the private key, if none is specified the same password as for the store is used</para>
                </listitem>
                <listitem>
                	<para>isClientAuthNeeded: if set to false ssl is used for encryption only, it true set to true then the server is only accepting trusted clients (the client certificate has to be in the trusted store)</para>
                </listitem>
                 <listitem>
                	<para>trustStore: the file where the trusted certificates are stored, if none is specified the same store as for the key is used</para>
                </listitem>
                 <listitem>
                	<para>trustStorePassword: the password to the trustStore, if none is specified the same password as for the keyStore is used</para>
                </listitem>
             </itemizedlist>
        </section>
    	<section id="ssl_console_clients">
            <title>Console / Jmx Clients</title>
     	    <para>
              The console and other jmx clients are configured with the use of java properties :
    	    </para>
            <itemizedlist>
                <listitem>
                	<para>javax.net.ssl.keyStore</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.keyStorePassword</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.trustStore</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.trustStorePassword</para>
                </listitem>
             </itemizedlist>
     	    <para>
              Example :
              -Djavax.net.ssl.trustStore=client.keystore -Djavax.net.ssl.trustStorePassword=clientpassword
    	    </para>
        </section>
    	<section id="ssl_driver">
            <title>Driver</title>
     	    <para>
              SSL on the driver side is configured with java properties 
    	    </para>
            <itemizedlist>
                <listitem>
                	<para>sequoia.ssl.enabled=true</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.keyStore</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.keyStorePassword</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.trustStore</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.trustStorePassword</para>
                </listitem>
             </itemizedlist>
     	    <para>
              Example :
              -Djavax.net.ssl.keyStore=client.keystore -Djavax.net.ssl.keyStorePassword=clientpassword
    	    </para>
        </section>
    	<section id="ssl_certificates">
            <title>Certificates (public and private keys)</title>
     	    <para>
              You may create your certificates with the keytool (part of JSSE)
    	    </para>
            <orderedlist>
                <listitem><para>
                	Create a self-signed server and a self-signed client key each in its own keystore</para>
                   <programlisting>
$&gt; keytool -genkey -v -keyalg RSA -keystore server.keystore -dname "CN=Server, OU=Bar, O=Foo, L=Some, ST=Where, C=UN"
$&gt; keytool -genkey -v -keyalg RSA -keystore client.keystore -dname "CN=Client, OU=Bar, O=Foo, L=Some, ST=Where, C=UN"
                   </programlisting>
                   
                </listitem>
                <listitem>
                  <para>
                	Export the server's and the client's public keys from their respective keystores</para>
                   <programlisting>
$&gt; keytool -export -rfc -keystore server.keystore -alias mykey -file server.public-key
$&gt; keytool -export -rfc -keystore client.keystore -alias mykey -file client.public-key
                   </programlisting>
                   
                </listitem>
                <listitem>
                  <para>
                	Import the client's public key to the server's keystore, and vice-versa:</para>
                   <programlisting>
$&gt; keytool -import -alias client -keystore server.keystore -file client.public-key
$&gt; keytool -import -alias server -keystore client.keystore -file server.public-key
                   </programlisting>
                   
                </listitem>
             </orderedlist>
         </section>
    </section>
    <!-- ========== Configuration Examples ========== -->
    <section id="configuration_examples">
      <title>Configuration Examples</title>
      <para>Configuration files examples are available in the Sequoia 
        distribution in the <filename 
        class="directory">/sequoia/doc/examples</filename> directory.</para>
      <para>Here is a brief overview of each example content:</para>
      <itemizedlist>
        <listitem>
          <para><filename>Cache</filename>: gives various configuration examples on
            how to use the cache.</para>
        </listitem>
        <listitem>
          <para><filename>Derby</filename> : contains examples for the Apache Derby
            database including the ones used in the ApacheCon demos.</para>
        </listitem>
        <listitem>
          <para><filename>HorizontalScalbility</filename> : provides configuration
            files to create a distributed virtual database on 2 controllers. One file should
            be loaded on each of the two controllers.</para>
        </listitem>
        <listitem>
          <para><filename>LinuxService</filename> and <filename>SuSE</filename> :
            contains examples to run Sequoia controller as a Linux service.</para>
        </listitem>
        <listitem>
          <para><filename>SingleDB</filename>: a Sequoia configuration with a unique
            MySQL backend.</para>
        </listitem>
        <listitem>
          <para><filename>RAIDb-0</filename>: Sequoia configuration examples for
            RAIDb-0.</para>
          <itemizedlist>
            <listitem>
              <para><filename>RAIDb-0.xml</filename>: a simple 2 nodes RAIDb-0
                configuration.</para>
            </listitem>
            <listitem>
              <para><filename>RAIDb-0-schema.xml</filename>: a 2 nodes RAIDb-0
                configuration using a static database schema definition matching the
                RUBiS benchmark database schema.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><filename>RAIDb-1</filename>: contains various RAIDb-1 configuration
            examples.</para>
        </listitem>
        <listitem>
          <para><filename>RAIDb-2</filename>: contains various RAIDb-2 configuration
            examples.</para>
        </listitem>
        <listitem>
          <para><filename>RecoveryLog</filename>: gives an example of a fault tolerant
            recovery log.</para>
        </listitem>
      </itemizedlist>
      </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Glossary -->
  <!-- =============================================================== -->
  <section id="glossary">
    <title>Glossary</title>
    <para><xref linkend="glossary_table"/> summarizes all the acronyms used in 
      this document.</para>
    <table id="glossary_table">
      <title>List of acronyms used in this document</title>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>C-JDBC</entry>
            <entry>Clustered Java DataBase Connectivity</entry>
          </row>
          <row>
            <entry>CVS</entry>
            <entry>Concurrent Versions System</entry>
          </row>
          <row>
            <entry>INRIA</entry>
            <entry>French National Institute for Research in Computer Science 
              and Control</entry>
          </row>
          <row>
            <entry>JDBC</entry>
            <entry>Java DataBase Connectivity (not officially recognized as 
              such)</entry>
          </row>
          <row>
            <entry>JMX</entry>
            <entry>Java Management eXtensions</entry>
          </row>
          <row>
            <entry>JRE</entry>
            <entry>Java Runtime Environment</entry>
          </row>
          <row>
            <entry>JVM</entry>
            <entry>Java Virtual Machine</entry>
          </row>
          <row>
            <entry>LGPL</entry>
            <entry>GNU Lesser General Public License</entry>
          </row>
          <row>
            <entry>RAIDb</entry>
            <entry>Redundant Array of Inexpensive Databases</entry>
          </row>
          <row>
            <entry>RDBMS</entry>
            <entry>Relational DataBase Management System</entry>
          </row>
          <row>
            <entry>RMI</entry>
            <entry>Remote Method Invocation</entry>
          </row>
          <row>
            <entry>SQL</entry>
            <entry>Standard Query Language</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>
  <!-- =============================================================== -->
  <!-- Section: About Sequoia -->
  <!-- =============================================================== -->
  <section id="about_sequoia">
    <title>About Sequoia</title>
    <!-- ========== License ========== -->
    <section id="license">
      <title>License</title>
      <para>Sequoia is free software. You can redistribute it and/or modify it under the
        terms of the <ulink url="http://www.apache.org/licenses/LICENSE-2.0.html">
        Apache v2 license</ulink>.</para>
      <para>Sequoia is copyrighted by the <ulink 
        url="http://www.inria.fr/">French National Institute For Research In 
        Computer Science And Control</ulink> (INRIA) and Continuent.</para>
    </section>
    <!-- ========== Web Site ========== -->
    <section id="web_sites">
      <title>Web Site</title>
      <para>The Sequoia project is hosted on the Continuent.org web site at the following
        URL: <ulink url="http://sequoia.continuent.org/"/>. To facilitate the
        development, a Sequoia project has also be created on the <ulink
          url="https://forge.continuent.org/">Continuent Forge</ulink>. This GForge
        integrates with <ulink url="https://forge.continuent.org/jira/browse/SEQUOIA">
        JIRA</ulink> for bug tracking.</para>
    </section>
    <!-- ========== Mailing Lists ========== -->
    <section id="mailing_lists">
      <title>Mailing Lists</title>
      <para>Two mailing lists are currently available for Sequoia. Both lists 
        are archived for public review at the <ulink 
        url="http://sequoia.continuent.org/">Sequoia's Web site</ulink>.</para>
      <itemizedlist>
        <listitem>
          <para><email>sequoia@continuent.org</email> is the user mailing list. 
            It is the source to get the latest information about Sequoia, send 
            your feedback and get support from the Sequoia community.</para>
        </listitem>
        <listitem>
          <para><email>sequoia-commits@continuent.org</email> is a developer 
            mailing list that reports every commit in the Sequoia CVS 
            repository.</para>
        </listitem>
      </itemizedlist>
      <para>Feedback is crucial to improve Sequoia. Please send us your comments 
        or any other form of input to: 
        <email>sequoia@continuent.org</email>.</para>
    </section>
    <!-- ========== Reporting a Bug ========== -->
    <section id="reporting_bug">
      <title>Reporting a Bug</title>
      <para><ulink url="https://forge.continuent.org/jira/browse/SEQUOIA">
        JIRA</ulink> provides support for bug tracking. We strongly encourage you to use the
        automatic Report feature (see <xref linkend="dtd_controller_report"></xref>)
        that provides all the details we usually need to figure out what happened. If you
        cannot use this feature, please include the following information when reporting a
        bug (when applicable):</para>
      <itemizedlist>
        <listitem>
          <para>The Sequoia driver and controller version.</para>
        </listitem>
        <listitem>
          <para>The XML file you used to configure the Sequoia controller.</para>
        </listitem>
        <listitem>
          <para>JDK vendor and version (example: Sun JDK 1.4.2_08). If you use 
            different JDK for driver and controller, please give as much detail 
            as possible.</para>
        </listitem>
        <listitem>
          <para>OS vendor and version (examples: Linux 2.6.12 or <trademark 
            class="registered">Windows XP</trademark> SP2). If you use different 
            operating systems for clients, controllers and backends, give the 
            appropriate information.</para>
        </listitem>
        <listitem>
          <para>Database backend version and driver (example: PostgreSQL 8.0.3 Linux 
            with JDBC driver postgresql-8.0-312.jdbc3.jar).</para>
        </listitem>
        <listitem>
          <para>Detailed error description with possibly the exception stack 
            trace or a logging trace with debugging enabled.</para>
        </listitem>
      </itemizedlist>
    </section>
    <!-- ========== Getting Involved ========== -->
    <section id="getting_involved">
      <title>Getting Involved</title>
      <para>Sequoia is an open source project and welcomes external 
        contributions. Please read the Sequoia Developer's Guide and join 
        us!</para>
      <para>Basically, any feature you need but you do not find implemented in Sequoia may
        become a contribution topic. Simply send your ideas, documents and developments (if
        any) to the <email>sequoia@continuent.org</email> mailing list. Available tasks
        and the roadmap is available on <ulink
          url="https://forge.continuent.org/jira/browse/SEQUOIA">JIRA</ulink>.
        Please use also this tool for feature requests and bug reports/fixes.</para>
      <para>You can finally subscribe to the sequoia-commits mailing list if you want to
        receive notifications of the CVS changes.</para>
    </section>
    <!-- ========== About Continuent ========== -->
    <section id="about_continuent">
      <title>About Continuent.org</title>
      <para><ulink url="http://www.continuent.org/">Continuent.org</ulink>
        Continuent.org is an open source portal and community dedicated to high
        availability and scalability services for databases and other closely related
        technologies. Continuent.org is sponsored by <ulink
          url="http://www.continuent.com/">Continuent</ulink>.</para>
    </section>
    <!-- ========== About INRIA ========== -->
    <section id="about_inria">
      <title>About INRIA</title>
      <para><ulink url="http://www.inria.fr/">INRIA</ulink> is the French National
        Institute for Research in Computer Science and Control. The <ulink
          url="http://sardes.inrialpes.fr/">Sardes project</ulink> at INRIA
        Rhones-Alpes has defined the RAIDb concept and developed C-JDBC. Sequoia is a
        continuation of the C-JDBC project.</para>
    </section>
    <!-- ========== About ObjectWeb ========== -->
    <section id="about_objectweb">
      <title>About ObjectWeb</title>
      <para>The goal of the <ulink url="http://www.objectweb.org/">ObjectWeb 
        Consortium</ulink> is the development of open source distributed 
        middleware, in the form of adaptable and flexible components. ObjectWeb 
        components range from specific software frameworks and protocols to 
        integrated platforms. More information on ObjectWeb and its projects is 
        available at the ObjectWeb's Web site.</para>
    </section>
  </section>
</article>
